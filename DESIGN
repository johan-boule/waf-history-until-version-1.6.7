## Thomas Nagy, 2005, 2006 (ita)

ADDITIONAL FEATURES OVER SCONS
------------------------------

* fast rescan for incremental builds (developer working on the project)
* kernel-like output and progress bar (-v switch to display command-lines)
* builddir set by default and with no effort
* find source files intelligently (glob-like) to ease script maintainance - kde module only at the moment
* customizable command-line parsing using sconfigure (works now!)
* tight control over the scheduler (not all links at the same time, etc)
* support for objective caml targets (no ocamldeps yet)

DATA STRUCTURE
--------------

S1: Action      = { f1:display_command_line ; f2:compute_signature ; f3:launch_commands }
S0: Environment = { HashMap{String -> Any} }
S2: Task        = { Action ; Environment ; Source[] ; Target[] }
S3: Object      = { Object[]; Task[] }
S4: Build       = { Environment ; Deptree ; BuildDirectory[] }
S5: Deptree     = { SourceNode[Tree] ; TargetNode[][Tree] }

MODULE STUCTURE
---------------

Scripting.py   : entry point of the scripts, calls user code before launching the targets

Node.py        : definition of the tree. The class should be as small as possible (tree is stored on-disk).

Deptree.py     : dependency tree handler, contains the trees of sources and targets
  the files are scanned only once
  the complete tree of dirs and files is loaded on memory
  this tree is stored in a file .dblite, and updated on next runs
  it can be modified in-place during the compilation phase itself

Environment.py : environment definition - environment copy is to be cheap

Object.py      : objects create tasks using actions and (default) environments
  It is also possible to force a particular environment over some objects

Action.py      : code used for building targets
  Generic actions take a list of environment variables to substitute upon usage
  they contain 3 essential functions:
  * signature
  * code for building objects
  * code that prints a message in the console
  The signature takes the environment variables to sign (given in the constructor); it is meant to run fast.
  To avoid subclassing actions, and if the target to build requires several functions or some python code,
  it is possible to attach a function to action.m_function_to_run   

Task.py        : action + environment + input objects + output objects
  the tasks associate input files (id), output files (id), an action and an environment

Build.py       : holds the data structures for building targets (deptree) and the configuration.
  it is the entry point of the application

Test.py        : some tests - uses files from the subdirectory 'test'
  go in the Test.py folder and run './Test.py'

Common.py      : common builders for C, C++, etc

Params.py      : all constants and global variables, trace functions
  there is no singleton, but the variables can be reset in Utils (for tests)
  for now there will be a reset function in every module that keeps its own variables
  public variables (shared by many modules) go into Params

Options.py     : command-line parser, sets g_commands and g_options in Params.py

Utils.py       : utilities

DESIGN DECISIONS
----------------

-> There are even constraint solvers in python, thus writing a fast tool
   for building targets without tons of overriding functions is doable
-> Object-oriented target declaration (Object.py) when possible
-> As few string transformations as possible to keep the tool fast
-> When starting from a branch, higher levels are considered up2date
   concerning the symlinking or mirroring.
-> Groups of tasks to processs together before attempting to process another one
   this is needed for bootstrapping (an executable is produced and used)
-> Control over the scheduler (do not link everything at the same time for example)
-> New tasks can be added while building other ones
-> '#include "file.moc"' versus 'include <file.moc>' (quotes to adds the local dependency)
-> Environments are modified according to conditions, here are some examples:
    * builddir_1, builddir_2, builddir_3
    * win32, darwin, linux, freebsd
    * ultradebug, debug, release, optimized
    * compile to bytecode in one dir, compile to native code in some other dir (for example, caml)
   Aliases are made using a hashtable to keep pre-defined environment values
-> Trick to start building targets even if all objects are not declared - calling a special function
   puts all tasks that are already declared into a list to be processed immediately by the scheduler
-> Explicit dependency handling as much as possible - tasks have a priority so it is easy to
   enforce a partial order for tasks to execute in parallel
-> It is better to have modules than grepping and executing code
-> Signature file size for the different schemes (.dblite):
 simple  32bits: 1713 44755
 md5str 128bits: 2272 58893
  ... so using md5 does not increase the db file significantly for small projects


FUNCTIONS TO PROVIDE IN WSCRIPT
-------------------------------
The scripts are now real python modules, so waf will import the wscripts
and run functions from them. The scripts may be compiled into python
bytecode in the future (quick startup).
Here are the function definitions
* set_options(opt_object)
    called for setting custom command-line options, 
    it takes an option object as input and adds options on it
    to collect options from a submodule located in folder 'src', use conf.sub_options('src')
    the opt.add_option(.. calls forward the parameters to an optparse object, see
    http://docs.python.org/lib/module-optparse.html
* configure(conf_obj)
    called for configuring the project, the command "waf configure" must be called from
    the folder of the project to configure (will not climb up)
    to use the configuration function from a submodule located in folder 'src', use
    conf.sub_config('src')
* init()
    called right after command-line arguments are parsed and before anything is built
    this function may contain a sys.exit
* shutdown()
    called after all targets are built
* build(bld_object)
    nothing is attached to the build object *yet*
* clean() (not used at the moment)
* dist()
    optional, for use when the default dist scheme is not enough
* distclean()
    optional, for use when the default distclean scheme is not enough

Additionally, the mandatory parameters need to be given:
* the source directory: srcdir = '.'
* the build directory (where to put object files): blddir = '_build_'
* the cache directory (where to put the configuration files): cachedir = os.sep.join(['_build_', 'cache'])

The following parameters are mandatory for the dist targets:
* APPNAME: name of the application (used by 'dist')
* VERSION: version of the application (used by 'dist')

IMPORTANT:
since it is certainly annoying to make a "build" function for each folder containing target definitions,
waf is also looking for a "wscript_build" file to replace the build function
more naming should follow (ie: wscript_configure instead of a "configure" function)

Proposal for Named environments
-------------------------------

in the configure function:
conf.newconf('main', env=None)
conf.detect('gcc')
conf.newconf('gtk', env='main')
conf.detect('pkg-config')
conf.detect('libxml2')
conf.newconf('kde', env='main')
conf.detect('g++')
conf.detect('qt')
-> three independent environents are created, the first one is considered
to be the default for projects

QUESTIONS
---------

* How to set the profiler (see TODO)
STATE OF THE APPLICATION
------------------------

== Engine ==                            95%
* mirror files and directories..........done
* create and run tasks..................done
* store node state between runs.........done
* scan for dependencies.................done
* process tasks in order................done
* install files.........................done
* parallel builds.......................done
* support for running unit tests........?
* script system.........................done

== Configuration ==                     95%
* read and write cache files............done
* tools system..........................done
* custom options (user-defined).........done
* framework for configuring projects....done
* functions for finding headers.........done
* functions for finding programs........done
* functions for using pkg-config........done
* process qmake configuration files.....?

== Unit tests ==                        0%
* file system representation............
* scanning for c/cpp headers............
* parallel builds.......................
* configuration system..................

STATE OF THE TOOLS
------------------

== Generic Tools ==                     60%
* basic builders for c, c++ objects.....done
* libtool support.......................
* shared and static libraries...........done
* ocaml.................................done
* latex.................................done
* java..................................

== KDE3 ==                              100%
* moc, uic..............................done
* skel, stub............................done
* kconfig_compiler......................done
* translations, documentation...........done
* kde3 documentation (meinproc).........done

== Qt4/KDE4 ==                          20%
* rcc...................................done
* kdeinit libraries.....................bits
* libtool file handling.................fake at the moment, real libtool file handling should come along

Note: native builds on win32 are not really supported at the moment (only cygwin)

