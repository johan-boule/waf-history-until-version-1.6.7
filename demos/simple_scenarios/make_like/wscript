#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2008 (pvm)

# Illustrate how to enable a makefile-like syntax
#
# WARNING: this wscript file is the source of some of the tasks
# if you modify it, the files will be rebuilt
#

VERSION= '0.0.1'
APPNAME= 'make_like'
srcdir = '.'
blddir = 'build'

def set_options(opt):
	pass

def configure(conf):
	pass

def build(bld):

	# a source file and one output
	bld.new_task_gen(
		source='wscript',
		target='test.k1',
		rule='cp ${SRC} ${TGT}'
	)

	# a source file but no outputs
	bld.new_task_gen(
		source='wscript',
		rule='echo ${SRC}'
	)

	# no source file but one output (execute when PREFIX changes)
	bld.new_task_gen(
		target='test.k3',
		rule='echo ${PREFIX} > ${TGT}',
	)

	# no inputs and no outputs (execute when PREFIX changes)
	bld.new_task_gen(
		rule='echo ${PREFIX}'
	)

	# no input and no output, ('always' attribute -> the task is always executed)
	bld.new_task_gen(
		rule="echo 'task always run'",
		always=True
	)

	# a source file and a target with a more complicated
	# rule and a constraint on the order (before)
	# a cwd attribute may be provided to set the directory to execute from
	bld.new_task_gen(
		source='wscript',
		target='test.k',
		rule='./create.py && mv ${TGT[0].abspath()} ${TGT[0].abspath(env)}',
		cwd=bld.path.abspath(),
		before='test.k1'
	)

	# no input and no output, the task executes a function
	def run(self):
		print 'hi there'

	bld.new_task_gen(
		name='hi',
		rule=run
	)


########### support code below ###############

from TaskGen import feature, before, taskgen
import Constants
import Task

@taskgen
@feature('*')
@before('apply_core')
def exec_rule(self):
	if not getattr(self, 'rule', None):
		return

	# get the function and the variables
	func = self.rule
	vars2 = []
	if isinstance(func, str):
		(func, vars2) = Task.compile_fun('', self.rule)
	vars = getattr(self, 'vars', vars2)

	# create the task class
	name = getattr(self, 'name', None) or self.target or self.rule
	cls = Task.task_type_from_func(name, func, vars)

	# now create one instance
	tsk = self.create_task(name)

	# we assume that the user knows that without inputs or outputs
	#if not getattr(self, 'target', None) and not getattr(self, 'source', None):
	#	cls.quiet = True

	if getattr(self, 'target', None):
		cls.quiet = True
		tsk.outputs=[self.path.find_or_declare(x) for x in self.to_list(self.target)]

	if getattr(self, 'source', None):
		cls.quiet = True
		tsk.inputs=[self.path.find_resource(x) for x in self.to_list(self.source)]

	if getattr(self, 'always', None):
		always_run(cls)

	if getattr(self, 'cwd', None):
		tsk.cwd = self.cwd

	for x in ['after', 'before']:
		setattr(cls, x, getattr(self, x, []))

def always_run(cls):
	old = cls.runnable_status
	def always(self):
		old(self)
		return Constants.RUN_ME
	cls.runnable_status = always

def update_outputs(cls):
	"""When a command is always run, it is possible that the output only change
	sometimes. By default the build node have as a hash the signature of the task
	which may not change. With this, the output nodes (produced) are hashed,
	and the hashes are set to the build nodes

	This may avoid unnecessary recompilations, but it uses more resources
	(hashing the output files) so it is not used by default
	"""
	old_post_run = cls.post_run
	def post_run(self):
		old_post_run(self)
		Build.bld.node_sigs[self.env.variant()][self.outputs[0].id] = \
		Utils.h_file(self.outputs[0].abspath(self.env))
	cls.post_run = post_run

