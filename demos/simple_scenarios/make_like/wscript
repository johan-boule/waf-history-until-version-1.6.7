#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2008 (pvm)

# Illustrate how to enable a makefile-like syntax
#
# WARNING: this wscript file is the source of some of the tasks
# if you modify it, the files will be rebuilt
#

VERSION= '0.0.1'
APPNAME= 'make_like'
srcdir = '.'
blddir = 'build'

def set_options(opt):
	pass

def configure(conf):
	pass

def build(bld):

	# a source file and one output
	bld.new_task_gen(
		source='wscript',
		target='test.k1',
		rule='cp ${SRC} ${TGT}'
	)

	# a source file but no outputs
	bld.new_task_gen(
		source='wscript',
		rule='echo ${SRC}'
	)

	# no source file but one output (execute when PREFIX changes)
	bld.new_task_gen(
		target='test.k3',
		rule='echo ${PREFIX} > ${TGT}',
	)

	# no inputs and no outputs (execute when PREFIX changes)
	bld.new_task_gen(
		rule='echo ${PREFIX}'
	)

	# no input and no output, ('always' attribute -> the task is always executed)
	bld.new_task_gen(
		rule="echo 'task always run'",
		always=True
	)

	# a source file and a target with a more complicated
	# rule and a constraint on the order (before)
	# a cwd attribute may be provided to set the directory to execute from
	bld.new_task_gen(
		source='wscript',
		target='test.k',
		rule='./create.py && mv ${TGT[0].abspath()} ${TGT[0].abspath(env)}',
		cwd=bld.path.abspath(),
		before='test.k1'
	)

	# no input and no output, the task executes a function
	def run(self):
		print 'hi there'

	bld.new_task_gen(
		name='hi',
		rule=run
	)

	# the dependant task copy_svnversion is executed
	# when the actual output of svnversion changes (on_results attribute)
	bld.new_task_gen(
		name='svnversion',
		target='ver.h',
		rule='svnversion > ${TGT[0].abspath(env)}',
		cwd=bld.path.abspath(),
		always=True,
		on_results=True
	)

	bld.new_task_gen(
		name='copy_svnversion',
		after='svnversion',
		source='ver.h',
		target='ver2.h',
		rule='cp ${SRC} ${TGT}'
	)

########### support code below ###############

from TaskGen import feature, before, taskgen
import Constants
import Task, Utils

@taskgen
@feature('*')
@before('apply_core')
def exec_rule(self):
	if not getattr(self, 'rule', None):
		return

	# get the function and the variables
	func = self.rule
	vars2 = []
	if isinstance(func, str):
		(func, vars2) = Task.compile_fun('', self.rule)
	vars = getattr(self, 'vars', vars2)

	# create the task class
	name = getattr(self, 'name', None) or self.target or self.rule
	cls = Task.task_type_from_func(name, func, vars)

	# now create one instance
	tsk = self.create_task(name)

	# we assume that the user knows that without inputs or outputs
	#if not getattr(self, 'target', None) and not getattr(self, 'source', None):
	#	cls.quiet = True

	if getattr(self, 'target', None):
		cls.quiet = True
		tsk.outputs=[self.path.find_or_declare(x) for x in self.to_list(self.target)]

	if getattr(self, 'source', None):
		cls.quiet = True
		tsk.inputs=[self.path.find_resource(x) for x in self.to_list(self.source)]

	if getattr(self, 'always', None):
		Task.always_run(cls)

	if getattr(self, 'cwd', None):
		tsk.cwd = self.cwd

	if getattr(self, 'on_results', None):
		Task.update_outputs(cls)

	for x in ['after', 'before']:
		setattr(cls, x, getattr(self, x, []))

