#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2008 (ita)

# illustrate how to enable a makefile-like syntax

VERSION= '0.0.1'
APPNAME= 'make_like'
srcdir = '.'
blddir = 'build'

def set_options(opt):
	pass

def configure(conf):
	pass

def build(bld):

	# a source file but no outputs
	bld.new_task_gen(
		source='wscript',
		rule='echo ${SRC}'
	)

	# a source file and one output
	bld.new_task_gen(
		source='wscript',
		target='test.k1',
		rule='echo ${SRC[0].abspath()}/${TGT[0].name} ${TGT};  cp ${SRC} ${TGT}'
	)

	# no source file but one output, the task is run whenever the variable changes
	bld.new_task_gen(
		target='test.k3',
		rule='echo ${PREFIX} > ${TGT}',
		vars=['PREFIX']
	)

	# no input and no output, the task is run when a variable changes
	bld.new_task_gen(
		rule='echo ${PREFIX}'
	)

	# a source file and a target with a more complicated rule
	bld.new_task_gen(
		source='wscript',
		target='test.k',
		rule='cd ${SRC[0].parent.abspath()} && ./create.py && mv ${TGT[0].abspath()} ${TGT[0].abspath(env)}',
		before='test.k1'
	)


########### support code below ###############

from TaskGen import feature, before, taskgen
import Task

@taskgen
@feature('*')
@before('apply_core')
def exec_rule(self):
	if not getattr(self, 'rule', None):
		return

	# get the function and the variables
	func = self.rule
	vars2 = []
	if isinstance(func, str):
		(func, vars2) = Task.compile_fun('', self.rule)
	vars = getattr(self, 'vars', vars2)

	# create the task class
	name = self.target or self.rule
	cls = Task.task_type_from_func(name, func, vars)

	# now create one instance
	tsk = self.create_task(name)

	# we assume that the user knows that without inputs or outputs
	#if not getattr(self, 'target', None) and not getattr(self, 'source', None):
	#	cls.quiet = True

	if getattr(self, 'target', None):
		cls.quiet = True
		tsk.outputs=[self.path.find_or_declare(x) for x in self.to_list(self.target)]

	if getattr(self, 'source', None):
		cls.quiet = True
		tsk.inputs=[self.path.find_resource(x) for x in self.to_list(self.source)]

	if getattr(self, 'always', None):
		always_run(cls)

	for x in ['after', 'before']:
		setattr(cls, x, getattr(self, x, []))

def always_run(cls):
	def always(self):
		return Constants.RUN_ME
	cls.runnable_status = always

