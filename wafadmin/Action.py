#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005 (ita)

import Object, Params, Runner
from Params import debug, error, trace, fatal

# more refactoring to come
class Action:
	def __init__(self, name, cmd=None, sig=None, str=None):
		# each action must have a user-friendly little name
		self.m_name = name

		# variables that should trigger a rebuild
		self.m_vars = []

		# if the action is simple, this is not defined, else a function
		# can be attached and will be launched instead of running the string generated by 'setstr'
		# see Runner for when this is used - a parameter is given, it is the task
		self.m_function_to_run = None

		# register ourselves
		self._add_action()

	def __str__(self):
		return self.m_name


	def _add_action(self):
		if self.m_name in Params.g_actions: error('overriding action '+self.m_name)
		Params.g_actions[self.m_name] = self
		trace("action added: %s" % self.m_name)

	# string to display to the user
	def get_str(self, task):
		src_str = " ".join(map(lambda a:a.bldpath(task.m_env), task.m_inputs))
		tgt_str = " ".join(map(lambda a:a.bldpath(task.m_env), task.m_outputs))
		return "* %s : %s -> %s" % (self.m_name, src_str, tgt_str)

	# prepare the compilation
	def prepare(self, task):
		task.m_sig = Object.sign_env_vars(task.m_env, self.m_vars)
		task.m_str = self.get_str(task)

	# run the compilation
	def run(self, task):
		if not self.m_function_to_run:
			fatal(self.m_name+" action has no function !")
		self.m_function_to_run(task)

# Actions declared using a string are compiled before use:
# * a class with the necessary functions is created (so the string is parsed only once)
# * all variables (CXX, ..) can be strings or lists of strings (only)
# * the keywords TGT and SRC cannot be overridden (they represent the task input and output nodes)
#
# Example:
# str = '${CXX} -o ${TGT[0]} ${SRC[0]} -I ${SRC[0].m_parent.bldpath()}'
# act = simple_action('name', str)

class alex:
	def __init__(self, s):
		self.str = s
		self.out = []
		self.params = []
		self.m_vars = []

		self.i = 0
		self.size = len(self.str)

	def start(self):
		while self.i < self.size:
			# quoted '$'
			c = self.str[self.i]
			if c == '\\':
				if self.i < self.size - 1 and self.str[self.i+1]=='$':
					self.out.append('$')
					self.i += 1
				else:
					self.out.append(c)
			elif c == '$':
				if self.str[self.i+1]=='{':
					self.i += 2
					self.varmatch()
				else:
					self.out.append(c)
			else:
				self.out.append(c)
			self.i += 1
	def varmatch(self):
		name = []
		meth = []

		cur = self.i
		while cur < self.size:
			if self.str[cur] == '}':
				s = ''.join(name)
				self.params.append( (''.join(name), ''.join(meth)) )
				self.out.append('%s')

				self.i = cur
				break
			else:
				c = self.str[cur]
				if meth:
					meth.append(c)
				else:
					if c=='.' or c =='[':
						meth.append(c)
					else:
						name.append(c)
			cur += 1
	def res(self):
		lst = ['def f(task):\n\tenv=task.m_env\n\tp=Object.flatten\n\t']

		#lst.append('print task.m_inputs\n\t')
		#lst.append('print task.m_outputs\n\t')

		lst.append('cmd = "')
		lst += self.out
		lst.append('"')

		alst=[]
		for (name, meth) in self.params:
			if name == 'SRC':
				if meth: alst.append('task.m_inputs%s' % meth)
				else: alst.append('" ".join(map(lambda a:a.srcpath(env), task.m_inputs))')
			elif name == 'TGT':
				if meth: alst.append('task.m_outputs%s' % meth)
				else: alst.append('" ".join(map(lambda a:a.bldpath(env), task.m_outputs))')
			else:
				self.m_vars.append(name)
				alst.append("p(env, '%s')" % name)
		if alst:
			lst.append(' % (\\\n\t\t')
			lst += ", \\\n\t\t".join(alst)
			lst.append(')\n')

		lst.append('\tRunner.exec_command(cmd)\n')

		return "".join(lst)

	def fun(self):
		exec(self.res())
		return eval('f')
			
def simple_action(name, line):
	obj = alex(line)
	obj.start()
	f = obj.fun()
	debug(obj.res())
	act = Action(name)
	act.m_function_to_run = f
	act.m_vars = obj.m_vars





# TODO obsolete (ita)
# most actions contain only one well-defined command-line taking sources as input and targets as output
class GenAction(Action):
	def __init__(self, name, vars, src_only=0, buildfunc=None):
		Action.__init__(self, name)
		self.m_vars     = vars
		self.m_src_only = src_only
		self.m_function_to_run = buildfunc
		
	def get_cmd(self, task):

		# the command should contain two '%s' for adding the source and the target
		if not task.m_env:
			error("task has no environment")

		cmd_list = Object.list_to_env_list( task.m_env, self.m_vars )

		#print cmd_list
		#l = task.m_env['LINK_ST']
		#print l
		#print task.m_env

		command = " ".join( cmd_list )

		# obtain the strings "file1.o file2.o" and "programname"
		src_str = " ".join(  map(lambda a:a.bldpath(task.m_env), task.m_inputs)  )
		tgt_str = " ".join(  map(lambda a:a.bldpath(task.m_env), task.m_outputs)  )

		# uncomment this for debugging purposes
		#print command, "      ",  self.m_vars

		# if the action processes only sources, return 'command %s' % src_str
		if self.m_src_only:
			print "Action: command is ", command
			return command % (src_str)

		# obtain the command-line "command %s -o %s" % (str, str) -> command file1.o file2.o -o programname
		#print " action is %s" % command
			
		try: 
			cmd = command % (src_str, tgt_str)
		except:
			print "exception #2 in Action "
			print src_str
			print tgt_str
			cmd = ""
		return cmd

	def run(self, task):
		if not self.m_function_to_run:
			cmd = self.get_cmd(task)
			Runner.exec_command(cmd)
		else:
			self.m_function_to_run(task)


