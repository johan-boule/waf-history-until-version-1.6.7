#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005 (ita)

"Actions are used to build the nodes of most tasks"

import re
import Object, Runner, Params
from Params import debug, fatal

g_actions={}
"global actions"

reg_act = re.compile(r"(?P<dollar>\$\$)|(?P<subst>\$\{(?P<var>\w+)(?P<code>.*?)\})", re.M)

class Action(object):
	"Base class for all Actions, an action takes a task and produces its outputs"
	def __init__(self, name, vars=[], func=None, color='GREEN'):
		"""If the action is simple, func is not defined, else a function can be attached
		and will be launched instead of running the string generated by 'setstr' see Runner
		for when this is used - a parameter is given, it is the task. Each action must name"""

		self.m_name = name
		# variables for triggering a rebuild
		self.m_vars = vars
		self.m_function_to_run = func
		self.m_color = color

		global g_actions
		if name in g_actions: debug('overriding action '+name, 'action')
		g_actions[name] = self
		debug("action added: %s" % name, 'action')

	def __str__(self):
		return self.m_name

	def get_str(self, task):
		"string to display to the user"
		src_str = " ".join([a.nice_path(task.m_env) for a in task.m_inputs])
		tgt_str = " ".join([a.nice_path(task.m_env) for a in task.m_outputs])
		return "* %s : %s -> %s" % (self.m_name, src_str, tgt_str)

	def run(self, task):
		"run the compilation"
		if not self.m_function_to_run: fatal(self.m_name+" action has no function !")
		return self.m_function_to_run(task)

class alex(object):
	"""
	Actions declared using a string (simple_action) are compiled before use:

	A class with the necessary functions is created (the string is parsed only once)
	The env variables (CXX, ..) can be strings or lists of strings (only)
	The keywords TGT and SRC represent the task input and output nodes (reserved keywords)

	Example:
	    code = '${CXX} -o ${TGT[0]} ${SRC[0]} -I ${SRC[0].m_parent.bldpath()}'
	    act = simple_action('name', code)
	"""
	def __init__(self, s):
		self.str = s
		self.out = []
		self.params = []
		self.m_vars = []

	def repl(self, match):
		g = match.group
		v = g('dollar')
		if v: return "$"
		elif g('subst'):
			self.params.append((g('var'), g('code')))
			return "%s"
		return None

	def code(self):
		if not self.out: self.out = reg_act.sub(self.repl, self.str)

		lst = ['def f(task):\n\tenv=task.m_env\n\tp=env.get_flat\n\t']
		ap = lst.append
		#ap('print task.m_inputs\n\t')
		#ap('print task.m_outputs\n\t')

		ap('try: cmd = "')
		lst += self.out
		ap('"')

		alst=[]
		for (var, meth) in self.params:
			if var == 'SRC':
				if meth: alst.append('task.m_inputs%s' % meth)
				else: alst.append('" ".join([a.srcpath(env) for a in task.m_inputs])')
			elif var == 'TGT':
				if meth: alst.append('task.m_outputs%s' % meth)
				else: alst.append('" ".join([a.bldpath(env) for a in task.m_outputs])')
			else:
				self.m_vars.append(var)
				alst.append("p('%s')" % var)
		if alst:
			ap(' % (\\\n\t\t')
			ap(' \\\n\t\t, '.join(alst))
			ap(')\n')

		ap('\texcept:\n')
		ap('\t\ttask.debug()\n')
		ap('\t\traise\n')

		ap('\treturn Runner.exec_command(cmd)\n')

		return "".join(lst)

	def get_fun(self):
		c = self.code()
		debug(c, 'action')
		exec(c)
		return f

def simple_action(name, line, color='GREEN', vars=[]):
	"helper provided for convenience"
	obj = alex(line)
	act = Action(name, color=color)
	act.m_function_to_run = obj.get_fun()
	act.m_vars = obj.m_vars
	if vars: act.m_vars = vars

