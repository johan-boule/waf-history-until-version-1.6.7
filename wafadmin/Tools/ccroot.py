#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005 (ita)

import os, types, sys, re
import ccroot
import Action, Object, Params, Scan, Common
from Params import debug, error, trace, fatal

# default priority for link tasks
# an even number means link tasks may be parallelized
# an odd number is probably the thing to do
g_prio_link=101

# default extensions for source files
g_src_file_ext = ['.c', '.cpp', '.cc']


def read_la_file(path):
	sp = re.compile(r'^([^=]+)=\'(.*)\'$')
	dc={}
	file = open(path, "r")
	for line in file.readlines():
		try:
			#print sp.split(line.strip())
			_, left, right, _ = sp.split(line.strip())
			dc[left]=right
		except:
			pass
	file.close()
	return dc

# fake libtool files
fakelibtool_vardeps = ['CXX', 'PREFIX']
def fakelibtool_build(task):
	# Writes a .la file, used by libtool
	dest  = open(task.m_outputs[0].abspath(task.m_env), 'w')
	sname = task.m_inputs[0].m_name
	fu = dest.write
	fu("# Generated by ltmain.sh - GNU libtool 1.5.18 - (pwn3d by BKsys II code name WAF)\n")
	if task.m_env['vnum']:
		nums=task.m_env['vnum'].split('.')
		libname = task.m_inputs[0].m_name
		name3 = libname+'.'+task.m_env['vnum']
		name2 = libname+'.'+nums[0]
		name1 = libname
		fu("dlname='%s'\n" % name2)
		strn = " ".join([name3, name2, name1])
		fu("library_names='%s'\n" % (strn) )
	else:
		fu("dlname='%s'\n" % sname)
		fu("library_names='%s %s %s'\n" % (sname, sname, sname) )
	fu("old_library=''\n")
	vars = ' '.join(task.m_env['libtoolvars']+task.m_env['LINKFLAGS'])
	fu("dependency_libs='%s'\n" % vars)
	fu("current=0\n")
	fu("age=0\nrevision=0\ninstalled=yes\nshouldnotlink=no\n")
	fu("dlopen=''\ndlpreopen=''\n")
	fu("libdir='%s/lib'\n" % task.m_env['PREFIX'])
	dest.close()
	return 0
# TODO move this line out
Action.Action('fakelibtool', vars=fakelibtool_vardeps, func=fakelibtool_build, color='BLUE')

# Parent class for programs and libraries in languages c, c++ and moc (Qt)
class ccroot(Object.genobj):
	s_default_ext = []
	def __init__(self, type='program'):
		Object.genobj.__init__(self, type)

		self.env = Params.g_build.m_allenvs['default'].copy()
		if not self.env['tools']: fatal('no tool selected')

		# installation directory, to override PREFIX/bin or PREFIX/lib
		self.install_in = ''

		# includes, seen from the current directory
		self.includes=''

		self.linkflags=''
		self.linkpaths=''

		self.rpaths=''

		self.uselib=''

		# new scheme: provide the names of the local libraries to link with
		# the objects found will be post()-ed
		self.uselib_local=''


		# add .o files produced by another Object subclass
		self.add_objects = ''

		self.m_linktask=None

		# libtool emulation
		self.want_libtool=0 # -1: fake; 1: real
		self.vnum=''

		self._incpaths_lst=[]
		self._bld_incpaths_lst=[]

		self.p_compiletasks=[]

		# do not forget to set the following variables in a subclass
		self.p_flag_vars = []
		self.p_type_vars = []

		# TODO ???
		self.m_type_initials = ''

		self.chmod = 0755

	# overrides Object.create_task to catch the creation of cpp tasks
	def create_task(self, type, env=None, nice=10):
		task = Object.genobj.create_task(self, type, env, nice)
		if type == self.m_type_initials:
			self.p_compiletasks.append(task)
		return task

	# subclass me
	def get_valid_types(self):
		fatal('subclass method get_valid_types of ccroot')

	# subclass if necessary
	def find_sources_in_dirs(self, dirnames, excludes=[]):
		lst=[]
		try:    exc_lst = excludes.split()
		except: exc_lst = excludes

		ext_lst = []
		ext_lst += self.self_default_ext
		try:
			for var in self.__class__.__dict__['all_hooks']:
				ext_lst += self.env[var]
		except:
			pass

		for name in dirnames.split():
			#print "name is ", name
			anode = Params.g_build.ensure_node_from_lst(self.m_current_path, name.split('/'))
			#print "anode ", anode.m_name, " ", anode.m_files
			Params.g_build.rescan(anode)
			#print "anode ", anode.m_name, " ", anode.m_files

			#node = self.m_current_path.find_node( name.split(os.sep) )
			for file in anode.m_files:
				#print "file found ->", file
				(base, ext) = os.path.splitext(file.m_name)
				if ext in ext_lst: 
					s = file.relpath(self.m_current_path)
					if not s in lst:
						if s in exc_lst: continue
						lst.append(s)

		self.source = self.source+' '+(" ".join(lst))

	# adding some kind of genericity is tricky
	# subclass this method if it does not suit your needs
	def apply(self):
		trace("apply called for "+self.m_type_initials)
		if not self.m_type in self.get_valid_types(): fatal('Invalid type for object: '+self.m_type_initials)

		self.apply_type_vars()
		self.apply_incpaths()

		if self.want_libtool and self.want_libtool>0: self.apply_libtool()

		obj_ext = self.env[self.m_type+'_obj_ext'][0]
		pre = self.m_type_initials

		# get the list of folders to use by the scanners
                # all our objects share the same include paths anyway
                tree = Params.g_build
                dir_lst = { 'path_lst' : self._incpaths_lst }

		lst = self.source.split()
		for filename in lst:

			node = self.m_current_path.find_node( filename.split(os.sep) )
			if not node:
				fatal("source not found: "+filename+" in "+str(self.m_current_path))

			base, ext = os.path.splitext(filename)

			fun = self.get_hook(ext)
			if fun:
				fun(self, node)
				continue

			if tree.needs_rescan(node, self.env):
				Scan.g_c_scanner.do_scan(node, self.env, hashparams = dir_lst)

			mlst = self.file_in(filename)
			node = mlst[0]

			# create the compilation task: cpp or cc
			task = self.create_task(self.m_type_initials, self.env)

			task.m_scanner        = Scan.g_c_scanner
			task.m_scanner_params = dir_lst

			task.set_inputs(node)
			task.set_outputs(node.change_ext(obj_ext))

		# and after the objects, the remaining is the link step
		# link in a lower priority (101) so it runs alone (default is 10)
		global g_prio_link
		if self.m_type=='staticlib': linktask = self.create_task(pre+'_link_static', self.env, g_prio_link)
		else:                        linktask = self.create_task(pre+'_link', self.env, g_prio_link)
		outputs = []
		for t in self.p_compiletasks: outputs.append(t.m_outputs[0])
		linktask.set_inputs(outputs)
		linktask.set_outputs(self.file_in(self.get_target_name()))

		self.m_linktask = linktask

		if self.m_type != 'program' and self.want_libtool:
			latask = self.create_task('fakelibtool', self.env, 200)
			latask.set_inputs(linktask.m_outputs)
			latask.set_outputs(linktask.m_outputs[0].change_ext('.la'))
			self.m_latask = latask

		self.apply_lib_vars()
		self.apply_obj_vars()
		self.apply_objdeps()

	def get_target_name(self, ext=None):
		return self.get_library_name(self.target, self.m_type, ext)

	def get_library_name(self, name, type, ext=None):
		prefix = self.env[type+'_PREFIX']
		suffix = self.env[type+'_SUFFIX']

		if ext: suffix = ext
		if not prefix: prefix=''
		if not suffix: suffix=''
		return ''.join([prefix, name, suffix])

	def apply_incpaths(self):
		if type(self.includes) is types.ListType: inc_lst = self.includes
		else: inc_lst = self.includes.split()
		lst = self._incpaths_lst

		# add the build directory
		self._incpaths_lst.append(Params.g_build.m_bldnode)

		# now process the include paths
		tree = Params.g_build
		for dir in inc_lst:
			node = self.m_current_path.find_node( dir.split(os.sep) )
			if not node:
				debug("node not found in ccroot:apply_incpaths "+str(dir))
				continue
			if not node in lst: lst.append(node)
			Params.g_build.rescan(node)
			self._bld_incpaths_lst.append(node)
		# now the nodes are added to self._incpaths_lst

	def apply_type_vars(self):
		trace('apply_type_vars called')
		for var in self.p_type_vars:
			# each compiler defines variables like 'shlib_CXXFLAGS', 'shlib_LINKFLAGS', etc
			# so when we make a cppobj of the type shlib, CXXFLAGS are modified accordingly
			compvar = '_'.join([self.m_type, var])
			#print compvar
			value = self.env[compvar]
			if value: self.env.appendValue(var, value)

	def apply_obj_vars(self):
		trace('apply_obj_vars called for cppobj')
		cpppath_st       = self.env['CPPPATH_ST']
		lib_st           = self.env['LIB_ST']
		staticlib_st     = self.env['STATICLIB_ST']
		libpath_st       = self.env['LIBPATH_ST']
		staticlibpath_st = self.env['STATICLIBPATH_ST']

		self.addflags('CXXFLAGS', self.cxxflags)
		self.addflags('CPPFLAGS', self.cppflags)

		# local flags come first
		# set the user-defined includes paths
		if not self._incpaths_lst: self.apply_incpaths()
		for i in self._bld_incpaths_lst:
			self.env.appendValue('_CXXINCFLAGS', cpppath_st % i.bldpath(self.env))
			self.env.appendValue('_CXXINCFLAGS', cpppath_st % i.srcpath(self.env))

		# set the library include paths
		for i in self.env['CPPPATH']:
			self.env.appendValue('_CXXINCFLAGS', cpppath_st % i)
			#print self.env['_CXXINCFLAGS']
			#print " appending include ",i
	
		# this is usually a good idea
		self.env.appendValue('_CXXINCFLAGS', cpppath_st % '.')
		self.env.appendValue('_CXXINCFLAGS', cpppath_st % self.env.variant())
		try:
			tmpnode = Params.g_build.m_curdirnode
			#tmpnode_mirror = Params.g_build.m_src_to_bld[tmpnode]
			self.env.appendValue('_CXXINCFLAGS', cpppath_st % tmpnode.bldpath(self.env))
			self.env.appendValue('_CXXINCFLAGS', cpppath_st % tmpnode.srcpath(self.env))
		except:
			pass

		for i in self.env['RPATH']:
			self.env.appendValue('LINKFLAGS', i)

		for i in self.env['LIBPATH']:
			self.env.appendValue('LINKFLAGS', libpath_st % i)

		for i in self.env['LIBPATH']:
			self.env.appendValue('LINKFLAGS', staticlibpath_st % i)

		if self.env['STATICLIB']:
			self.env.appendValue('LINKFLAGS', self.env['STATICLIB_MARKER'])
			for i in self.env['STATICLIB']:
				self.env.appendValue('LINKFLAGS', staticlib_st % i)

		if self.env['LIB']:
			self.env.appendValue('LINKFLAGS', self.env['SHLIB_MARKER'])
			for i in self.env['LIB']:
				self.env.appendValue('LINKFLAGS', lib_st % i)

	def install(self):
		if not (Params.g_commands['install'] or Params.g_commands['uninstall']): return

		dest_var    = ''
		dest_subdir = ''

		if self.install_in:
			dest_var    = self.install_in
			dest_subdir = ''
		else:
			if self.m_type == 'program':
				dest_var    = 'PREFIX'
				dest_subdir = 'bin'
			else:
				dest_var    = 'PREFIX'
				dest_subdir = 'lib'

		if self.m_type == 'program':
			self.install_results(dest_var, dest_subdir, self.m_linktask, chmod=self.chmod)
		elif self.m_type == 'shlib':
			if self.want_libtool: self.install_results(dest_var, dest_subdir, self.m_latask)
			if sys.platform=='win32' or not self.vnum:
				self.install_results(dest_var, dest_subdir, self.m_linktask)
			else:
				libname = self.m_linktask.m_outputs[0].m_name

				nums=self.vnum.split('.')
				name3 = libname+'.'+self.vnum
				name2 = libname+'.'+nums[0]
				name1 = libname

				filename = self.m_linktask.m_outputs[0].relpath_gen(Params.g_build.m_curdirnode)

				Common.install_as(dest_var, dest_subdir+'/'+name3, filename)

				#print 'lib/'+name2, '->', name3
				#print 'lib/'+name1, '->', name2

				Common.symlink_as(dest_var, name3, dest_subdir+'/'+name2)
				Common.symlink_as(dest_var, name2, dest_subdir+'/'+name1)
		elif self.m_type == 'staticlib':
			self.install_results(dest_var, dest_subdir, self.m_linktask, chmod=0644)

	# TODO: broken, update
	def apply_libtool(self):
		self.env['vnum']=self.vnum

		paths=[]
		libs=[]
		libtool_files=[]
		libtool_vars=[]

		for l in self.env['LINKFLAGS']:
			if l[:2]=='-L':
				paths.append(l[2:])
			elif l[:2]=='-l':
				libs.append(l[2:])

		for l in libs:
			for p in paths:
				try:
					dict = read_la_file(p+'/lib'+l+'.la')
					linkflags2 = dict['dependency_libs']
					for v in linkflags2.split():
						if v[len(v)-3:] == '.la':
							libtool_files.append(v)
							libtool_vars.append(v)
							continue
						self.env.appendUnique('LINKFLAGS', v)
					break
				except:
					pass

		self.env['libtoolvars']=libtool_vars

		while libtool_files:
			file = libtool_files.pop()
			dict = read_la_file(file)
			for v in dict['dependency_libs'].split():
				if v[len(v)-3:] == '.la':
					libtool_files.append(v)
					continue
				self.env.appendUnique('LINKFLAGS', v)

	def apply_lib_vars(self):
		trace('apply_lib_vars called')

		# 1. the case of the libs defined in the project
		names = self.uselib_local.split()
		env=self.env
		htbl = Params.g_build.m_depends_on
		for obj in Object.g_allobjs:
			if obj.name in names:
				obj.post()

				if obj.m_type == 'shlib':
					env.appendValue('LIB', obj.target)
				elif obj.m_type == 'staticlib':
					env.appendValue('STATICLIB', obj.target)
				else:
					error('unknown object type %s in apply_lib_vars' % obj.name)

				# add the path too
				tmp_path = obj.m_current_path.bldpath(self.env)
				if not tmp_path in env['LIBPATH']: env.appendValue('LIBPATH', tmp_path)

				# set the dependency over the link task
				self.m_linktask.m_run_after.append(obj.m_linktask)
				
				# make sure to rebuild our link task if obj.m_linktask is re-run
				try:
					lst = htbl[self.m_linktask.m_outputs[0]]
					for a in obj.m_linktask:
						if not a in lst:
							lst.append(a)
				except:
					htbl[self.m_linktask.m_outputs[0]] = obj.m_linktask.m_outputs

		# 2. the case of the libs defined outside
		libs = self.uselib.split()
		for l in libs:
			for v in self.p_flag_vars:
				val=''
				try:    val = self.env[v+'_'+l]
				except: pass
				if val:
					self.env.appendValue(v, val)

	# add the .o files produced by some other object files in the same manner as uselib_local
	def apply_objdeps(self):
		lst = self.add_objects.split()
		for obj in Object.g_allobjs:
			if obj.name in lst:
				obj.post()
				self.m_linktask.m_inputs += obj.out_nodes

	# utility function for cc.py and ccroot.py: add self.cxxflags to CXXFLAGS
	def addflags(self, var, value):
		if type(var) is types.StringType:
			for i in value.split():
				self.env.appendValue(var, i)
		else:
			# TODO: double-check
			self.env[var] += value

