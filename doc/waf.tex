\documentclass[a4,10pt]{article}

\usepackage{vmargin, listings}

\setpapersize{A4}
\setmargnohfrb{25mm}{25mm}{25mm}{45mm}

\def\doctitle{Waf user's guide}
\def\authorName{Carlos Rafael Giani}

\usepackage[
  breaklinks               % Links »überstehen« Zeilenumbruch
  ,backref                 % Backlinks im Literaturverzeichnis
  ,bookmarks               % Erzeugung von Bookmarks für PDF-Viewer
  ,bookmarksnumbered       % Nummerierung der Bookmarks
  ,hyperfootnotes=false    % Keine Links auf Fußnoten
  ,plainpages=false
  ,pdfpagelabels
  ,pdftitle={\doctitle}
  ,pdfauthor={\authorName}
  ,pdfstartview=FitH,      % Dokument wird »Fit Width« geöffnet
  ,pdfpagemode=UseOutlines % Bookmarks im Viewer anzeigen
  ,bookmarksopenlevel=2    % Gliederungstiefe der Bookmarks
  ]
  {hyperref}




\title{\def\doctitle}



\begin{document}
\lstset{basicstyle=\small\ttfamily, numberstyle=\footnotesize, captionpos=b}


\begin{titlepage}
	\vspace*{3cm}
	\begin{center}
		{\Huge\textbf{\doctitle}}\\
		\vspace*{0.5cm}
		\authorName
	\end{center}	

\tableofcontents
\end{titlepage}

\newpage

\pagestyle{plain}
\pagenumbering{arabic}

\section{Getting started}
In order to understand the basics of waf, let's create a simple hello world project. It has only one source file, main.cpp:

\begin{center}
	\begin{lstlisting}[caption=\footnotesize the main.cpp hello world code]
int main()
{
    std::cout << "Hello world";
    return 0;
}
	\end{lstlisting}
\end{center}

To build this, we need a waf build script, called a \emph{wscript}.
Here is the wscript for the hello world program:

\begin{center}
	\begin{lstlisting}[caption=\footnotesize The hello world wscript]
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.check_tool('g++')

def build(bld):
    obj = bld.create_obj('cpp', 'program')
    obj.source = 'main.cpp'
    obj.target = 'hello'
	\end{lstlisting}
\end{center}

Let's go line by line through it:\\
\\
\emph{srcdir}: the root directory for all source files. The project's entire source code is in this directory (or in a subdirectory).\\
\\
\emph{blddir}: where to put the build results. Waf separates build output from source.\\
\\
\emph{configure(conf)}: this function gets invoked when ''waf configure'' is called. It handles the necessary configuration steps, such as autodetection. In this script, configure calls \emph{conf.check\_tool('g++')}, which autodetects the programs \emph{cpp}, \emph{g++}, \emph{ar}, and \emph{ranlib} (some platforms call the C++ compiler cpp, some g++). This step is necessary for waf to be able to build C++ programs. In Windows, the \emph{msvc} tool would accomplish the same, but using Visual C, and not gcc.\\
\\
\emph{build(bld)}: this function is called by waf once the actual building starts.
In build(), \emph{build objects} are created; here, a build object called ''obj'' is created via calling \emph{bld.create\_obj('cpp', 'program')}. create\_obj() takes two arguments: the tool to use for object creation, and a tool-specific type specifier. Tool ''cpp'' creates an object for building C++ projects and knows the types ''shlib'', ''staticlib'', ''program'', and a few others, but usually these three are used. ''shlib'' tells ''cpp'' to build a shared library (.so), ''staticlib'' means a static library (.a), and ''program'' builds an executable.\\
\\
\emph{obj.source = 'main.cpp'}: this line tells the object which source files to use for building. In this case, only main.cpp is used; projects with several files can specify these as one string with the filenames being whitespace-separated.\\
\\
\emph{obj.target = 'hello'}: the name of the target to build. The resulting executable will be called ''hello''.\\\\
\\
This script is now able to autodetect the g++ compiler (and additional programs like ranlib) and build the hello world program. First \emph{waf configure} is called, which causes waf to call the configure() method. Then, by calling \emph{waf build} (or just \emph{waf}) build() is called, and the program is built. For cleaning the build result without deleting the autoconfiguration results, type \emph{waf clean}. This deletes the build results only; the configuration results remain. For fully removing all autogenerated files, \emph{waf distclean} ist used.




\section{The waf building process}

Building with waf always follows these steps:

\begin{enumerate}
\item Init procedures are called
\item Custom command-line options are added
\item Configuration is done (by calling "waf configure")
\item Actual building takes place (command-line call "waf build", or just "waf")
\item Shutdown procedures are called
\end{enumerate}

As mentioned before, waf scripts are called \emph{wscripts}. They are in fact python modules, and treated as such. A wscript variant is \emph{wscript\_build}, which is a wscript with building code only.

\subsection{Initialization}
init() is called every time waf is run, except when running ''waf dist'' or ''waf distclean''. Currently, it has no designated use, but is
available for wscripts. However, usually it is omitted in wscripts.

\subsection{Custom command-line options}
It is possible to add custom command-line options to waf. For example, the hello world wscript with an added option ''--foo-path'' looks like this:

\begin{center}
	\begin{lstlisting}[caption=\footnotesize The hello world wscript with the custom option added]
srcdir = '.'
blddir = 'build'

import Params  # necessary for custom options

def set_options(opt):
	opt.add_option('--foo-path', type='string',
					help='some path', default='', dest='foopath')

def configure(conf):
    conf.check_tool('g++')
	if Params.g_options.foopath:
		print ''Using foo path %s'' % Params.g_options.foopath

def build(bld):
    obj = bld.create_obj('cpp', 'program')
    obj.source = 'main.cpp'
    obj.target = 'hello'
	\end{lstlisting}
\end{center}

This script behaves like the original one, except that the ''waf configure --foo-path=/some/path'' call now causes waf to print ''Using foo path /some/path''.\\
The \emph{Params.g\_options} object is in fact a Python \emph{OptionParser}, which is explained in detail in the Python documentation.

\subsubsection{Tool options}
Some tools add their own commandline options. These tools need to be called in the set\_options() function, via the tool\_options() functions:

\begin{center}
	\begin{lstlisting}[caption=\footnotesize Adding command-line options of the tool 'g++']
	opt.tool_options('g++')
	\end{lstlisting}
\end{center}

\subsubsection{Sub options}
In complex projects, it is common that the source is partitioned in subdirectories. If some of the wscripts in these directories contain set\_options() functions too, then the \emph{opt.sub\_options()} function can be used for recursing into these subdirectories.

\begin{center}
	\begin{lstlisting}[caption=\footnotesize Calling the set\_options() functions of the wscripts in the directories 'main' and 'graphics']
	opt.sub_options('main graphics')
	\end{lstlisting}
\end{center}

\subsection{Configuration}
Waf supplies a ''conf'' object to the configure() function in a wscript, which contains a Python ''env'' dictionary. This dictionary contains all \emph{uselib variables}, among others. Additionally, the conf object has functions for creating  \emph{enumerators} and \emph{configurators}, and the ''check\_tool'' function for detecting and initializing tools.

\subsubsection{Tools}
Waf tools are utility code for common tasks. Often, they handle complex autodetection and/or add tools for building. Internally, they reside in wafadmin/Tools/. Some tools are added via the conf.check\_tool() function, others are for internal use.

Of crucial importance is the check\_tool() function takes two parameters; the first one is the tool name, the second is optional and specifies a path where to look for the tool. At least one tool must be ran in order to be able to build; for example, for being able to build C++ projects using g++, check\_tool('g++') must be called. Same with Visual C (check\_tool('msvc')) and so on.

Without this call, the first parameter of Build.create\_obj() is meaningless (Waf does not know 'cpp', 'cc', etc. unless one C++ tool like 'g++' or 'msvc' is added). To be more specific, g++, gcc, msvc handle the compiler-specific details and add abstract 'cpp' and 'cc' tools to Waf, which are used for building. (This is why internal tools like 'cpp' and 'cc' must not be added manually via check\_tool by the wscript.)

The second parameter is a list of paths where to look for the tools mentioned in the first parameter. This is useful for third-party tools not included in waf itself. Usually, this happens when a Waf tool is modified in any way. For example, if one uses a custom ''Foo.py'' tool, which is located in the same directory as the wscript, use ''check\_tool('Foo', ['.'])''. Omitting the second parameter causes waf to use the internal tools only.

A detailed list of the tools can be found in chapter 3.1.

\subsubsection{Uselib variables}
Configuration works with so-called \emph{uselib variables}. The configure() functions in the wscripts define the variables, the subsequent build step uses them (this will be explained in more detail in the Build chapter). \\
\\
uselib variable names all have the same structure: \emph{vartype}\_\emph{varname}\\
\\
\emph{vartype} is the type of the uselib variable. For example, CPPPATH is the type for C++ include paths.\\
\emph{varname} is an unique name associated with the contents.\\\\
For example, ''CPPPATH\_FT2'' is the uselib variable for the C++ include paths of ''FT2''.\\\\

Here is a list of variable types used in waf, along with a description of their usage and values:\\
\begin{itemize}
	\item \emph{LIB} : a library name. Used both for static and dynamic libraries. If a static and a dynamic library with the same name exist, the dynamic one will be used. For example, env['LIB\_FT2'] = 'ft2' results in the ld linker flag '' -lft2 ''. This type also accepts several library names, which must be specified as a list. Example: [ 'X11' , 'Xxf86vm' ] becomes '' -lX11 -lXxf86vm ''.
	\item \emph{STATICLIB} : unlike LIB, this type works for static libraries only. If only a dynamic library with the specified name exists, it will not be linked.
	\item \emph{LIBPATH} : path to a library. Usually used together with LIB. Can accept multiple paths as a list.
	\item \emph{STATICLIBPATH} : path to a static library. Usually used together with STATICLIB. Can accept multiple paths as a list.
	\item \emph{CPPPATH}: C/C++ include paths (the ''-I'' parameters in gcc). Accepts multiple paths as a list.
	\item \emph{CXXDEFINES}: C/C++ preprocessor defines (the ''-D'' parameter in gcc). Accepts multiple defines as a list. This one should be used with care, since some platforms limit the amount of characters a command-line call can have. It it therefore usually wiser to use a configuration header with the defines in it. (It also cleans up the waf verbose output.)
	\item \emph{CCFLAGS}: C compiler flags. The value is directly passed to the compiler. Note that this is compiler-specific, which can be a problem with multiplatform projects. Example: env['CCFLAGS\_FT2'] = '-Wall -ansi -pedantic'.
	\item \emph{CXXFLAGS}: C++ compiler flags. The value is directly passed to the compiler. Note that this is compiler-specific, which can be a problem with multiplatform projects. Example: env['CXXFLAGS\_FT2'] = '-Wall -ansi -pedantic'.
	\item \emph{LINKFLAGS}: Linker flags. The value is directly passed to the linker. Note that this is linker-specific, which can be a problem with multiplatform projects. Example: env['LINKFLAGS\_FT2'] = '-fPIC'.
\end{itemize}

The configure() function in a wscript is free to define the uselib variable contents in any way. Manual setting is not common, however. Usually, \emph{configurators} and \emph{tools} are used. There are configurators for autodetecting C++ headers, libraries, pkg-config packages, config-tools (like \emph{sdl-config}), and others. Waf tools (not to be confused with the aforementioned config-tools) are general utility packages which can also include autodetection features; in fact, many tools use configurators for internal autodetection.

\subsubsection{Global uselib variables}
These uselib variables are valid everywhere; all build objects include these. They work exactly like normal uselib variables, but lack a name. For example, env['CXXFLAGS'] += ['-Wall'] causes waf to add the '-Wall' C++ compiler flag to \emph{all} build objects. A common use of these special uselib variables is strict compiler behaviour. With gcc, this is achieved by using the flags '-ansi' and '-pedantic'. So, env['CXXFLAGS'] += ['-Wall -ansi -pedantic'] puts gcc in the most strict mode, penalizing almost all violations of the ISO C++ standard.\\

\textbf{\underline{Note:}} As seen above, it is recommended to append (+=) and not assign (=) a new value. waf may have written something in the global uselib variables already, and this would be lost by assigning the new value. Also do not forget to put the string in square brackets.

\subsubsection{Configurators}
As mentioned before, these are used for automating the detection of various components like libraries, C++ headers, programs. They also fill the corresponding uselib variables with the autodetection results. The basic usage is the same with all configurators:

\begin{enumerate}
	\item Create the configurator
	\item Fill in the values necessary for autodetecting
	\item call the configurator's run() function
\end{enumerate}
Afterwards, the env dictionary contains the resulting uselib variables, if the autodetection was successful
(for example, if the desired header was found). A failure can have two results,
depending on the value of the configurator's \emph{mandatory} variable: Print a warning and continue, or stop waf and print an error message.
\begin{center}
	\begin{lstlisting}[caption=\footnotesize Example header configurator usage]
headerconf = conf.create_header_configurator()
headerconf.name = 'GL/gl.h'
headerconf.path = ['/usr/X11R6/include','/usr/local/include']
headerconf.mandatory = 1
headerconf.message = 'This projects requires OpenGL.'
headerconf.run()
	\end{lstlisting}
\end{center}
Configurators have variables, which need to be set with correct values for accomplishing the task.
Some variables are the same for all (or almost all) configurators, some are configurator-specific. The common variables are:

\begin{itemize}
	\item \emph{mandatory} : if this is 1, a failure in autodetection results in waf stopping and printing an error message defined in the
	\emph{message} variable (see below). 0 means that a warning will be emitted, but waf is not stopped. Default is 0. 1 should be used for components absolutely necessary for this project, 0 for optional parts (for example, an audio player with optional support for mp3 decoding).
	\item \emph{message}: the message to be printed if \emph{mandatory} is set to 1 and the autodetection fails. This is useful for
	helping out the user, for example when autodetection of library FT2 fails, the message could contain some suggestions where to download this library and how to install it, or how to install it in popular Unix distributions.
	\item \emph{define}: the define to be added to the configure header once autoconfiguration is completed.
	\item \emph{uselib}: the unique name of the uselib variable to set. Configurator results will be stored in uselib variables with this name.
\end{itemize}

Here is a list of the configurators included in waf:

\begin{itemize}
	\item \emph{Header configurator}\\
	Searches for a particular C++ header in a list of paths, and puts its path in a CPPPATH uselib variable if found.

	This configurator works by test-compiling this code (''someheader.h'' is the wanted header):
	\begin{lstlisting}
// "header_code" contents are inserted here
#include "someheader.h"
int main()
{
  // custom_code contents are inserted here
  return 0;
}
	\end{lstlisting}
	header\_code and custom\_code are explained below.

	Its specific members:
	\begin{itemize}
		\item \emph{name} : the name of the C++ header, including the file extension (''shared\_ptr.hpp'' for example).
		\item \emph{path} : the list of paths where to look for the header. An example would be ['/usr/X11R6/include', '/usr/local/include'].
		\item \emph{nosystem} : if this is set to 1, the standard include paths are not appended, that is the header will not be searched in these standard paths. Default is 0.
		\item \emph{header\_code}: The code specified in this member will be inserted into the testcode \emph{before} the searched header is included (see the code above). This is necessary because some headers expect other headers to be included before, other headers expect some preprocessor defines etc. For example, \emph{jpeglib.h} expects \emph{stdio.h} to be included before. Default value is ' '.
		\item \emph{custom\_code}: Custom code which will be inserted into the testcode's main() function. Default value is ' '.
		\item \emph{libs}: Libraries to be linked to the testprogram. Necessary when testing for \emph{boost.asio} for example; its header(s) require the \emph{pthread} library to be linked, else a linker error occurs. Default value is ' '.
		\item \emph{libpath}: Paths where to find the aforementioned libraries. Default value is ' '.
	\end{itemize}
	Note that this configurator is capable of autodeducing a \emph{uselib} variable name; if \emph{uselib} isn't set, it uses the contents of \emph{name} in uppercase, with the symbols '.', ':', '/' replaced by an underscore '\_'. So, in case of GL/gl.h \emph{uselib} is set to 'GL\_GL\_H'.

	Created by calling \emph{conf.create\_header\_configurator()}.

	\item \emph{Library configurator}\\
	Searches for a library in a list of paths. It looks for both static and shared libraries (DLLs in Windows).
	Its specific members:
	\begin{itemize}
		\item \emph{name} : the name of the library, {\bf not} including the platform-specific pre- and postfix (e.g. 'foo' instead of 'libfoo.so').
		\item \emph{path} : the list of paths where to look for the library. An example would be ['/usr/X11R6/lib', '/usr/local/lib'].
	\end{itemize}

	Created by calling \emph{conf.create\_library\_configurator()}.

	\item \emph{Configure tool configurator}\\
	Uses the values from configure tools (not to be confused with waf tools). Configure tools are package-specific helpers used for determining the flags necessary for using the package. For example, the SDL (http://www.libsdl.org) has ''sdl-config''. Calling ''sdl-config --cflags'' returns the C/C++ compiler flags necessary for using the SDL.
	This configurator can query such a tool and put its results into the uselib variables.
	Its specific members:
	\begin{itemize}
		\item \emph{binary} : the name of the configure tool to use. An example would be ''sdl-config''.
	\end{itemize}
	Unlike other configurators, this one is \emph{not} capable of auto-deducing a uselib variable name, so it must be set explicitely.

	Created by calling \emph{conf.create\_cfgtool\_configurator()}.

	\item \emph{Pkg-config configurator}\\
	This configurator makes use of the pkg-config system. pkg-config is a popular centralized database for querying compiler flags. It works similar to a configure tool; for example, "pkg-config --cflags alsa" prints the cflags necessary for using ALSA. The flags are stored in .pc files, usually located in /usr/lib/pkgconfig/.
	Its specific members:
	\begin{itemize}
		\item \emph{name} Name of the .pc file. In the example above, it would be "alsa" (note that the .pc suffix must not be added).
		\item \emph{version} Minimum version of the package. If the present package is older, the configurator fails. Default value is '''' (= all versions are ok).
		\item \emph{path} Path to the .pc file. Internally, this value is passed to the ''PKG\_CONFIG\_PATH'' environment variable when pkg-config is called. Default value is '''' - in this case PKG\_CONFIG\_PATH is not set.
		\item \emph{binary} Name and path to pkg-config. Default value is '''' (''pkg-config'' is used).
		\item \emph{variables} You could also check for extra values in a pkg-config file. Use this value to define which values should be checked and defined. Several formats for this value are supported:
		\begin{itemize}
			\item{string with spaces to separate a list}
			\item{list of values to check (define name will be upper(uselib''\_''value\_name))}
			\item{a list of [value\_name, override define\_name]}
		\end{itemize}
		Default value is [].
	\end{itemize}

	Created by calling \emph{conf.create\_pkgconfig\_configurator()}.

	\item \emph{Test configurator}\\

	\item \emph{OSX framework configurator}\\
\end{itemize}

\subsubsection{Sub configurations}
Like the sub options, wscripts in subdirectories may contain configure() functions as well. To call these, use \emph{conf.sub\_config()}. It works analogous to \emph{opt.sub\_options()}.

\subsubsection{Configure header}
Waf can autogenerate a C/C++ header file with preprocessor defines in it. This is the aforementioned alternative to the CXXDEFINES uselib variable type.

The \emph{conf.write\_config\_header()} function writes all defines present in the environment (conf.env). New defines can be added by using \emph{conf.add\_define()}. This function expects a name for the define as first and its value as second parameter. If a define with the same name already exists, it is overwritten.

\emph{All} configurators add a define, most can autogenerate a name for one. Its value is 1 if the configurator succeeded or 0 if it failed. These defines' names always start with ''HAVE\_''. So, a library configurator looking for the library ''GL'' would add the define ''HAVE\_GL'', with 1 as a value if the GL library was found.

It is also possible to use a custom define name. The \emph{define} configurator variable provides this. If it is empty, waf autogenerates the define name (if possible), otherwise it uses the one specified in the \emph{define} variable. See chapter 2.3.4 for details.

There are additional functions for handling defines:

\begin{enumerate}
	\item \emph{is\_defined(define)} : This returns nonzero if the specified define exists, zero otherwise.
	\item \emph{get\_define(define)} : Returns the value of the specified define, or zero if this define does not exist.
\end{enumerate}

\begin{center}
	\begin{lstlisting}[caption=\footnotesize Configure header example]
    conf.write_config_header('config.h')
    conf.add_define('DEBUG', 1)
	\end{lstlisting}
\end{center}

The example above adds a define called ''DEBUG'', and sets its value to 1. The resulting header code:

\begin{center}
	\begin{lstlisting}[caption=\footnotesize Configure header example]
/* configuration created by waf */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

#define DEBUG 1

#endif /* _CONFIG_H_WAF */
	\end{lstlisting}
\end{center}

This resulting config.h header would be located in \emph{blddir}/default/config.h (\emph{blddir} is the directory where the build results are put).

\subsection{Building}
Building works by making use of \emph{build objects}. In wscripts, a build() function always gets an object of type \emph{Build} supplied as the function's only parameter (in the example in chapter 1, the object is called ''bld''). This object can create build objects. The wscript has to call the create\_obj function in Build to create the right build objects, and supply them with data. As an example this build() function is used:
\\
\begin{center}
	\begin{lstlisting}[caption=\footnotesize The example build() function]
def build(bld):
    obj = bld.create_obj('cpp', 'program')
    obj.source = 'example.cpp'
    obj.target = 'example'
    obj.uselib = 'ABC FT2'
	\end{lstlisting}
\end{center}

bld is the object of type Build. The first parameter of create\_obj specifies the \emph{tool} to be used for building. Waf has several tools for building various kinds of projects (see chapter 3.1 for a list of all tools).\\
The second parameter is tool-specific. In this case, it defines which type to use. The cpp tool  knows these types: program, staticlib, shlib, bundle, plugin (the last two being OSX specific).\\
After this call, an object is returned. Waf also registers this object in an internal list. When all objects are created and properly set with valid values, waf calls the tools, which create \emph{tasks}. These tasks handle calling the compiler, copying the build results, deleting generated files when calling \emph{./waf (dist)clean} etc.\\
\\
build() functions in subdirectories can be called by using \emph{bld.add\_subdirs()}. This function accepts multiple whitespace-separated directories as one string, like 'src src2'.\\
\\
The following lines set the build object data:
\begin{itemize}

\item \emph{source} contains all source files to be processed. Common are the whitespace-separated and end-of-line separated representations. An example of the former would be 'a.cpp b.cpp', and one of the latter would be
\\
\begin{verbatim}
"""
a.cpp
b.cpp
"""
\end{verbatim}

Often, one does not want to specify all source files, instead simply telling in which dir to look for them is desired. For this, \emph{find\_sources\_in\_dirs()} exist. So, writing \emph{obj.find\_sources\_in\_dirs(".")} instead of \emph{obj.source = 'example.cpp'} above are equivalent. This is especially handy if the project has one directory containing many source files.

\item \emph{target} specifies the target name. The type of the target is directly related to the type of the build. In case of C++, the target is an executable if the type is ''program'', a shared library (DLL in windows) if ''shlib'', a static library if ''staticlib'', an OSX bundle if ''bundle'' and a OSX plugin if ''plugin'' (the latter two equal ''shlib'' in Unix and Windows). Note that the target name should not include platform-specific pre- and suffixes, since Waf attaches them automatically; a shlib target ''foo'' will result in a shared library ''libfoo.so'' in Unix, and ''foo.dll'' in Windows.

\item \emph{uselib} is the key to making use of autoconfiguration. Any uselib variable whose name is in this string will be attached to this build object. Multiple names are whitespace-separated. In the example above, the uselibs ''ABC'' and ''FT2'' are attached to the build object. In case uselibs do not exist, waf ignores this silently.\\
Continuing with the example above, if a ''CPPPATH\_FT2'' uselib variable exists, its contents are attached to the build object's c++ include path list. This is how autoconfiguration works; configure() creates uselib variables, build() adds their contents to the build objects.

\end{itemize}

\vspace{10mm}
The three lines above are not all members available in build objects. Here is the full list:
\begin{itemize}

\item \emph{source, target, uselib}: already explained above.

\item \emph{name}: Build objects can (and should) be named. This is for internal references, and especially handy for the \emph{uselib\_local} variable.

\item \emph{uselib\_local}: Similar to \emph{uselib}, this defines the local dependencies of a build object. If program A depends on static library B, both being created in the same project, and library B is named 'b' (e.g. obj.name = 'b'), then program A should use ''obj.uselib\_local = 'b' ''. This way waf makes sure B is built \emph{before} A, and B gets linked to A.\\
\\
Note: uselib\_local must be in the right order, e.g. if a build object uses the libraries A and B, and lib A uses parts of lib B, uselib\_local must be 'A B'. This is necessary for ensuring proper linking.

\item \emph{includes}: a string of whitespace-separated paths where project specific C/C++ header files are kept. This is C/C++ specific and necessary for tracking header dependencies; if one of the headers stored in one of these paths is modified, waf rebuilds the source files using the modified file(s).

\item \emph{unit\_test}: if this is set to 1, this build object classifies as a unit test. Default value is 0. Only useful if the result of the build object is an executable. See chapter 3.2, \emph{unit tests} for more.

\end{itemize}

\subsection{Shutdown}
shutdown() is called every time waf is run, except when running "waf dist" or "waf distclean". It is useful for performing unit tests and/or copying files. It is optional, and can be omitted.



\section{Additional waf features}

\subsection{Waf tools}
Here is a list of tools included in waf:
\begin{itemize}
	\item \emph{bison}
	\item \emph{cs}
	\item \emph{docbook}
	\item \emph{flex}
	\item \emph{g++}
		Tool for building C++ projects using the GNU C++ compiler. Adds a build tool ''cpp'' capable of building various types of C++ projects. The type is specified in create\_obj after 'cpp'. For example, a C++ project of the ''program'' type will be created like this: obj = bld.create\_obj('cpp', 'program')\\
		The supported types:
		\begin{itemize}
			\item \emph{program} Executables (they get a ''.exe'' suffix in Windows).
			\item \emph{shlib} Shared libraries (called DLLs - dynamic link libraries - in Windows). Pre- and suffix vary between platforms; Unix and Unix derivatives use ''lib'' as pre- and ''.so'' as suffix, Windows uses no pre- and ''.dll'' as suffix.
			\item \emph{staticlib} Static libraries. These have the same naming convention in Unix as shared libraries, in Windows they end with ''.lib'' instead of ''.dll''.
			\item \emph{bundle} OSX-specific (equals shlib on other platforms).
			\item \emph{plugin} OSX-specific (equals shlib on other platforms).
		\end{itemize}
	\item \emph{gcc}
		Tool for building C projects using the GNU C compiler. Adds a build tool 'cc' capable of building the same types g++ supports.
	\item \emph{Gnome}
	\item \emph{java}
	\item \emph{KDE3}
	\item \emph{msvc}
		A C++ building tool, using Microsoft's Visual C compiler. It adds both a ''cc'' and a ''cpp'' build tool, since it is able to build both C and C++ projects. Like g++, it supports various types of C/C++ projects. These types equal those of g++, as does create\_obj() call.\\
\\
		\emph{\textbf{\underline{CAUTION: Do not use msvc and gcc/g++ at the same time.} Doing so results in undefined behaviour, since both msvc and gcc/g++ try to set the cc/cpp build tools. If you want to support multiple compilers, make it possible to select one via a command-line option instead.}}
	\item \emph{osx}
	\item \emph{Ocaml}
	\item \emph{Qt3}
		Qt3 support tool. Needs a C++ tool, so for using the Qt3 tool, 'g++' or 'msvc' need to be initialized via check\_tool() as well.\\
		This tool provides a build tool ''qt3'' for use with bld.create\_obj(). The build types equal the g++/msvc ones. So, for building a Qt3 program, use \emph{bld.create\_obj('qt3', 'program')}.
		\\
		The tool tries to autodetect Qt3. However, some installations cannot be autodetected because of unusual paths and/or different naming. For this, the tool also adds custom command-line options (visible via calling ''waf --help''). Support for automatic moc calling is also included; however, the C++ source files must have this line at the end: \begin{verbatim}#include "headername.moc"\end{verbatim} This is necessary to let waf know when to invoke moc.\
		A class using Qt signals is always defined in a header, and its methods are defined in a source file. For example, a class ''Foo'' is being defined in ''foo.h'' and its methods defined in a file ''foo.cpp''. Foo contains some Qt slots, so moc has to process the header. For this, the line \begin{verbatim}#include "foo.moc"\end{verbatim} needs to be added at the end of foo.cpp. (foo.moc, because the header name is ''foo'', omitting the extension).\
		Note: it is important that waf can actually reach the header, so it has to be ensured that the include paths are correct. \emph{obj.includes} may have to be adjusted for this (see chapter 2.4 for an explanation of \emph{obj.includes}). Also, the Qt3 tool \textbf{must} be called in the \emph{set\_options()} function by calling 'opt.tool\_options('Qt3')' (see chapter 2.2.1 for more about \emph{opt.tool\_options()}.
	\item \emph{Qt4}
		Qt4 support tool, behaves like the Qt3 one. The Qt3 and Qt4 tools can be used in the same wscript (e.g. calling \emph{conf.check\_tool(''g++ Qt3 Qt4'')} is valid). Like the Qt3 tool, it must be called in the \emph{set\_options()} function.
	\item \emph{Tex}
	\item \emph{yacc}
\end{itemize}

Note that these are not all tools present in wafadmin/Tools/; the internal ones have been left out.

\subsection{Unit tests}
Unit testing works in waf by making use of the \emph{unit\_test} variable in build objects (this variable has been explained in chapter 2.4 above).
The unit test is meant to be ran in the shutdown() function. You need to import the ''UnitTest'' module first. Using it is quite straightforward:\\

\begin{enumerate}
	\item First create a unit\_test instance.
	\item Call unit\_test.run(); this calls all projects marked as unit tests (e.g. obj.unit\_test set to 1). Note that run() does not output anything.
	\item Now, either read the test results manually (they are stored in the unit\_test instance), or call unit\_test.printt\_results(), which writes the results to stdout with formatting.
\end{enumerate}

Here is an example:

\begin{center}
	\begin{lstlisting}
def shutdown():
        import UnitTest

        unittest = UnitTest.unit_test()
        unittest.run()
        unittest.print_results()
	\end{lstlisting}
\end{center}

The output from the print\_results() call in this example:

\begin{center}
	\begin{verbatim}
Running unit tests

default/src/testprogram ....... OK

Successful tests:      1 (100.0%)
Failed tests:          0 (0.0%)
Erroneous tests:       0 (0.0%)

Total number of tests: 1

Unit tests finished
	\end{verbatim}
\end{center}

unit\_test has some members, \emph{returncode\_ok} for determining the unit test ''OK'' return code, and the others are filled in with data by the run() method.

\begin{itemize}
	\item \emph{returncode\_ok}: The ''OK'' return code. If a unit test returns this code, it is counted as being successful, else the unit test run will be seen as failed. Default value is 0. Note that if you want to set another code, this has to be done \emph{before} run() is called.
	\item \emph{num\_tests\_ok}: Contains the amount of successful unit test runs.
	\item \emph{num\_tests\_failed}:  Contains the amount of failed unit test runs.
	\item \emph{num\_tests\_err}: Contains the amount of failed erroneous test runs (for example a crashed unit test).
	\item \emph{total\_num\_tests}: The total amount of unit tests. Equals num\_tests\_ok + num\_tests\_failed + num\_tests\_err.
	\item \emph{max\_label\_length}: Labels are names for the unit test; in the example above, ''default/src/testprogram'' is a label. \emph{max\_label\_length} contains the largest label; this is useful for pretty-print output.
\end{itemize}

\end{document}
