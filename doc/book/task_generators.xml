<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="task_gen">
	<title>Task encapsulation using task generators</title>
	<para>
		Although task instances may be created directly, they act like global variables in the scripts, and they may lead to the creation of spaghetti code. The containers named task generators are used for creating the tasks and keeping track of them.
	</para>

	<section>
		<title>Explicit rules for simple transformations (Make-like)</title>
		<para>
			For simple transformations, a make-like scheme enables the creation of tasks by means of task generators. The task is created lazily, for example only if waf is called from a subdirectory of the project containing the declaration.
		</para>

		<sect2>
			<title>Simple rules</title>
		<para>
			The following examples illustrate how to perform simple rule-based transformations, the attribute <emphasis>rule</emphasis> is mandatory, but the input or output files are optional:
		<programlisting language="python">
	bld.new_task_gen( <co id="tg1-co" linkends="tg1"/>
		source='wscript',
		target='test.k1',
		rule='cp ${SRC} ${TGT}'
	)

	bld.new_task_gen( <co id="tg2-co" linkends="tg2"/>
		source='wscript',
		rule='echo ${SRC}'
	)

	bld.new_task_gen( <co id="tg3-co" linkends="tg3"/>
		target='test.k3',
		rule='echo ${PREFIX} > ${TGT}',
	)

	bld.new_task_gen( <co id="tg4-co" linkends="tg4"/>
		rule='echo 1337'
	)
		</programlisting>
			<calloutlist>
				<callout arearefs="tg1-co" id="tg1">
					<para>A basic example with an input and an output. The task is run whenever the input or the rule change</para>
				</callout>
				<callout arearefs="tg2-co" id="tg2">
					<para>The task will run whenever the input or the rule change, but there is no output</para>
				</callout>
				<callout arearefs="tg3-co" id="tg3">
					<para>Creates a task with no input, the output is regenerated whenever the PREFIX variable changes</para>
				</callout>
				<callout arearefs="tg4-co" id="tg4">
					<para>Creates a task without inputs our outputs, it is run whenever the rule text changes</para>
				</callout>
			</calloutlist>
		</para>
		</sect2>

		<sect2>
			<title>Advanced features</title>
		<para>
			The next examples illustrate various attributes which may be used to alter task execution.

		<programlisting language="python">
	bld.new_task_gen( <co id="tg5-co" linkends="tg5"/>
		rule="echo 'task always run'",
		always=True
	)

	bld.new_task_gen( <co id="tg6-co" linkends="tg6"/>
		source='wscript',
		target='test.k',
		rule='./create.py &amp;&amp; mv ${TGT[0].abspath()} ${TGT[0].abspath(env)}',
		cwd=bld.path.abspath(),
		before='test.k1'
	)

	def run(self):
		print 'hi there'

	bld.new_task_gen( <co id="tg7-co" linkends="tg7"/>
		name='hi',
		rule=run
	)

	bld.new_task_gen( <co id="tg8-co" linkends="tg8"/>
		name='svnversion',
		target='ver.h',
		rule='svnversion > ${TGT[0].abspath(env)}',
		cwd=bld.path.abspath(),
		always=True,
		on_results=True
	)

	bld.new_task_gen(
		name='copy_svnversion',
		after='svnversion',
		source='ver.h',
		target='ver2.h',
		rule='cp ${SRC} ${TGT}'
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="tg5-co" id="tg5">
					<para>Make a task which is always run (attribute <emphasis>always</emphasis>)</para>
				</callout>
				<callout arearefs="tg6-co" id="tg6">
					<para>Demonstrates how to add an ordering constraint (attribute <emphasis>before</emphasis>) to execute the rule before the one that produces test.k1. It also demonstrates how to set the directory from which the command is run (attribute <emphasis>cwd</emphasis>)</para>
				</callout>
				<callout arearefs="tg7-co" id="tg7">
					<para>Rules may be given as functions. In this case the task has no input or output files</para>
				</callout>
				<callout arearefs="tg8-co" id="tg8">
					<para>the dependant task copy_svnversion is executed when the actual output of svnversion changes (attribute <emphasis>on_results</emphasis>)</para>
				</callout>
			</calloutlist>
		</para>
		</sect2>
		<para>
			By binding the rule to the actual declaration, <emphasis>this system limits code reuse</emphasis>. For this reason, it is recommended for solving very specific problems in which a library would not make sense. The creation of lots of small rules may also impact performance negatively.
		</para>
	</section>

	<section>
		<title>Implicit processing based on file name or extension</title>
		<para>
			The exclicit rules described in the previous section becomes limited for processing several files of the same kind. Instead of adding loops, we will now describe how to process files using the name or the extension, for files declared in the <emphasis>source</emphasis> attribute. This scheme is the most common technique used in the Waf library.
		</para>
		<sect2>
			<title>Task chain declaration</title>
			<para>
				The following example illustrates how to add a rule for transforming <emphasis>.lua</emphasis> files into <emphasis>.luac</emphasis> files:
				<programlisting language="python">
import TaskGen
TaskGen.declare_chain(
    name = 'luac',
    rule = '${LUAC} -s -o ${TGT} ${SRC}',
    ext_in = '.lua',
    ext_out = '.luac',
    reentrant = 0,
    install = 'LUADIR', # env variable
)

def build(bld):
	bld.new_task_gen(source='main.lua test.lua bar.lua')
				</programlisting>
In practice, the chaining declaration is located in a separate python file which may be re-used for other projects.
			</para>
		</sect2>
		<sect2>
			<title>Using the extension decorator</title>
			<para>
			A special method named <emphasis>apply_core</emphasis> provides file extension processing using the attribute <emphasis>source</emphasis>. On the user side, this takes the following form:
			<programlisting language="python">
def build(bld):
	main = bld.new_task_gen()
	main.features = ['cc', 'program']
	main.source = 'main.c foo.c bar.c'
	main.target = 'my_app'
			</programlisting>
			The method to process <emphasis>.c</emphasis> files (main.c) is called automatically by <emphasis>apply_core</emphasis>, and is declared in the following manner:
			<programlisting language="python">
from TaskGen import extension

@extension('.c')
def c_hook(self, node):
    task = self.create_task('cc')
    try: obj_ext = self.obj_ext
    except AttributeError: obj_ext = '_%d.o' % self.idx

    task.defines  = self.scanner_defines
    task.inputs = [node]
    task.outputs = [node.change_ext(obj_ext)]
    self.compiled_tasks.append(task)
			</programlisting>
		</para>
		<para>
			When the method <emphasis>apply_core</emphasis> is called, the following operations are performed:
			<orderedlist>
				<listitem>If a method is mapped (<emphasis>@extension</emphasis>) to a name listed in sources, it is called with that name as a parameter</listitem>
				<listitem>The names that do not have a mapping are supposed to be files and are transformed into Node instances</listitem>
				<listitem>For each node (temporary variable <emphasis>self.allnodes</emphasis>), a method corresponding to the file extension is applied</listitem>
			</orderedlist>
		</para>
		</sect2>

		<para>
			In this system, the list of sources for an application does not have to exactly represent files. Also, methods may re-inject new nodes to process by extension (in the temporary variable <emphasis>self.allnodes</emphasis>), without keeping an exact reference on the method that will be called.
		</para>

	</section>


	<section>
		<title>Custom processing by task generator methods</title>
		<para>
			In some cases the information to process is very specific and does not really fit in the list of sources. The data may be attached to various attribute of the task generator, and a distinct task generator method may process the attributes dynamically.
		</para>
		<para>
			Let us pretend we want to add a new attribute 'tst' to task generators, and call a method to print the contents of that attribute:
			<programlisting language="python">
def build(bld):
	foo = bld.new_task_gen()
	foo.tst = 'hello, world'
	# equivalent to bld.new_task_gen(tst = 'hello, world')
			</programlisting>
		</para>
		<para>
			To attach a new method to the task_gen class (the type of <emphasis>foo</emphasis>), the decorator <emphasis>@taskgen</emphasis> is used in the following manner:
			<programlisting language="python">
from TaskGen import taskgen
@taskgen
def print_tst(self):
	print 'processing the tst attribute:', self.tst
			</programlisting>
		</para>

		<para>
			At this point, the function print_tst is attached to the class as a new method, but to process the attribute <emphasis>foo.tst</emphasis>, the method has to be called explicitly:
			<programlisting language="python">
def build(bld):
	foo = bld.new_task_gen()
	foo.tst = 'hello, world'
	foo.print_tst()
			</programlisting>
		</para>

		<para>
			To schedule a method for automatic execution, it must be mapped to an alias making a reference to it. The aliases are given in the task generator attribute <emphasis>features</emphasis>:
			<programlisting language="python">
from TaskGen import taskgen, feature
@taskgen
@feature('TEST')
def print_tst(self):
    print 'processing the tst attribute:', self.tst

def build(bld):
    foo = bld.new_task_gen()
    foo.features = ['TEST']
    foo.tst = 'hello, world'
			</programlisting>
		</para>

		<para>
			For mapping the method to all task generators, the wildcard <emphasis>*</emphasis> may be used, a complete example is reproduced below:
			<programlisting language="python">
srcdir='.'
blddir='build'

from TaskGen import taskgen, feature
@taskgen
@feature('*')
def print_tst(self):
    print 'processing the tst attribute:', self.tst

def build(bld):
    foo = bld.new_task_gen()
    foo.tst = 'hello, world'

def configure(conf):
    pass

def set_options(opt):
    pass
			</programlisting>
			Upon execution, this produces the following output:
			<programlisting language="sh">
$ waf
processing the tst attribute: hello, world
			</programlisting>
		</para>
	</section>

	<section>
		<title>Task generator method ordering</title>
		<para>
			In practice, the code for generating tasks has to be shared between different task generators. For example, applications containing different programming languages such as c and c++ at the same time will require a way to create the tasks without duplicating the source code, and by calling the methods in the right order.
			<graphic format="png" fileref="posting.png" align="center"/>
		</para>

		<para>
			Two annotations <emphasis>before</emphasis> and <emphasis>after</emphasis> have been created to enforce an order on the method calls (excerpt from the Waf source code):
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@after('apply_obj_vars_cc')
@after('apply_obj_vars_cxx')
@before('apply_link')
def asm_incflags(self):
	if self.env['ASINCFLAGS']: self.env['_ASINCFLAGS'] = self.env['ASINCFLAGS']
			</programlisting>
		</para>

		<para>
			Methods may be disabled by other methods by modifying the <emphasis>meths</emphasis> attribute. TODO
		</para>
	</section>
		<!--para>
			In the past, Waf used to provide Task generators using a hierarchy of classes. This system was unmaintainable for the following reasons:
			<itemizedlist>
				<listitem>Specialization limits code sharing between instances</listitem>
				<listitem>Each new feature suggests a new class</listitem>
				<listitem>The order of calls in the class hierarchy is complicated</listitem>
			</itemizedlist>
		</para -->
		<!--para>
			In real-world scenarios, the amount of task generator attributes is quite small, but the amount of methods is high. Tracing the execution is a very important usecase to understand the execution, and to extend the system. For this reason, and aspect-oriented system has been adopted since about Waf 1.3: methods and attributes are attached dynamically to a very small set of classes.</para>
		<para>
			We will detail in the following sections how the task generator execution, and the default processing based on file extensions. The details of the execution system will be described in the ultimate section of this chapter.
		</para-->

</chapter>

