<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="task_gen">
	<title>Task encapsulation using task generators</title>
	<para>
		Although task instances may be created directly, they act like global variables in the scripts, and they may lead to the creation of spaghetti code. The containers named task generators are used for creating the tasks and keeping track of them.
	</para>

	<section id="make_like">
		<title>Explicit rules for simple transformations (Make-like)</title>
		<para>
			For simple transformations, a make-like scheme enables the creation of tasks by means of task generators. The task is created lazily, for example only if waf is called from a subdirectory of the project containing the declaration.
		</para>

		<sect2>
			<title>Simple rules</title>
		<para>
			The following examples illustrate how to perform simple rule-based transformations, the attribute <emphasis>rule</emphasis> is mandatory, but the input or output files are optional:
		<programlisting language="python">
	bld.new_task_gen( <co id="tg1-co" linkends="tg1"/>
		source='wscript',
		target='test.k1',
		rule='cp ${SRC} ${TGT}'
	)

	bld.new_task_gen( <co id="tg2-co" linkends="tg2"/>
		source='wscript',
		rule='echo ${SRC}'
	)

	bld.new_task_gen( <co id="tg3-co" linkends="tg3"/>
		target='test.k3',
		rule='echo ${PREFIX} > ${TGT}',
	)

	bld.new_task_gen( <co id="tg4-co" linkends="tg4"/>
		rule='echo 1337'
	)
		</programlisting>
			<calloutlist>
				<callout arearefs="tg1-co" id="tg1">
					<para>A basic example with an input and an output. The task is run whenever the input or the rule change</para>
				</callout>
				<callout arearefs="tg2-co" id="tg2">
					<para>The task will run whenever the input or the rule change, but there is no output</para>
				</callout>
				<callout arearefs="tg3-co" id="tg3">
					<para>Creates a task with no input, the output is regenerated whenever the PREFIX variable changes</para>
				</callout>
				<callout arearefs="tg4-co" id="tg4">
					<para>Creates a task without inputs our outputs, it is run whenever the rule text changes</para>
				</callout>
			</calloutlist>
		</para>
		</sect2>

		<sect2>
			<title>Advanced features</title>
		<para>
			The next examples illustrate various attributes which may be used to alter task execution.

		<programlisting language="python">
	bld.new_task_gen( <co id="tg5-co" linkends="tg5"/>
		rule="echo 'task always run'",
		always=True
	)

	bld.new_task_gen( <co id="tg6-co" linkends="tg6"/>
		source = 'wscript',
		target = 'test.k',
		rule = './create.py &amp;&amp; mv ${TGT[0].abspath()} ${TGT[0].abspath(env)}',
		cwd = bld.path.abspath(),
		before = 'test.k1'
	)

	def run(self):
		print('hi there')

	bld.new_task_gen( <co id="tg7-co" linkends="tg7"/>
		name = 'hi',
		rule = run
	)

	bld.new_task_gen( <co id="tg8-co" linkends="tg8"/>
		name = 'svnversion',
		target = 'ver.h',
		rule = 'svnversion > ${TGT[0].abspath(env)}',
		cwd = bld.path.abspath(),
		always = True,
		on_results = True
	)

	bld.new_task_gen(
		name = 'copy_svnversion',
		after = 'svnversion',
		source = 'ver.h',
		target = 'ver2.h',
		rule = 'cp ${SRC} ${TGT}'
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="tg5-co" id="tg5">
					<para>Make a task which is always run (attribute <emphasis>always</emphasis>)</para>
				</callout>
				<callout arearefs="tg6-co" id="tg6">
					<para>Demonstrates how to add an ordering constraint (attribute <emphasis>before</emphasis>) to execute the rule before the one that produces test.k1. It also demonstrates how to set the directory from which the command is run (attribute <emphasis>cwd</emphasis>)</para>
				</callout>
				<callout arearefs="tg7-co" id="tg7">
					<para>Rules may be given as functions. In this case the task has no input or output files</para>
				</callout>
				<callout arearefs="tg8-co" id="tg8">
					<para>the dependant task copy_svnversion is executed when the actual output of svnversion changes (attribute <emphasis>on_results</emphasis>)</para>
				</callout>
			</calloutlist>
		</para>
		</sect2>
		<para>
			By binding the rule to the actual declaration, <emphasis>this system limits code reuse</emphasis>. For this reason, it is recommended for solving very specific problems in which a library would not make sense. The creation of lots of small rules may also impact performance negatively.
		</para>
	</section>


	<section id="processing_chains">
		<title>Task chaining</title>
			<para>
			The explicit rules described in the previous section become limited for processing several files of the same kind. Instead of adding loops, we will now describe how to process files using the file extensions, for files declared in the <emphasis>source</emphasis> attribute.
			</para>
			<para>
			The following example illustrates how to add a rule for transforming <emphasis>.lua</emphasis> files into <emphasis>.luac</emphasis> files:
			<programlisting language="python">
import TaskGen
TaskGen.declare_chain(
    name    = 'luac',
    rule    = '${LUAC} -s -o ${TGT} ${SRC}',
    ext_in  = '.lua',
    ext_out = '.luac',
	install = '${LUADIR}', # env variable
    reentrant = 0,
)

def build(bld):
	bld.new_task_gen(source='main.lua test.lua bar.lua')
			</programlisting>
The chaining declaration is usually located in a separate python file for re-usability. In practice, chains are useful for simple cases such as processing statistical data and generating simple documents. When more control over the declaration and the output files is needed, it is more convenient to use the techniques described in the next sections.
			</para>
	</section>


	<section id="processing_extensions">
		<title>Name or extension mappings</title>
		<para>
		A special method named <emphasis>apply_core</emphasis> provides file extension processing using the attribute <emphasis>source</emphasis>. On the user side, this takes the following form:
		<programlisting language="python">
def build(bld):
	main = bld.new_task_gen(
		features = 'cc cprogram',
		source = 'main.c foo.c bar.c',
		target = 'my_app')
		</programlisting>
		The method to process <emphasis>.c</emphasis> files (main.c) is declared in the following manner:
		<programlisting language="python">
from TaskGen import extension

@extension('.c')
def c_hook(self, node):
    task         = self.create_task('cc')
    task.inputs  = [node]
    task.outputs = [node.change_ext(obj_ext)]
		</programlisting>
		</para>
		<para>
			When the method <emphasis>apply_core</emphasis> is called, the following operations are performed:
			<orderedlist>
				<listitem>If a method is mapped (<emphasis>@extension</emphasis>) to a name listed in sources, it is called with that name as a parameter</listitem>
				<listitem>The names that do not have a mapping are supposed to be files and are transformed into Node instances</listitem>
				<listitem>For each node (temporary variable <emphasis>self.allnodes</emphasis>), a method corresponding to the file extension is applied</listitem>
			</orderedlist>
		</para>
		<para>
			Now let's illustrate the @extension decorator on idl file processing. Files with .idl extension are processed to produce .c and .h files (foo.idl -> foo.c + foo.h). The .c files must be compiled after being generated.
			<programlisting language="python">
import Task
from TaskGen import extension

Task.simple_task_type('idl', 'omniidl -bcxx ${SRC} -C${TGT}', color='BLUE', ext_out='.cxx')

@extension('.idl')
def process_idl(self, node):
	cc_node = node.change_ext('.cc')
	h_node  = node.change_ext('.h')

	tsk         = self.create_task('idl')
	tsk.inputs  = [node]
	tsk.outputs = [cc_node, h_node]

	# reinject the c++ node to the list of nodes to process
	self.allnodes.append(cc_node)

def build(bld):
	bld.new_task_gen(
		features = 'cxx cprogram',
		source   = 'foo.idl main.cpp',
		target   = 'myapp'
		)
			</programlisting>
		</para>

		<para>
			The @extension decorator also accepts names instead of extensions. An entry in the source list may then be an abstract name. This may be used for tracing or debugging (task creation is not mandatory).
			<programlisting language="python">
@extension('debug')
def debug_allnodes(self, code):
	print (self.allnodes)

def build(bld):
	bld.new_task_gen(
		features = 'cxx cprogram',
		source   = 'debug main.cpp debug',
		target   = 'test'
	)
			</programlisting>
		</para>

		<para>
			The extensions mappings are stored on the class task_gen, which make it possible to modify them globally:
			<programlisting language="python">
import TaskGen
TaskGen.task_gen.mappings['.mm'] = TaskGen.task_gen.mappings['.c']
			</programlisting>
			The may also be set to specific task generator:
			<programlisting language="python">
def build(bld):
	obj = bld.new_task_gen(features='cxx cprogram', source='main.c', target='foo')
	obj.mappings['.c'] = TaskGen.task_gen.mappings['.cxx']
			</programlisting>
		</para>
	</section>


	<section id="task_generator_methods">
		<title>Custom processing by task generator methods</title>
		<para>
			In some cases the information to process is very specific and does not really fit in the list of sources. The data may be attached to various attribute of the task generator, and a distinct task generator method may process the attributes dynamically.
		</para>
		<para>
			In the following example, a new attribute 'tst' is added to task generators instances, and is used to call a method to print the contents of that attribute at the start of the build:
			<programlisting language="python">
def build(bld):
	foo = bld.new_task_gen()
	foo.tst = 'hello, world'
	# alternate syntax: bld.new_task_gen(tst = 'hello, world')
			</programlisting>
		</para>
		<para>
			To attach a new method to the task_gen class (the type of <emphasis>foo</emphasis>), the decorator <emphasis>@taskgen</emphasis> is used in the following manner:
			<programlisting language="python">
from TaskGen import taskgen
@taskgen
def print_tst(self):
	print('processing the tst attribute: %r' % self.tst)
			</programlisting>
		</para>

		<para>
			At this point, the function print_tst is attached to the class as a new method, but to process the attribute <emphasis>foo.tst</emphasis>, the method has to be called explicitly:
			<programlisting language="python">
def build(bld):
	foo = bld.new_task_gen()
	foo.tst = 'hello, world'
	foo.print_tst()
			</programlisting>
		</para>

		<para>
			To schedule that method for automatic execution, it is necessary to bind it somehow. The aliases are given in the task generator attribute <emphasis>features</emphasis>:
			<programlisting language="python">
from TaskGen import taskgen, feature
@taskgen
@feature('TEST')
def print_tst(self):
    print('processing the tst attribute: %r' % self.tst)

def build(bld):
    foo = bld.new_task_gen()
    foo.features = ['TEST']
    foo.tst = 'hello, world'
			</programlisting>
		</para>

		<para>
			For mapping the method to all features, the wildcard <emphasis>*</emphasis> may be used, a complete example is reproduced below:
			<programlisting language="python">
srcdir='.'
blddir='build'

from TaskGen import taskgen, feature
@taskgen
@feature('*')
def print_tst(self):
    print('processing the tst attribute: %r' % self.tst)

def build(bld):
    foo = bld.new_task_gen()
    foo.tst = 'hello, world'

def configure(conf):
    pass
			</programlisting>
			Upon execution, this produces the following output:
			<programlisting language="sh">
$ waf
processing the tst attribute: hello, world
			</programlisting>
		</para>
	</section>

	<section id="task_gen_method_exec">
		<title>Task generator method execution</title>
		<para>
			Methods may be added to task generators, and those methods are bound to features. At the beginning of the build, the task generator instances are executed one by one, and in turn their methods are executed to generate the tasks or to modify additional data. We will now describe what make task generator methods with an example:
			<itemizedlist>
				<listitem>Task generator methods take a single parameter <emphasis>self</emphasis></listitem>
				<listitem>They are bound to particular names representing <emphasis>features</emphasis> (or to '*')</listitem>
				<listitem>They have order restrictions <emphasis>before</emphasis> and <emphasis>after</emphasis></listitem>
			</itemizedlist>
			Here is an example of a task generator method from the Waf source code:
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@after('apply_obj_vars_cc')
@after('apply_obj_vars_cxx')
@before('apply_link')
def asm_incflags(self):
	if self.env.ASINCFLAGS: self.env._ASINCFLAGS = self.env.ASINCFLAGS
			</programlisting>
		</para>

		<para>
			In general, the methods cannot be called several times or in random order. For example, in c++ programming contexts, the compilation tasks must be created before link tasks because link task will reference the compilation tasks. This leads to a particular workflow, reproduced in the following illustration:
			<graphic format="png" fileref="posting.png" align="center"/>
			The list of methods to execute is kept in the attribute <emphasis>meths</emphasis> of the task generator instance. The list of methods to execute may be given directly.
		</para>

		<para>
			It is however more convenient to use the attribute <emphasis>feature</emphasis> to add the methods automatically. For example, for creating a c application, the methods to execute depend on the operating system, so the feature system actually simplifies the code reuse.
		</para>

		<para>
			The order constraints on the methods (after/before), are used to sort the list of methods in the attribute <emphasis>meths</emphasis>. The sorting is performed once, and the list is consumed as methods are executed. Though no new feature may be added once the first method is executed, new methods may be added dynamically in self.meths. Here is how to make an infinite loop:
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@feature('*')
def infinite_loop(self):
	self.meths.append('infinite_loop')
			</programlisting>
		</para>

	</section>
		<!--para>
			In the past, Waf used to provide Task generators using a hierarchy of classes. This system was unmaintainable for the following reasons:
			<itemizedlist>
				<listitem>Specialization limits code sharing between instances</listitem>
				<listitem>Each new feature suggests a new class</listitem>
				<listitem>The order of calls in the class hierarchy is complicated</listitem>
			</itemizedlist>
		</para -->
		<!--para>
			In real-world scenarios, the amount of task generator attributes is quite small, but the amount of methods is high. Tracing the execution is a very important usecase to understand the execution, and to extend the system. For this reason, and aspect-oriented system has been adopted since about Waf 1.3: methods and attributes are attached dynamically to a very small set of classes.</para>
		<para>
			We will detail in the following sections how the task generator execution, and the default processing based on file extensions. The details of the execution system will be described in the ultimate section of this chapter.
		</para-->

</chapter>

