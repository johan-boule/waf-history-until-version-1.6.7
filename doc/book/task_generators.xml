<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="task_gen">
	<title>General purpose task generators</title>

	<section id="task_generator_methods">
		<title>Task generator definition</title>
		<para>
			The chapter on make-like rules illustrated how the attribute <emphasis>rule</emphasis> is processed. Then the chapter on name and extension-based file processing illustrated how the attribute <emphasis>source</emphasis> is processed (in the absence of the rule attribute). To process <emphasis>any attribute</emphasis>, the following properties should hold:
			<itemizedlist>
				<listitem>Attributes should be processed only when the task generator is set to generate the tasks (lazy processing)</listitem>
				<listitem>There is no list of authorized attributes (task generators may be extended by user scripts)</listitem>
				<listitem>Attribute processing should be controlable on a task generator instance basis (special rules for particular task generators)</listitem>
				<listitem>The extensions should be split into independent files (low coupling between the Waf tools)</listitem>
			</itemizedlist>
		</para>

		<para>
			Implementing such a system is a difficult problem which lead to the creation of very different designs:
			<orderedlist>
				<listitem><emphasis>A hierarchy of task generator subclasses</emphasis> It was abandoned due to the high coupling between the Waf tools: the C tools required knowledge from the D tool for building hybrid applications</listitem>
				<listitem><emphasis>Method decoration (creating linked lists of method calls)</emphasis> Replacing or disabling a method safely was no longer possible (addition-only), so this system disappeared quickly</listitem>
				<listitem><emphasis>Flat method and execution constraint declaration</emphasis> The concept is close to aspect-oriented programming and may scare programmers.</listitem>
			</orderedlist>
			So far, the third design proved to be the most flexible and was kept. Here is how to define a task generator method:

			<programlisting language="python">
srcdir = '.'
blddir = 'out'

def configure(conf):
	pass

def build(bld):
	v = bld(myattr='Hello, world!')
	#v.myattr = 'Hello, world!' <co id="feati1-co" linkends="feati1"/>
	v.myMethod() <co id="feati2-co" linkends="feati2"/>

import TaskGen

@TaskGen.taskgen <co id="feati3-co" linkends="feati3"/>
def myMethod(tgen): <co id="feati5-co" linkends="feati5"/>
	print(getattr(self, 'myattr', None)) <co id="feati6-co" linkends="feati6"/>
			</programlisting>

			<calloutlist>
				<callout arearefs="feati1-co" id="feati1">
					<para>Attributes may be set by arguments or by accessing the object (commented here)</para>
				</callout>
				<callout arearefs="feati2-co" id="feati2">
					<para>Call the task generator method explicitely</para>
				</callout>
				<callout arearefs="feati3-co" id="feati3">
					<para>Use a python decorator</para>
				</callout>
				<callout arearefs="feati5-co" id="feati5">
					<para>Task generator methods have a unique argument representing the current instance</para>
				</callout>
				<callout arearefs="feati6-co" id="feati6">
					<para>Process the attribute <emphasis>myattr</emphasis> when present (the case in the example)</para>
				</callout>
			</calloutlist>

			The output from the build will be the following:
			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/simpleproject/out'
hello world
Waf: Leaving directory `/tmp/simpleproject/out'
'build' finished successfully (0.003s)
			</programlisting>
		</para>

		<note>The method could be bound by using <emphasis>setattr</emphasis> directly, like for binding any new method on a python class.</note>

	</section>

	<!-- bind the feature to all, then demonstrate what it to to make one feature, then the order -->


	<section id="task_generator_all">
		<title>Executing the method during the build</title>

		<para>
			So far, the task generator methods defined are only executed through explicit calls. Another decorator is necessary to have a task generator executed during the build phase automatically. Here is the updated example:
				<programlisting language="python">
srcdir = '.'
blddir = 'out'

def configure(conf):
	pass

def build(bld):
	bld(myattr='Hello, world!')

import TaskGen

@TaskGen.taskgen <co id="featj1-co" linkends="featj1"/>
@TaskGen.feature('*') <co id="featj2-co" linkends="featj2"/>
def methodName(self):
	print(getattr(self, 'myattr', None))
				</programlisting>

			<calloutlist>
				<callout arearefs="featj1-co" id="featj1">
					<para>Bind a method to the task generator class (optional when other methods such as <emphasis>TaskGen.feature</emphasis> are used)</para>
				</callout>
				<callout arearefs="featj2-co" id="featj2">
					<para>Bind the method to the symbol <emphasis>myfeature</emphasis></para>
				</callout>
			</calloutlist>

			The execution results will be the following:

			<programlisting language="sh">
$ waf distclean configure build --zones=task_gen <co id="feata1-co" linkends="feata1"/>
'distclean' finished successfully (0.004s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/simpleproject/out'
23:03:44 task_gen posting objects (normal)
23:03:44 task_gen posting &lt;task_gen '' of type task_gen defined in dir:///tmp/simpleproject&gt; 139657958706768 <co id="feata2-co" linkends="feata2"/>
23:03:44 task_gen -> exec_rule (139657958706768) <co id="feata3-co" linkends="feata3"/>
23:03:44 task_gen -> apply_core (139657958706768) <co id="feata4-co" linkends="feata4"/>
23:03:44 task_gen -> methodName (139657958706768) <co id="feata5-co" linkends="feata5"/>
Hello, world!
23:03:44 task_gen posted <co id="feata6-co" linkends="feata6"/>
Waf: Leaving directory `/tmp/simpleproject/out'
23:03:44 task_gen posting objects (normal)
'build' finished successfully (0.004s)
			</programlisting>

			<calloutlist>
				<callout arearefs="feata1-co" id="feata1">
					<para>The debugging zone <emphasis>task_gen</emphasis> is used to display the task generator methods being executed</para>
				</callout>
				<callout arearefs="feata2-co" id="feata2">
					<para>Display which task generator is being executed</para>
				</callout>
				<callout arearefs="feata3-co" id="feata3">
					<para>The method <emphasis>exec_rule</emphasis> is used to process the <emphasis>rule</emphasis>. It is always executed.</para>
				</callout>
				<callout arearefs="feata4-co" id="feata4">
					<para>The method <emphasis>apply_core</emphasis> is used to process the <emphasis>source</emphasis> attribute. It is always executed exept if the method <emphasis>exec_rule</emphasis> processes a <emphasis>rule</emphasis> attribute</para>
				</callout>
				<callout arearefs="feata5-co" id="feata5">
					<para>Our task generator method is executed, and prints <emphasis>Hello, world!</emphasis></para>
				</callout>
				<callout arearefs="feata6-co" id="feata6">
					<para>The task generator methods have been executed, the task generator is marked as done (posted)</para>
				</callout>
			</calloutlist>
		</para>

	</section>


	<section id="task_generator_order">
		<title>Controlling the execution order</title>
		<para>
			To control the execution order, two new decorators need to be added. We will now show a new example with two custom task generator methods <emphasis>method1</emphasis> and <emphasis>method2</emphasis>, executed in that order:
			<programlisting language="python">
srcdir = '.'
blddir = 'out'

def configure(conf):
	pass

def build(bld):
	bld(myattr='Hello, world!')

import TaskGen

@TaskGen.feature('*')
@TaskGen.before('apply_core', 'exec_rule')
def method1(self):
	print('method 1 %r' % getattr(self, 'myattr', None))

@TaskGen.feature('*')
@TaskGen.before('apply_core')
@TaskGen.after('method1')
def method2(self):
	print('method 2 %r' % getattr(self, 'myattr', None))
			</programlisting>

			The execution output will be the following:

			<programlisting language="sh">
 waf distclean configure build --zones=task_gen
'distclean' finished successfully (0.003s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/simpleproject/out'
15:54:02 task_gen posting objects (normal)
15:54:02 task_gen posting &lt;task_gen '' of type task_gen defined in dir:///tmp/simpleproject&gt; 139808568487632
15:54:02 task_gen -> method1 (139808568487632)
method 1 'Hello, world!'
15:54:02 task_gen -> exec_rule (139808568487632)
15:54:02 task_gen -> method2 (139808568487632)
method 2 'Hello, world!'
15:54:02 task_gen -> apply_core (139808568487632)
15:54:02 task_gen posted
Waf: Leaving directory `/tmp/simpleproject/out'
15:54:02 task_gen posting objects (normal)
'build' finished successfully (0.005s)
			</programlisting>

		</para>
	</section>

	<section id="task_generator_meths">
		<title>Adding or removing method for execution</title>

		<para>
			The order constraints on the methods (after/before), are used to sort the list of methods in the attribute <emphasis>meths</emphasis>. The sorting is performed once, and the list is consumed as methods are executed. Though no new feature may be added once the first method is executed, new methods may be added dynamically in self.meths. Here is how to create an infinite loop by adding the same method at the end:
			<programlisting language="python">
from TaskGen import feature

@feature('*')
def infinite_loop(self):
	self.meths.append('infinite_loop')
			</programlisting>
		</para>
		<para>
			The task generator method workflow is represented in the following illustration:
			<graphic format="png" fileref="posting.png" align="center"/>
		</para>

	</section>

	<section id="task_generator_features">
		<title>Task generator features</title>
		<para>
			feature for executing a method in one task generator and not in another one
		</para>
	</section>


		<!-- para>

			A system called <emphasis>features</emphasis> enables new methods on task generators to be loaded conditionally. For example, c programs require typically the processing of lots of attributes such as the application target. The rule-based and source-based processing are bound to all task generators and are the exception.

			TODO explain the separation between task and task generators (concurrency reasons, etc)

		</para -->

	<!--
	<section id="task_gen_method_exec">
		<title>Task generator method execution</title>
		<para>
			Methods may be added to task generators, and those methods are bound to features. At the beginning of the build, the task generator instances are executed one by one, and in turn their methods are executed to generate the tasks or to modify additional data. We will now describe what make task generator methods with an example:
			<itemizedlist>
				<listitem>Task generator methods take a single parameter <emphasis>self</emphasis></listitem>
				<listitem>They are bound to particular names representing <emphasis>features</emphasis> (or to '*')</listitem>
				<listitem>They have order restrictions <emphasis>before</emphasis> and <emphasis>after</emphasis></listitem>
			</itemizedlist>
			Here is an example of a task generator method from the Waf source code:
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@after('apply_obj_vars_cc')
@after('apply_obj_vars_cxx')
@before('apply_link')
def asm_incflags(self):
	if self.env.ASINCFLAGS: self.env._ASINCFLAGS = self.env.ASINCFLAGS
			</programlisting>
		</para>


		<para>
			It is however more convenient to use the attribute <emphasis>feature</emphasis> to add the methods automatically. For example, for creating a c application, the methods to execute depend on the operating system, so the feature system actually simplifies the code reuse.
		</para>

	</section>
	-->
		<!--para>
			In the past, Waf used to provide Task generators using a hierarchy of classes. This system was unmaintainable for the following reasons:
			<itemizedlist>
				<listitem>Specialization limits code sharing between instances</listitem>
				<listitem>Each new feature suggests a new class</listitem>
				<listitem>The order of calls in the class hierarchy is complicated</listitem>
			</itemizedlist>
		</para -->
		<!--para>
			In real-world scenarios, the amount of task generator attributes is quite small, but the amount of methods is high. Tracing the execution is a very important usecase to understand the execution, and to extend the system. For this reason, and aspect-oriented system has been adopted since about Waf 1.3: methods and attributes are attached dynamically to a very small set of classes.</para>
		<para>
			We will detail in the following sections how the task generator execution, and the default processing based on file extensions. The details of the execution system will be described in the ultimate section of this chapter.
		</para-->

	<section id="task_gen_example">
		<title>Putting it altogether</title>
		<para>
			Now let's illustrate the @extension decorator on idl file processing. Files with .idl extension are processed to produce .c and .h files (foo.idl &#8594; foo.c + foo.h). The .c files must be compiled after being generated.
			<programlisting language="python">
import Task
from TaskGen import extension

Task.simple_task_type('idl', 'omniidl -bcxx ${SRC} -C${TGT}', color='BLUE', ext_out='.cxx')

@extension('.idl')
def process_idl(self, node):
	cc_node = node.change_ext('.cc')
	h_node  = node.change_ext('.h')

	self.create_task('idl', node, [cc_node, h_node])

	# reinject the c++ node to the list of nodes to process
	self.allnodes.append(cc_node)

def build(bld):
	bld(
		features = 'cxx cprogram',
		source   = 'foo.idl main.cpp',
		target   = 'myapp'
		)
			</programlisting>
		</para>

	</section>

</chapter>

