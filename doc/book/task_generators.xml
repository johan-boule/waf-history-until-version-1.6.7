<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="task_gen">
	<title>General purpose task generators</title>

	<section id="task_generator_methods">
		<title>Features</title>
		<para>
			The chapter on make-like rules illustrated how the attribute <emphasis>rule</emphasis> is processed. Then the chapter on name and extension-based file processing illustrated how the attribute <emphasis>source</emphasis> is processed (in the absence of the rule attribute). To process <emphasis>any attribute</emphasis>, the following properties should hold:
			<itemizedlist>
				<listitem>Attributes should be processed only when the task generator is set to generate the tasks (lazy processing)</listitem>
				<listitem>There is no list of authorized attributes (task generators may be extended by user scripts)</listitem>
				<listitem>Attribute processing should be controlable on a task generator instance basis (special rules for particular task generators)</listitem>
				<listitem>The extensions should be split into independent files (low coupling between the Waf tools)</listitem>
			</itemizedlist>
		</para>

		<para>
			Implementing such a system is a difficult problem which lead to the creation of very different designs:
			<orderedlist>
				<listitem><emphasis>A hierarchy of task generator subclasses</emphasis> It was abandoned due to the high coupling between the Waf tools: the C tools required knowledge from the D tool for building hybrid applications</listitem>
				<listitem><emphasis>Method decoration (creating linked lists of method calls)</emphasis> Replacing or disabling a method safely was no longer possible (addition-only), so this system disappeared quickly</listitem>
				<listitem><emphasis>Flat method and execution constraint declaration</emphasis> The concept is close to aspect-oriented programming and may scare programmers.</listitem>
			</orderedlist>
			So far, the third design proved to be the most flexible and was kept. We will now provide a generic description of how the task generator methods are declared, by presenting an example that prints <emphasis>Hello world!</emphasis> during the build:

				<programlisting language="python">
srcdir = '.'
blddir = 'out'

def configure(conf):
	pass

def build(bld):
	bld(features='myfeature', myattr='Hello, world!')

import TaskGen

@TaskGen.taskgen <co id="feat1-co" linkends="feat1"/>
@TaskGen.feature('myfeature') <co id="feat2-co" linkends="feat2"/>
@TaskGen.before('someMethod') <co id="feat3-co" linkends="feat3"/>
@TaskGen.after('anotherMethod') <co id="feat4-co" linkends="feat4"/>
def methodName(self): <co id="feat5-co" linkends="feat5"/>
	print(getattr(self, 'myattr', None)) <co id="feat6-co" linkends="feat6"/>
				</programlisting>

			<calloutlist>
				<callout arearefs="feat1-co" id="feat1">
					<para>Bind a method to the task generator class (optional when other methods such as <emphasis>TaskGen.feature</emphasis> are used)</para>
				</callout>
				<callout arearefs="feat2-co" id="feat2">
					<para>Bind the method to the symbol <emphasis>myfeature</emphasis></para>
				</callout>
				<callout arearefs="feat3-co" id="feat3">
					<para>If a task method <emphasis>someMethod</emphasis> exists, this method will be executed in priority</para>
				</callout>
				<callout arearefs="feat4-co" id="feat4">
					<para>Same as above, but the other method will be executed first</para>
				</callout>
				<callout arearefs="feat5-co" id="feat5">
					<para>Task generator methods have a unique argument representing the current instance</para>
				</callout>
				<callout arearefs="feat6-co" id="feat6">
					<para>Process the attribute <emphasis>myattr</emphasis> when present (the case in the example)</para>
				</callout>
			</calloutlist>

			The execution results will be the following:

			<programlisting language="sh">
$ waf distclean configure build --zones=task_gen <co id="feata1-co" linkends="feata1"/>
'distclean' finished successfully (0.004s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/simpleproject/out'
23:03:44 task_gen posting objects (normal)
23:03:44 task_gen posting &lt;task_gen '' of type task_gen defined in dir:///tmp/simpleproject&gt; 139657958706768 <co id="feata2-co" linkends="feata2"/>
23:03:44 task_gen -> exec_rule (139657958706768) <co id="feata3-co" linkends="feata3"/>
23:03:44 task_gen -> apply_core (139657958706768) <co id="feata4-co" linkends="feata4"/>
23:03:44 task_gen -> methodName (139657958706768) <co id="feata5-co" linkends="feata5"/>
Hello, world!
23:03:44 task_gen posted <co id="feata6-co" linkends="feata6"/>
Waf: Leaving directory `/tmp/simpleproject/out'
23:03:44 task_gen posting objects (normal)
'build' finished successfully (0.004s)
			</programlisting>

			<calloutlist>
				<callout arearefs="feata1-co" id="feata1">
					<para>The debugging zone <emphasis>task_gen</emphasis> is used to display the task generator methods being executed</para>
				</callout>
				<callout arearefs="feata2-co" id="feata2">
					<para>Display which task generator is being executed</para>
				</callout>
				<callout arearefs="feata3-co" id="feata3">
					<para>The method <emphasis>exec_rule</emphasis> is used to process the <emphasis>rule</emphasis>.</para>
				</callout>
				<callout arearefs="feata4-co" id="feata4">
					<para>The method <emphasis>apply_core</emphasis> is used to process the <emphasis>source</emphasis> attribute. Its execution is disabled if the method <emphasis>exec_rule</emphasis> processes a <emphasis>rule</emphasis> attribute</para>
				</callout>
				<callout arearefs="feata5-co" id="feata5">
					<para>Our task generator method is executed, and prints <emphasis>Hello, world!</emphasis></para>
				</callout>
				<callout arearefs="feata6-co" id="feata6">
					<para>The task generator methods have been executed, the task generator is marked as done (posted)</para>
				</callout>
			</calloutlist>
		</para>

		<!-- para>

			A system called <emphasis>features</emphasis> enables new methods on task generators to be loaded conditionally. For example, c programs require typically the processing of lots of attributes such as the application target. The rule-based and source-based processing are bound to all task generators and are the exception.

			TODO explain the separation between task and task generators (concurrency reasons, etc)

			TODO present waf  -zones=task_gen

		</para -->

	</section>

	<section id="task_generator_methods">
		<title>Features</title>
		<para>

		</para>
	</section>


	<section id="task_generator_methods">
		<title>Custom processing by task generator methods</title>
		<para>
			In some cases the information to process is very specific and does not really fit in the list of sources. The data may be attached to various attribute of the task generator, and a distinct task generator method may process the attributes dynamically.
		</para>
		<para>
			In the following example, a new attribute 'tst' is added to task generators instances, and is used to call a method to print the contents of that attribute at the start of the build:
			<programlisting language="python">
def build(bld):
	foo = bld()
	foo.tst = 'hello, world'
	# alternate syntax: bld(tst = 'hello, world')
			</programlisting>
		</para>
		<para>
			To attach a new method to the task_gen class (the type of <emphasis>foo</emphasis>), the decorator <emphasis>@taskgen</emphasis> is used in the following manner:
			<programlisting language="python">
from TaskGen import taskgen
@taskgen
def print_tst(self):
	print('processing the tst attribute: %r' % self.tst)
			</programlisting>
		</para>

		<para>
			At this point, the function print_tst is attached to the class as a new method, but to process the attribute <emphasis>foo.tst</emphasis>, the method has to be called explicitly:
			<programlisting language="python">
def build(bld):
	foo = bld()
	foo.tst = 'hello, world'
	foo.print_tst()
			</programlisting>
		</para>

		<para>
			To schedule that method for automatic execution, it is necessary to bind it somehow. The aliases are given in the task generator attribute <emphasis>features</emphasis>:
			<programlisting language="python">
from TaskGen import taskgen, feature
@taskgen
@feature('TEST')
def print_tst(self):
	print('processing the tst attribute: %r' % self.tst)

def build(bld):
	foo = bld()
	foo.features = ['TEST']
	foo.tst = 'hello, world'
			</programlisting>
		</para>

		<para>
			For mapping the method to all features, the wildcard <emphasis>*</emphasis> may be used, a complete example is reproduced below:
			<programlisting language="python">
srcdir='.'
blddir='build'

from TaskGen import taskgen, feature
@taskgen
@feature('*')
def print_tst(self):
	print('processing the tst attribute: %r' % self.tst)

def build(bld):
	foo = bld()
	foo.tst = 'hello, world'

def configure(conf):
	pass
			</programlisting>
			Upon execution, this produces the following output:
			<programlisting language="sh">
$ waf
processing the tst attribute: hello, world
			</programlisting>
		</para>
	</section>

	<section id="task_gen_method_exec">
		<title>Task generator method execution</title>
		<para>
			Methods may be added to task generators, and those methods are bound to features. At the beginning of the build, the task generator instances are executed one by one, and in turn their methods are executed to generate the tasks or to modify additional data. We will now describe what make task generator methods with an example:
			<itemizedlist>
				<listitem>Task generator methods take a single parameter <emphasis>self</emphasis></listitem>
				<listitem>They are bound to particular names representing <emphasis>features</emphasis> (or to '*')</listitem>
				<listitem>They have order restrictions <emphasis>before</emphasis> and <emphasis>after</emphasis></listitem>
			</itemizedlist>
			Here is an example of a task generator method from the Waf source code:
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@after('apply_obj_vars_cc')
@after('apply_obj_vars_cxx')
@before('apply_link')
def asm_incflags(self):
	if self.env.ASINCFLAGS: self.env._ASINCFLAGS = self.env.ASINCFLAGS
			</programlisting>
		</para>

		<para>
			In general, the methods cannot be called several times or in random order. For example, in c++ programming contexts, the compilation tasks must be created before link tasks because link task will reference the compilation tasks. This leads to a particular workflow, reproduced in the following illustration:
			<graphic format="png" fileref="posting.png" align="center"/>
			The list of methods to execute is kept in the attribute <emphasis>meths</emphasis> of the task generator instance. The list of methods to execute may be given directly.
		</para>

		<para>
			It is however more convenient to use the attribute <emphasis>feature</emphasis> to add the methods automatically. For example, for creating a c application, the methods to execute depend on the operating system, so the feature system actually simplifies the code reuse.
		</para>

		<para>
			The order constraints on the methods (after/before), are used to sort the list of methods in the attribute <emphasis>meths</emphasis>. The sorting is performed once, and the list is consumed as methods are executed. Though no new feature may be added once the first method is executed, new methods may be added dynamically in self.meths. Here is how to make an infinite loop:
			<programlisting language="python">
from TaskGen import before, after, taskgen

@taskgen
@feature('*')
def infinite_loop(self):
	self.meths.append('infinite_loop')
			</programlisting>
		</para>

	</section>
		<!--para>
			In the past, Waf used to provide Task generators using a hierarchy of classes. This system was unmaintainable for the following reasons:
			<itemizedlist>
				<listitem>Specialization limits code sharing between instances</listitem>
				<listitem>Each new feature suggests a new class</listitem>
				<listitem>The order of calls in the class hierarchy is complicated</listitem>
			</itemizedlist>
		</para -->
		<!--para>
			In real-world scenarios, the amount of task generator attributes is quite small, but the amount of methods is high. Tracing the execution is a very important usecase to understand the execution, and to extend the system. For this reason, and aspect-oriented system has been adopted since about Waf 1.3: methods and attributes are attached dynamically to a very small set of classes.</para>
		<para>
			We will detail in the following sections how the task generator execution, and the default processing based on file extensions. The details of the execution system will be described in the ultimate section of this chapter.
		</para-->

	<section id="task_gen_example">
		<title>Putting it altogether</title>
		<para>
			Now let's illustrate the @extension decorator on idl file processing. Files with .idl extension are processed to produce .c and .h files (foo.idl &#8594; foo.c + foo.h). The .c files must be compiled after being generated.
			<programlisting language="python">
import Task
from TaskGen import extension

Task.simple_task_type('idl', 'omniidl -bcxx ${SRC} -C${TGT}', color='BLUE', ext_out='.cxx')

@extension('.idl')
def process_idl(self, node):
	cc_node = node.change_ext('.cc')
	h_node  = node.change_ext('.h')

	self.create_task('idl', node, [cc_node, h_node])

	# reinject the c++ node to the list of nodes to process
	self.allnodes.append(cc_node)

def build(bld):
	bld(
		features = 'cxx cprogram',
		source   = 'foo.idl main.cpp',
		target   = 'myapp'
		)
			</programlisting>
		</para>

		<para>
			The extensions mappings are stored on the class task_gen, which make it possible to modify them globally:
			<programlisting language="python">
import TaskGen
TaskGen.task_gen.mappings['.mm'] = TaskGen.task_gen.mappings['.c']
			</programlisting>
			The may also be set to specific task generator:
			<programlisting language="python">
def build(bld):
	obj = bld(features='cxx cprogram', source='main.c', target='foo')
	obj.mappings['.c'] = TaskGen.task_gen.mappings['.cxx']
			</programlisting>
		</para>
	</section>

</chapter>

