== Advanced commands

=== Providing a custom command context

The context for a command is created automatically, and is derived from the class 'Utils.Context'. Custom context instance may be provided in the following manner:

[source,python]
---------------
def foo(ctx):
	pass

import Utils
def foo_context(Utils.Context):
	def __init__(self):
		print("a context for 'foo'")
[source,python]
---------------

Custom contexts may be provided for the functions 'configure' and 'build'.

=== Creating aliases / Injecting new commands

New commands may be injected in the following manner:

[source,python]
---------------
import Scripting
def foo(ctx):
	Scripting.commands += ['build', 'clean']
---------------

Injecting new commands is useful for writing testcases. By executing 'waf test', the following script will configure a project, create source files in the source directory, build a program, modify the sources, and rebuild the program. In this case, the program must be rebuilt because a header (implicit dependency) has changed.

[source,python]
---------------
VERSION = '0.0.1'
APPNAME = 'my_testcase'

srcdir = '.'
blddir = 'build'

import Scripting

def test(ctx):
	Scripting.commands += ['distclean', 'configure', 'setup', 'build', 'modify', 'build']

def configure(conf):
	conf.check_tool('gcc')

def setup(ctx):
	f = open('main.c', 'w')
	f.write('#include "foo.h"\nint main() {return 0;}\n')
	f.close()

	f = open('foo.h', 'w')
	f.write('int k = 32;\n')
	f.close()

def build(bld):
	bld(
		features = 'cc cprogram',
		source = 'main.c',
		target='tprog')

def modify(ctx):
	f = open('foo.h', 'w')
	f.write('int k = 34;\n')
	f.close()
---------------

=== Executing commands as part of another command

In the following scenario, packaging the build files requires an installation into a temporary directory.

Since the contexts parameters passed to the commands usually derive from different classes. For this reason, it is not possible a command may not call another command.

[source,python]
---------------
srcdir = '.'
blddir = 'out'

import Scripting, Options

def configure(conf):
	conf.check_tool('gcc')

def build(bld):
	bld.install_files('/tmp/foo/', 'wscript') <1>
	bld.new_task_gen(features='cc cprogram', target='foo', source='k.c')

back = False
def package(ctx): <2>
	global back
	Scripting.commands.insert(0, 'package') <3>
	Scripting.commands.insert(0, 'install') <4>
	back = Options.options.destdir <5>
	Options.options.destdir = '/tmp/foo'

def create_package(ctx): <6>
	global back
	print("packaging")
	Options.options.destdir = back <7>
---------------

<1> perform the installation
<2> users will call 'waf package' to create the package
<3> postpone the actual package creation
<4> now the next command to execute is the installation, and after the installation, the package creation will be performed
<5> change the value of 'destdir' for installing the files into a temporary directory
<6> command for creating the package
<7> restore the value of 'destdir', in case if more commands are to be executed

