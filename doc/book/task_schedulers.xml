<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="task_schedulers">
	<title>Tasks scheduling</title>
	<section>
		<title>The task execution model</title>
		<para>
			Task dependencies and task ordering specify the exact order in which tasks must be executed. When tasks are executed in parallel, different algorithms may be used to improve the compilation times. For example, tasks that are known to last longer may be launched first. Linking tasks that use a lot of ram (in the context of c++ applications) may be launched alone to avoid disk thrashing by saving RAM.</para>
		<para>
			To make this possible, the task execution is organized in the following manner:
			<graphic format="png" fileref="task_grouping.png" align="center"/>
		</para>
	</section>
	<section>
		<title>Job control</title>
		<para>
			Job control is related to the parallelization algorithms used for launching the tasks. While the aim of parallelization is to maximize the amount of tasks in execution, different algorithms may be used in practice:
			<orderedlist>
				<listitem>Each task holds a list of tasks it must run after, there is only one list of tasks waiting to be executed. This version is better for parallelization, but it consumes more memory and processing, as a result, null builds can be slower by about 20% compared to the next algorithms.</listitem>
				<listitem>Task groups are created in advance, and the topological sort is performed once. The overall performance penalty for real builds is usually minor (a few seconds on builds during minutes).</listitem>
				<listitem>Task groups are created in advance, and a maximum amount of jobs is used when the consumer threads execute the tasks. This is like the second algorithm, but it prevents parallelization of critical tasks (slower builds in theory, but much faster builds in practice)</listitem>
			</orderedlist>
			TODO: provide illustrations of the three algorithms
		</para>
	</section>
	<section>
		<title>Weak ordering constraints</title>
		<para>
			Tasks that are known to take a lot of time may be launched first to improve the build times. The general problem of finding an optimal order for launching tasks in parallel and with constraints is called <emphasis>Job Shop</emphasis>. In practice this problem can often be reduced to a critical path problem (approximation).
		</para>
		<para>
			Waf provides a function for reordering the tasks before they are launched in the module Runner, the default reordering may be changed by dynamic method replacement in Python:
			<programlisting language="python">
import Runner
def get_next(self):
	# reorder the task list by a random function
	self.outstanding.sort()
	# return the next task
	return self.outstanding.pop()
Runner.Prallel.get_next = get_next
			</programlisting>
			If the reordering is not to be performed each time a task is retrieved, the list of task may be reordered when the next group is retrieved:
			<programlisting language="python">
import Runner
old_refill = Runner.Parallel.refill_task_list
def refill_task_list(self):
	old_refill(self)
	self.outstanding.sort()
Runner.Parallel.refill_task_list = refill_task_list
			</programlisting>
			It is possible to measure the task execution times by intercepting the function calls. The task execution times may be re-used for optimizing the schedule for subsequent builds:
			<programlisting language="python">
import time
import Task
old_call_run = Task.TaskBase.call_run
def new_call_run(self):
	t1 = time.time()
	ret = old_call_run(self)
	t2 = time.time()
	if not ret: print "execution time %r" % (t2 - t1)
	return ret
Task.TaskBase.call_run = new_call_run
			</programlisting>
		</para>
	</section>
</chapter>
