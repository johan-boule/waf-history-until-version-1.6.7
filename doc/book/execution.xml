<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="execution">
	<title>Introduction to the Waf scripting system</title>
	<section id="setup">
		<title>Setting up a project</title>
		<para>
		The Waf projects are structured based on the following concepts:
			<itemizedlist>
				<listitem>Source directory: directory containing the source files that will be packaged and redistributed to other developers or to end users</listitem>
				<listitem>Build directory: directory containing the files generated by the project (configuration data, build files, logs, etc)</listitem>
				<listitem>System files: files and folders which do not belong to the project (operating system files, etc)</listitem>
			</itemizedlist>
		</para>

		<para>
		When Waf is launched, it looks for the top-level project file, which are Python scripts. A valid Waf project requires at least a top-level Waf script file (named 'wscript' without any extension) containing the three following elements:
			<itemizedlist>
				<listitem>srcdir: string representing the source directory. In general, srcdir is set to '.', except for some proprietary projects where to wscript cannot be added to the top-level, srcdir may be set to '../..' or even some other folder such as '/checkout/perforce/project'</listitem>
				<listitem>blddir: string representing the build directory. In general, it is set to 'build', except for some proprietary projects where the build directory may be set to an absolute path such as '/tmp/build'. It is important to be able to remove the build directory safely, so it should never be given as '.' or '..'</listitem>
				<listitem>configure: function called for setting up a project (also known as a 'Waf command')</listitem>
			</itemizedlist>
		The Waf script will always look for one valid top-level project file first before considering other project files.
		</para>

		<para>
		Now let us create a new Waf project in the folder <emphasis>/tmp/smallproject</emphasis>. The first step is to write a wscript file in <emphasis>/tmp/smallproject/wscript</emphasis> with the following contents:
			<programlisting language="python">
srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configuring the project')
			</programlisting>
		</para>

		<para>
		To use a Waf project for the first time, it is necessary to initialize it. Waf will then validate the project file, and create the cache files for later use (lock file, build directory, store the project options):
			<programlisting language="sh">
$ cd /tmp/smallproject <co id="init1-co" linkends="initl"/>
$ tree
.
`-- wscript

$ waf configure <co id="init2-co" linkends="init2"/>
-> configuring the project
'configure' finished successfully (0.021s)

$ tree
.
|-- build_directory/ <co id="init3-co" linkends="init3"/>
|   |-- c4che/ <co id="init4-co" linkends="init4"/>
|   |   |-- build.config.py <co id="init5-co" linkends="init5"/>
|   |   `-- default.cache.py <co id="init6-co" linkends="init6"/>
|   |-- config.log <co id="init7-co" linkends="init7"/>
|   `-- default/ <co id="init8-co" linkends="init8"/>
|--.lock-wscript <co id="init9-co" linkends="init9"/>
`-- wscript
			</programlisting>

			<calloutlist>
				<callout arearefs="init1-co" id="init1"><para>To configure the project, go to the folder containing the top-level project file</para></callout>
				<callout arearefs="init2-co" id="init2"><para>The execution is called by calling "waf configure"</para></callout>
				<callout arearefs="init3-co" id="init3"><para>The build directory was created</para></callout>
				<callout arearefs="init4-co" id="init4"><para>The configuration data is stored in the folder c4che/</para></callout>
				<callout arearefs="init5-co" id="init5"><para>The command-line options and environment variables in use are stored in this file</para></callout>
				<callout arearefs="init6-co" id="init6"><para>The user configuration data will be stored to this file</para></callout>
				<callout arearefs="init7-co" id="init7"><para>Configuration log (duplicate of the output generated during the configuration)</para></callout>
				<callout arearefs="init8-co" id="init8"><para>Directory for the generated files (none so far)</para></callout>
				<callout arearefs="init9-co" id="init9"><para>Lock file pointing at the relevant project file and build directory</para></callout>
			</calloutlist>

		</para>
	</section>

	<section id="commands">
		<title>Project commands</title>
		<para>
			In the last section, we have see the use of the command <emphasis>configure</emphasis> to initialize a project. Waf commands are special functions declared in the top-level project file and which may be called explicitely by <emphasis>waf commandname</emphasis>. Let us create two new commands <emphasis>print_ping</emphasis> and <emphasis>print_pong</emphasis> in the project created previously (/tmp/smallproject/)

			<programlisting language="python">
srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configuring the project')

def print_ping(ctx):
	print(' ping!')

def print_pong(ctx):
	print(' pong!')
			</programlisting>

			Waf commands always take a single parameter called the <emphasis>context</emphasis>. To execute the new commands:

			<programlisting language="sh">
$ cd /tmp/smallproject

$ waf configure
-> configuring the project
'configure' finished successfully (0.001s)

$ waf print_ping
 ping!
'print_ping' finished successfully (0.000s)

$ waf print_pong
 pong!
'print_pong' finished successfully (0.000s)
			</programlisting>


			Waf commands may also be executed at once by chaining them:

			<programlisting language="sh">
$ waf print_ping print_pong print_ping
 ping!
'print_ping' finished successfully (0.000s)
 pong!
'print_pong' finished successfully (0.000s)
 ping!
'print_ping' finished successfully (0.000s)
			</programlisting>


			Waf commands may be repeated several times too:

			<programlisting language="sh">
$ waf print_ping print_ping print_ping
 ping!
'print_ping' finished successfully (0.000s)
 pong!
'print_ping' finished successfully (0.000s)
 ping!
'print_ping' finished successfully (0.000s)
			</programlisting>

		</para>
	</section>


	<section id="distclean">
		<title>Cleaning up a project</title>
		<para>
			Waf itself comes with a predefined command called <emphasis>distclean</emphasis> which removes the build directory and the lock file. After calling cleaning a project, it is necessary to configure it once again.

			<programlisting language="sh">
$ waf configure
-> configuring the project
'configure' finished successfully (0.001s)

$ waf print_ping
 ping!
'print_ping' finished successfully (0.000s)

$ waf distclean
'distclean' finished successfully (0.001s)

$ waf print_ping
Project not configured (run 'waf configure' first)
			</programlisting>
		</para>

		<para>
			It is possible to override the behaviour of <emphasis>distclean</emphasis> by redefining it in the wscript file. For example, the following will cause it to avoid removing the build files.
			<programlisting language="python">
srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configuring the project')

def distclean(ctx):
	print(' Not cleaning anything!')
			</programlisting>

			Upon execution:

			<programlisting language="sh">
$ waf distclean
 not cleaning anything!
'distclean' finished successfully (0.000s)
			</programlisting>
		</para>

	</section>

	<section id="dist">
		<title>Packaging a project</title>
		<para>
			The command <emphasis>dist</emphasis> is another predefined utility which is used to create an archive of the project. By using the script presented previously:

			<programlisting language='python'>
srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configuring the project')
			</programlisting>

			Execute the command 'dist' to get:

			<programlisting language="sh">
$ waf configure
-> configuring the project
'configure' finished successfully (0.001s)

$ waf dist
New archive created: noname-1.0.tar.bz2 (sha='c16c97a51b39c7e5bee35bb6d932a12e2952f2f8')
'dist' finished successfully (0.091s)
			</programlisting>
		</para>

		<para>
			By default, the project name and version are set to 'noname' and '1.0'. To change them, it is necessary to provide two additional variables in the top-level project file:

			<programlisting language="python">
APPNAME='webe'
VERSION='2.0'

srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configuring the project')
			</programlisting>

			Because the project was configured once, it is not necessary to configure it once again:

			<programlisting language='sh'>
$ waf dist
New archive created: webe-2.0.tar.bz2 (sha='7ccc338e2ff99b46d97e5301793824e5941dd2be')
'dist' finished successfully (0.006s)
			</programlisting>
		</para>

	</section>

	<section id="recursion">
		<title>Breaking up a project into several files</title>
		<para>
			Although a Waf project must contain a top-level wscript file, the contents may be split into several sub-project files. We will now illustrate this concept on a small project:
			<programlisting language="shell">
.
|-- src
|   `-- wscript
`-- wscript
			</programlisting>

			The commands in the top-level wscript will call the same commands from a subproject wscript file by calling a context method named <emphasis>recurse</emphasis>.

			<programlisting language="python">
srcdir = '.'
blddir = 'build_directory'

def configure(ctx):
    print('-> configure from the top-level')
    ctx.recurse('src')

def print_ping(ctx):
    print('-> ping from the top-level')
    ctx.recurse('src')
			</programlisting>

			Since src/wscript is not to point to a single project, it is not necessary to duplicate the srcdir and blddir variables.

			<programlisting language="python">
def configure(ctx):
    print('-> configure from src')

def print_ping(ctx):
    print('-> ping from src')
			</programlisting>

			Upon execution, the results will be:

			<programlisting language="shell">
$ cd /tmp/smallproject

$ waf configure print_ping
-> configure from the top-level
-> configure from src
'configure' finished successfully (0.080s)
-> ping from the top-level
-> ping from src
'print_ping' finished successfully (0.009s)
			</programlisting>

		</para>
	</section>


	<section id="build function">
		<title>The build function</title>
		<para>
			The function <emphasis>build</emphasis> indicates the start of the actual construction of the software, it is used for two main purposes:
			<itemizedlist>
				<listitem>Declaring the location of scripts that provide other build functions</listitem>
				<listitem>Declaring the actual targets to build</listitem>
			</itemizedlist>
		</para>
		<sect2>
			<title>Subdirectory recursion</title>
			<para>
			The function build may reference build functions in wscript present in sub folders, for example:
			<programlisting language="sh">
.
`-- wscript
|-- src
|   `-- wscript
			</programlisting>
			The top-level wscript may indicate there is a build function to execute in src/wscript using:
			<programlisting language="python">
def build(bld):
	bld.add_subdirs('src')
			</programlisting>

			The wscript files that are not on the top-level often contain a large <emphasis>build</emphasis> function, with no additional configuration or command-line options. In this case the file only contain one method and the indentation is an annoyance. For this reason, the <emphasis>wscript_build</emphasis> files contain the body of a build function defined in a wscript file. A folder may only contain either a wscript or a wscript_build but not both.
			</para>
		</sect2>

		<sect2>
			<title>Pre/post build execution</title>
			<para>
			Additionally, two methods enable the execution after the scripts are read and immediately before the build starts (bld.add_pre_fun) and immediately after the build is completed successfully (bld.add_post_fun). Here is a concrete example for executing a test after the build is finished:
			<programlisting language="python">
def set_options(opt):
	opt.add_option('--exe', action='store_true', default=False,
		help='execute the program after it is built')

def pre(bld):
	print ("before the build is started")

def post(bld):
	import Options, Utils
	if Options.options.exe:
		cmd = "LD_LIBRARY_PATH=build/default/src/:$LD_LIBRARY_PATH build/default/src/testprogram"
		Utils.exec_command(cmd)

def build(bld):
	bld.add_pre_fun(pre)
	bld.add_post_fun(post)
			</programlisting>
			</para>
		</sect2>

		</section>


		<section id="task_intro">
			<title>Introduction to Waf tasks</title>
			<para>
			The process of building a piece of software require the transformation of source code (input) into the result (output). Since the source code is usually split in various files, the construction of the result requires the processing of each of the files. Several new concepts derive from this:
			<itemizedlist>
				<listitem>Intermediate results (object files) may be produced to speed up the build (no need to rebuild everything when small changes occur)</listitem>
				<listitem>Source files may be processed in parallel to speed up the build</listitem>
				<listitem>Source files may be transformed into other source files (sequences of transformations)</listitem>
			</itemizedlist>
			</para>
			<para>
				In a more general scope, the input necessary for a build may come from <emphasis>arbitrary data</emphasis> instead of files (database, commands to execute). The concepts of <emphasis>input, output and transformation</emphasis> and the <emphasis>transformation constraints</emphasis> (in parallel, in sequence) remain identical.
			</para>

			<sect2>
				<title>Simple tasks</title>
			<para>
				In Waf, the operation of transforming data is performed by <emphasis>tasks</emphasis>, which are instances of the class TaskBase (in the Waf library). The tasks in the following example illustrate the declaration of Tasks from the base class. The task instances must be located in a build context (the function build) to be taken into account in the build phase, and to obtain the reference on the source and build folders:
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    pass

import Task
class task_test_a(Task.TaskBase):
	pass
class task_test_b(Task.TaskBase):
	after = 'task_test_a'

def build(bld):
    tb = task_test_b()
    ta = task_test_a()
			</programlisting>
			The execution trace will be the following:
			<programlisting language="sh">
$ waf configure
Configuration finished successfully (00:00:00); project is now ready to build.
$ waf
[0/2] task_test_a
[1/2] task_test_b
Compilation finished successfully (00:00:00)
			</programlisting>
			<warning>By default, command-lines executed by tasks are run from the top of the build directory</warning>
			</para>
		</sect2>

		<sect2>
			<title>Encapsulation by task generators</title>
			<para>
				In practice, when lots of tasks are declared one by one, scripts tend to become complicated, and contain a lot of redundant code. Special objects named <emphasis>task generators</emphasis> are provided to facilitate the creation of several tasks at once. In the following example, a task generator is used to create the compilation and link tasks needed by a c++ project. The syntax <emphasis>bld(...)</emphasis> is a shortcut for calling the method <emphasis>BuildContext.__call__</emphasis> internally and make a new instance of the class <emphasis>task_gen</emphasis>.
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.check_tool('gcc')

def build(bld):
    bld(features='cc cprogram', source='main.c test.c', target='myapp')
			</programlisting>
			This example provides a modified <emphasis>configure</emphasis> function, which is the topic of the next section. The task generator system and the default generators will be reviewed in detail in <xref  linkend="task_gen"/>.
			</para>
		</sect2>
	</section>

	<section id="project_config">
		<title>Configuring a project</title>
		<para>
			The function <emphasis>configure</emphasis> is used for four main purposes:
			<itemizedlist>
				<listitem>Indicating new scripts that provide configuration functions to call</listitem>
				<listitem>Providing configuration contexts to hold persistent data</listitem>
				<listitem>Providing configuration helpers</listitem>
				<listitem>Loading various Waf tools</listitem>
			</itemizedlist>
		</para>
		<sect2>
			<title>Indicating configuration sub folders</title>
			<para>
			The function configure may reference configure functions in wscript present in sub folders, for example:
			<programlisting language="sh">
.
`-- wscript
|-- src
|   `-- wscript
			</programlisting>
			The the directive <emphasis>sub_config</emphasis> wscript indicates another configure function to execute from the script present in another folder:
			<programlisting language="python">
def configure(conf):
	conf.sub_config('src')
			</programlisting>
			The script may be a wscript file containing a function configure, or a file named wscript_configure containing the body of such a function.
			</para>
		</sect2>
		<sect2>
			<title>Storing and loading configuration parameters</title>
			<para>
				<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.env.test = 'hello'
def build(bld):
    print(bld.env.test)
				</programlisting>
			The execution will result in:
				<programlisting language="sh">
$ waf configure
Configuration finished successfully (00:00:00); project is now ready to build.
$ waf
hello
				</programlisting>
			This configuration modifications (on conf.env) are persistent, they are reused during the build (using bld.env). Let us look at the files produced:
				<programlisting language="sh">
.
|-- build
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
`-- wscript
				</programlisting>
			The contents of the file <emphasis>default.cache.py</emphasis> is reproduced here:
				<programlisting language="sh">
$ cat build/c4che/default.cache.py
PREFIX = '/usr/local'
test = 'hello'
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Using configuration helpers</title>
			<para>
				Setting up many parameters manually is a tedious process, and Waf provide configuration helpers to automate the process of finding the settings. For example:
				<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.find_program('tar', var='TAR')
def build(bld):
    print(bld.env.TAR)
				</programlisting>
				Will produce the following results:
				<programlisting language="sh">
$ waf configure
Checking for program tar                 : ok /bin/tar
Configuration finished successfully (00:00:00); project is now ready to build.
$ waf
/bin/tar
Compilation finished successfully (00:00:00)
				</programlisting>
			</para>
		</sect2>

		<sect2>
			<title>Loading Waf tools</title>
			<para>
				The Waf tools are extensions that provide task types (for languages such as c, java, ...), more configuration tests, and command-line options. To make certain that the Waf tools used during the configuration are also available during the build, they are stored during the configuration and loaded automatically afterwards. Here is an example:
				<programlisting language="python">
def configure(conf):
	conf.check_tool('gcc')
				</programlisting>
				By default, tools are loaded from the Waf library, but it is possible to load tools from the source directory using the following:
				<programlisting language="python">
def configure(conf):
	conf.check_tool('my_tool', tooldir='.')
				</programlisting>
			</para>
		</sect2>

	</section>

	<section id="cmdline_options">
		<title>Adding custom command-line options</title>
		<para>
			The function <emphasis>set_options</emphasis> is used for three main purposes:
			<itemizedlist>
				<listitem>Declaring custom command-line options</listitem>
				<listitem>Indicating that scripts provide command-line options</listitem>
				<listitem>Adding command-line options from Waf tools</listitem>
			</itemizedlist>
		</para>
		<sect2>
			<title>Adding options directly</title>
			<para>
			Waf uses the optparse module from Python for adding command-line options, for example:
			<programlisting language="python">
def set_options(opt):
	opt.add_option('--foo', action='store_true', default=False,
		help='Build the program in the folder foo')
def build(bld):
	import Options
	if Options.options.foo:
		bld.add_subdirs('foo')
			</programlisting>
			The command-line options can be displayed afterwards:
			<programlisting language="sh">
$ waf --help
Usage: waf [options] [commands ...]

* Main commands: configure build install clean dist distclean uninstall distcheck
* Example: ./waf build -j4

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -j JOBS, --jobs=JOBS  amount of parallel jobs [Default: 1]
  -f, --force           force file installation
  -k, --keep            keep running happily on independent task groups
  -p, --progress        -p: progress bar; -pp: ide output
  -v, --verbose         verbosity level -v -vv or -vvv [Default: 0]
  --destdir=DESTDIR     installation root [Default: '']
  --nocache             compile everything, even if WAFCACHE is set
  --zones=ZONES         debugging zones (task_gen, deps, tasks, etc)
  --targets=COMPILE_TARGETS
                        compile the targets given only [targets in CSV format, e.g. "target1,target2"]
  --foo                 Build the program in the folder foo
			</programlisting>
			</para>
		</sect2>

		<sect2>
			<title>Adding options from wscript files located in sub folders</title>
			<para>
			The function set_options may reference build functions in wscript present in sub folders, for example:
			<programlisting language="sh">
.
`-- wscript
|-- src
|   `-- wscript
			</programlisting>
			The top-level wscript may indicate there is a build function to execute in src/wscript using:
			<programlisting language="python">
def set_options(opt):
	opt.sub_options('src')
			</programlisting>
			</para>
		</sect2>

		<sect2>
			<title>Adding options from Waf tools</title>
			<para>
			Waf tool options are not added by default because the excess of command-line options is annoying.
			Here is an example for adding the command-line options defined from a Waf tools named compiler_cxx
			<programlisting language="python">
def set_options(opt):
	opt.tool_options('compiler_cxx')
			</programlisting>
			</para>
		</sect2>
	</section>

	<section id="target_install">
		<title>Installing targets</title>
		<para>
			Targets are installed when Waf is run with the following command-line <emphasis>waf install</emphasis>. The actual installation is performed after the current task group has finished, which usually means at the end of the build. We will now describe the three main ways of installing the targets.
		</para>
		<sect2>
			<title>Installing files directly</title>
			<para>
				Source files may be installed directly by using the install methods of the build context.
				<programlisting language="python">
def build(bld):
	bld.install_files('${PREFIX}/include', 'a1.h')
	bld.install_as('${PREFIX}/dir/bar.png', 'foo.png')
	bld.symlink_as('${PREFIX}/lib/libfoo.so.1', 'libfoo.so.1.2.3')
				</programlisting>
			The variables in curly brackets are substituted by values found in <emphasis>bld.env</emphasis>, for example <emphasis>${PREFIX}</emphasis> is substituted by the value of <emphasis>bld.env.PREFIX</emphasis>. An environment parameter may be provided if necessary:
				<programlisting language="python">
def build(bld):
	env2 = bld.env.copy()
	env2['PREFIX'] = '/opt'
	bld.install_files('${PREFIX}/include', 'a1.h', env=env2)
				</programlisting>
			</para>
			<para>
				Though the substitution is only performed on the first parameter, it is possible to re-use the method <emphasis>bld.get_install_path</emphasis> or the function <emphasis>Utils.subst_vars</emphasis>
				<programlisting language="python">
def build(bld):
	print(bld.get_install_path('${PREFIX}/bin'))

	import Utils
	print(Utils.subst_vars('${PREFIX}/${LANG}/po', bld.env))
				</programlisting>
			</para>
			<para>
				To install the contents of a whole directory, iterate on the individual files, for example:
				<programlisting language="python">
def build(bld):
	for x in bld.path.ant_glob('**/*.h'):
		bld.install_files('${PREFIX}/includes', x)
				</programlisting>
				Note that a specialized builder exists to install both python and python compiled files (demos/python).
			</para>

		</sect2>

		<sect2>
			<title>Installing targets (most task generators)</title>
			<para>
				By providing the attribute <emphasis>install_path</emphasis>, tasks generators will install the target (in this example, a program) in the given path.
				<programlisting language="python">
def build(bld):
	bld(
		features = 'cc cprogram',
		source = 'main.c test.c',
		target = 'test_c_program',
		install_path = '${PREFIX}/sbin',
		chmod = 0755)
				</programlisting>

				The variables in curly brackets are substituted as described in the previous paragraph, using <emphasis>main.env</emphasis> instead of bld.env. The <emphasis>chmod</emphasis> attribute is optional, and is used to change the permissions of the installed file (by default it is set to 0644).
			</para>
			<para>
				To prevent the installation of a target (by default, programs and shared libraries are installed), set <emphasis>install_path</emphasis> to <emphasis>None</emphasis>
				<programlisting language="python">
def build(bld):
	bld(
		features = 'cc cprogram',
		source = 'main.c test.c',
		target = 'test_c_program',
		install_path = None)
				</programlisting>
			</para>
		</sect2>

		<sect2>
			<title>Custom tasks</title>
			<para>
				Task installation is disabled by default for most task types. If a method named <emphasis>install</emphasis> is provided, it will be executed immediately after the task is successfully executed. Unlike the compilation, the file installation is not run in parallel (there is little gain in copying files in parallel).
			</para>
		</sect2>
	</section>
</chapter>

