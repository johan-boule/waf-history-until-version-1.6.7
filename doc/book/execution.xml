<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>Introduction to the Waf scripting system</title>
	<section>
		<title>Empty project example</title>
		<para>
		The Waf scripts are based on the following concepts:
			<itemizedlist>
				<listitem>System files: files and folders which do not belong to the project</listitem>
				<listitem>Source directory: directory containing the source files for an application, it is meant to be ultimately packaged, and redistributed to other developers or to end users.</listitem>
				<listitem>Build directory: all files produced by Waf will be output in that folder</listitem>
			</itemizedlist>
		The Waf philosophy is to avoid the pollution of the source directory by letting all files into the build directory. The build directory can be located on the system, out of the source directory (like in /tmp for example).
		</para>

		<para>
		When Waf is launched, it looks for the user-defined Waf scripts which are files written in the Python language. The most important one is the top-level Waf script file in which several functions and attributes must be provided for defining a valid Waf project:
			<itemizedlist>
				<listitem>srcdir: string representing the source directory</listitem>
				<listitem>blddir: string representing the build directory</listitem>
				<listitem>set_options: function used for adding custom command-line options</listitem>
				<listitem>configure: function called for configuring the project</listitem>
				<listitem>build: function used for building the project</listitem>
			</itemizedlist>
		The top-level Waf script file name is &quot;wscript&quot;
		</para>

		<para>
		A simple empty Waf project can be declared using a wscript file containing the following Python code:
		<programlisting language="python">
srcdir = '.'
blddir = 'output'

def set_options(opt):
    print '  setting the options'
def configure(conf):
    print '  executing the configuration'
def build(bld):
    print '  building the project'
		</programlisting>
		</para>

		<para>
		The minimum workflow for any project consists of the following steps:
			<itemizedlist>
				<listitem>Configuring the project: searching for system parameters and compilers</listitem>
				<listitem>Building the project: building the software</listitem>
			</itemizedlist>
		To do this, the following shell commands will be:
		<programlisting>
$ waf configure
  setting the options
  executing the configuration
$ waf build
  setting the options
  building the project
		</programlisting>
		</para>
	</section>

	<section>
		<title>Workflow illustration on a more complicated example</title>
		<para>
			Additional functions are usually provided in the top-level wscript file:
			<itemizedlist>
				<listitem>APPNAME: project name</listitem>
				<listitem>VERSION: project version</listitem>
				<listitem>init: function called before anything is executed</listitem>
				<listitem>shutdown: function called after a successful configuration or build</listitem>
				<listitem>dist: function called for packaging the application</listitem>
			</itemizedlist>
			We will now provide a more complicated wscript file, execute the typical commands, and look at the output:
			<programlisting language="python">
VERSION='0.0.1'
APPNAME='test'
srcdir = '.'
blddir = 'build'

def init():
    print "  init called"
def set_options(opt):
    print "  set_options"
def configure(conf):
    print "  calling the configuration"
def build(bld):
    print "  building"
def shutdown():
    print "  shutdown called"
			</programlisting>
The output will be:
			<programlisting>
$ waf
Project not configured (run 'waf configure' first)
$ waf configure
  set_options
  init called
  calling the configuration
Configuration finished successfully (00:00:00); project is now ready to build.
$ waf
  set_options
  init called
  building
Compilation finished successfully (00:00:00)
  shutdown called
$ waf dist
  set_options
  init called
Your archive is ready -> test-0.0.1.tar.bz2
			</programlisting>
		</para>
		<para>
			A few files will be produced by Waf, let us look at them now:
			<programlisting language="sh">
.
|-- build
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|-- test-0.0.1.tar.bz2
`-- wscript
			</programlisting>
			A build directory was created with the name given in the wscript file. It contains a configuration log, and various cache files. The last command produced a tarball of the project (an archive) containing the source files. For now it only contains the wscript file.
		</para>
	</section>
	<section>
		<title>Building a project</title>
		<para>
			The function <emphasis>build</emphasis> is used for two purposes:
			<itemizedlist>
				<listitem>Indicate new scripts that provide build functions to call</listitem>
				<listitem>Declare the targets to build</listitem>
			</itemizedlist>
		</para>
		<sect2>
			<title>Providing wscript files in subfolders</title>
			<para>
			The function build may reference build functions in wscript present in subfolders, for example:
			<programlisting language="sh">
.
`-- wscript
|-- src
|   `-- wscript
			</programlisting>
			The top-level wscript may indicate there is a build function to execute in src/wscript using:
			<programlisting language="python">
def build(bld):
	bld.add_subdirs('src')
			</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Declaring Waf tasks</title>
			<para>
			We will now introduce the concept of task. In Waf, tasks represent individual units of change. By change, we mean the production of one or several files, by which the process cannot be split in sub-tasks (atomicity). Waf uses objects of the class TaskBase (in the Waf library) to represent the tasks:
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def set_options(opt):
    pass
def configure(conf):
    pass

import Task
class task_test_a(Task.TaskBase):
	pass
class task_test_b(Task.TaskBase):
	after = 'task_test_a'

def build(bld):
    tb = task_test_b()
    ta = task_test_a()
			</programlisting>
			The execution trace will be the following:
			<programlisting language="sh">
$ waf configure
Configuration finished successfully (00:00:00); project is now ready to build.
$ waf
[0/2] task_test_a
[1/2] task_test_b
Compilation finished successfully (00:00:00)
			</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>The task generators</title>
			<para>
			The tasks provided in the previous example do not do anything useful, and in practice it is desirable to automate their production. For example, if a lot of c files are provided and are to be processed into an application, a task generator will take all the source files and produce the tasks with the appropriate dependencies (compile and then assemble the object files at the end). Waf provides various task generator by default.
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.check_tool('gcc')

def build(bld):
    main = bld.new_task_gen('cc', 'program')
    main.source = 'main.c test.c'
    main.target = 'test_c_program'
			</programlisting>
			This example provides a modified <emphasis>configure</emphasis> function, which is the topic of the next section. The various task generators will be reviewed in another chapter.
			</para>
		</sect2>
	</section>

</chapter>

