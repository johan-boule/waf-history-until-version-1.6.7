<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>Using the development version</title>
	<section>
		<title>Tracing the execution</title>
		<para>
			The generic flags to add more information to the stack traces or to the messages is <emphasis>-v</emphasis>, it is used to display the command-lines executed during a build:
			<programlisting language="shell">
$ waf -v
			</programlisting>
			To display all the traces, use the following flag:
			<programlisting language="shell">
$ waf -vvv
			</programlisting>
			Most of the time, only specific areas are useful, for this use the flag <emphasis>zones</emphasis>.
			<programlisting language="shell">
$ waf --zones=action
			</programlisting>
			Tracing zones must be comma-separated, for example:
			<programlisting language="shell">
$ waf --zones=action,envhash,task_gen
			</programlisting>
		</para>
		<para>
			The Waf module <emphasis>Logs</emphasis> replaces the Python module logging. In the source code, traces are provided by using the <emphasis>debug</emphasis> function, they must obey the format "zone: message" like in the following:
			<programlisting language="python">
Logs.debug("task: task %r must run as it was never run before or the task code changed" % self)
			</programlisting>
			The following zones are used in Waf:
<table>
<title>Debugging zones</title>

<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colname='c1'/>
<colspec colname='c2'/>

<thead>
<row>
  <entry>Zone</entry>
  <entry>Meaning</entry>
</row>
</thead>

<tbody>

<row>
  <entry>runner</entry>
  <entry>command-lines executed (enabled when -v is provided without debugging zones)</entry>
</row>

<row>
  <entry>task_gen</entry>
  <entry>task creation (from task generators)</entry>
</row>

<row>
  <entry>action</entry>
  <entry>functions to execute for building the targets</entry>
</row>

<row>
  <entry>env</entry>
  <entry>environment contents</entry>
</row>

<row>
  <entry>envhash</entry>
  <entry>hashes of the environment objects - helps seeing what changes</entry>
</row>

<row>
  <entry>build</entry>
  <entry>build context operations such as filesystem access</entry>
</row>

<row>
  <entry>deps</entry>
  <entry>implicit dependencies found (task scanners)</entry>
</row>

</tbody>
</tgroup>
</table>

		</para>
	</section>

	<section>
		<title>Benchmarking</title>
		<para>
			The script <filename>utils/genbench.py</filename> generates a simple benchmark for Waf. The habitual use is the following:
			<programlisting language="shell">
utils/genbench.py /tmp/build 50 100 15 5
cd /tmp/build
waf configure
waf -p -j2
			</programlisting>
			The project created contains 50 libraries with 100 classes for each, each source file having 15 include headers pointing to the same library and 5 headers pointing to the headers of other libraries in the project.
		</para>

		<para>
			The time taken to create the tasks and to resolve the dependencies can be obtained by injecting code to disable the actual compilation, for example:
			<programlisting language="python">
def build(bld):
	import Task
	def touch_func(task):
		for x in task.outputs:
			open(x.abspath(task.env), 'w').close()
	for x in Task.TaskBase.classes.keys():
		cls = Task.TaskBase.classes[x]
		cls.func = touch_func
		cls.color = 'CYAN'
			</programlisting>
		</para>
	</section>

	<section>
		<title>Profiling</title>
		<para>
			Profiling information is obtained by calling the module cProfile and by injecting specific code, for example:
			<programlisting language="python">
import Build
def ncomp(self):
	import cProfile, pstats
	cProfile.run('import Build; Build.bld.rep_compile()', 'profi.txt')
	p = pstats.Stats('profi.txt')
	p.sort_stats('time').print_stats(150)

Build.bld.rep_compile = Build.bld.compile
Build.bld.compile = ncomp
			</programlisting>
			Here is an example of the output obtained on a benchmark build created as explained in the previous section:
			<programlisting language="shell">
Sat Oct 18 12:20:28 2008    profi.txt

         889841 function calls (847991 primitive calls) in 2.882 CPU seconds

   Ordered by: internal time
   List reduced from 166 to 5 due to restriction 5

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.390    0.390    0.390    0.390 {cPickle.dump}
     5000    0.206    0.000    0.291    0.000 /compilation/waf/wafadmin/Task.py:770(compute_sig_implicit_deps)
73950/42150    0.205    0.000    0.254    0.000 /compilation/waf/wafadmin/Environment.py:66(__getitem__)
     5050    0.162    0.000    0.511    0.000 /compilation/waf/wafadmin/Task.py:706(sig_vars)
   179434    0.138    0.000    0.138    0.000 {method 'update' of 'fnv' objects}
			</programlisting>

			The two most interesting methods to profile are <emphasis>flush</emphasis> and <emphasis>compile</emphasis>. The most important number from the profiling information is the amount of function calls, and reducing it results in noticeable speedups. Though the obvious bottlenecks are are the persistency layer (cPickle), and the signature computation (compute_sig_implicit_deps), they are not significant enough to justify code changes in practice. Also, profiling must be carried out on builds which last at least several seconds.
		</para>
	</section>

	<section>
		<title>Obtaining the latest source code</title>
		<para>Waf is hosted on <ulink url="http://code.google.com/p/waf/source">Google code</ulink>, and uses Subversion for source control. To obtain the development copy, use:
		<programlisting language="sh">
svn checkout http://waf.googlecode.com/svn/trunk/ waf-read-only
cd waf-read-only
./waf-light --make-waf
		</programlisting>
		</para>
		<para>
		To avoid regenerating Waf each time, the environment variable WAFDIR can be used to point to the directory containing wafadmin:
		<programlisting language="sh">
export WAFDIR=/path/to/wafadmin
		</programlisting>
		</para>
		<para>
			Although the Waf binary depends on Python 2.3, the Waf source code depends on Python 2.4. When generating Waf, a parser modifies the source code and performs the following operations:
			<itemizedlist>
				<listitem>Move the decorators into simple function calls</listitem>
				<listitem>Add the imports for the module sets</listitem>
				<listitem>Eliminate redundant spaces</listitem>
				<listitem>Strip comments to reduce the size</listitem>
			</itemizedlist>
		</para>
	</section>

	<section>
		<title>Development standards</title>
		<para>
			Though Waf is written in Python, additional restrictions apply to the source code:
			<itemizedlist>
				<listitem>Identation is tab-only, and the maximum line length should be about 200 characters</listitem>
				<listitem>The development code is kept compatible with Python 2.3, to the exception of decorators in the Tools directory. In particular, the Waf binary can be generated using Python 2.3</listitem>
				<listitem>The <filename>wafadmin</filename> modules must be insulated from the <filename>Tools</filename> modules to keep the Waf core small and language independent</listitem>
				<listitem>Api compatibility is maintained in the cycle of a minor version (from 1.5.0 to 1.5.9)</listitem>
			</itemizedlist>
		</para>

		<para>
			More code always means more bugs. Whenever possible, unnecessary code must be removed, and the existing code base should be simplified.
		</para>
	</section>


</chapter>

