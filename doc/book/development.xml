<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>Using the development version</title>
	<section>
		<title>Obtaining the latest source code</title>
		<para>Waf is hosted on <ulink url="http://code.google.com/p/waf/source">Google code</ulink>, and uses Subversion for source control. To obtain the development copy, use:
		<programlisting language="sh">
svn checkout http://waf.googlecode.com/svn/trunk/ waf-read-only
cd waf-read-only
./waf-light --make-waf
		</programlisting>
		</para>
		<para>
		To avoid regenerating Waf each time, the environment variable WAFDIR can be used to point to the directory containing wafadmin:
		<programlisting language="sh">
export WAFDIR=/path/to/wafadmin
		</programlisting>
		</para>
		<para>
			Although the Waf binary depends on Python 2.3, the Waf source code depends on Python 2.4. When generating Waf, a parser modifies the source code and performs the following operations:
			<itemizedlist>
				<listitem>Move the decorators into simple function calls</listitem>
				<listitem>Add the imports for the module sets</listitem>
				<listitem>Eliminate redundant spaces</listitem>
				<listitem>Strip comments to reduce the size</listitem>
			</itemizedlist>
		</para>
	</section>

	<section>
		<title>Development standards</title>
		<para>
			Though Waf is written in Python, additional restrictions apply to the source code:
			<itemizedlist>
				<listitem>Identation is tab-only, and the maximum line length should be about 200 characters</listitem>
				<listitem>The development code is kept compatible with Python 2.3, to the exception of decorators in the Tools directory. In particular, the Waf binary can be generated using Python 2.3</listitem>
				<listitem>The <filename>wafadmin</filename> modules must be insulated from the <filename>Tools</filename> modules to keep the Waf core small and language independent</listitem>
				<listitem>Api compatibility is maintained in the cycle of a minor version (from 1.5.0 to 1.5.9)</listitem>
			</itemizedlist>
		</para>

		<para>
			More code always means more bugs. Whenever possible, unnecessary code must be removed, and the existing code base should be simplified.
		</para>
	</section>

	<section>
		<title>Debugging</title>
		<para>
			TODO
		</para>
	</section>

	<section>
		<title>Benchmarking</title>
		<para>
			The script <filename>utils/genbench.py</filename> generates a simple benchmark for Waf. The habitual use is the following:
			<programlisting language="shell">
utils/genbench.py /tmp/build 50 100 15 5
cd /tmp/build
waf configure
waf -p -j2
			</programlisting>
		</para>

		<para>
			The time taken to create the tasks and to resolve the dependencies can be obtained by disabling the actual compilation, for example:
			<programlisting language="python">
def build(bld):
	import Task
	def touch_func(task):
		for x in task.outputs:
			open(x.abspath(task.env), 'w').close()
	for x in Task.TaskBase.classes.keys():
		cls = Task.TaskBase.classes[x]
		cls.func = touch_func
		cls.color = 'CYAN'
			</programlisting>
		</para>
	</section>

	<section>
		<title>Profiling</title>
		<para>
			Profiling information is obtained by calling the module cProfile. Here is one example:
			<programlisting language="python">
import cProfile, pstats
cProfile.run('import Build; Build.bld.compile()', 'profi.txt')
p = pstats.Stats('profi.txt')
p.sort_stats('time').print_stats(150)
			</programlisting>
		</para>
	</section>

</chapter>

