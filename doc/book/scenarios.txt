== Advanced scenarios

This chapter provides examples for advanced scenarios to demonstrate the practical use of the Waf library.

=== Simple file transformations

The Waf tool 'misc' contains various routines to ease file manipulations such as substituting parameters or executing custom compilers. The objective of this section is to illustrate the principles of the current apis.

The following example illustrates how to produce a pkg-config file from a template:

[source,python]
---------------
def configure(conf):
	conf.check_tool('misc')

def build(bld):
	obj = bld('subst')
	obj.source = 'test.pc.in'
	obj.target = 'test.pc'
	obj.dict   = {'LIBS': '-lm', 'CFLAGS': '-Wall', 'VERSION': '1.0'}

	# any kind of map will work, for example
	# obj.dict = obj.env.get_merged_dict()
---------------

The variables must be declared in the template file by enclosing the names between '@ characters' (m4 syntax).

---------------
Name: test
Description: @CFLAGS@
Version: @VERSION@
Libs: -L${libdir} @LIBS@
Cflags: -I${includedir} @CFLAGS@
---------------

The default substitution function may be replaced by changing the attribute 'func' of the task generator.

=== Building the compiler first

The example below demonstrates how to build a compiler which is used for building the remaining targets. The requirements are the following:

. Compile the compiler with all its intermediate tasks
. Re-use the compiler in a second build step

This scenario demonstrates the 'bld.add_group' to segment the build into strictly sequential parts:

[source,python]
---------------
def build(bld):
	env = bld.env_of_name('default')

	import Task, ocaml
	ocaml.open_re = re.compile('open ([a-zA-Z]+)', re.M)

	Task.simple_task_type('ts2qm', '${QT_LRELEASE} ${SRC} -qm ${TGT} 2> /dev/null', color='RED')
	Task.task_type_from_func('py2rcc', vars=[], func=compile_py, color='BLUE')

	bld(
		features='ocaml native', <1>
		include = 'util',
		source = bld.path.ant_glob('util/*.ml'),
		target = 'util/ocaml+twt',
		are_deps_set = True,
		uselib='PP')

	bld.add_group() <2>

	bld(
		features = 'ocaml c_object', <3>
		source = 'src/armtlkto.c ' + bld.path.ant_glob('src/*.ml'),
		includes = '. src',
		target = 'camlprog',
		are_deps_set = True,
		uselib = 'TWT',
		add_objects = [])
---------------

<1> Create the compiler.
<2> Create a new group
<3> The rest of the build follows

=== Writing the output of a program into a header

The example below demonstrates how to write the output of svnversion into a header without using a make-like rule. The command is always run, and the c/c++ compilation will be executed if the header changes (implicit dependencies obtained by the Waf preprocessor):

[source,python]
---------------
def build(bld):
	# 1. A simple program
	main = bld(
		features = 'cc cprogram',
		source = 'main.c',
		target = 'test_c_program',
		uselib_local = 'teststaticlib',
		svn_header = 'ver.h' <1>
	)
	# 2. A simple static lib
	staticlib = bld(
		features = 'cc cstaticlib',
		source = 'test_staticlib.c',
		target = 'teststaticlib'
	)

import subprocess
from Constants import RUN_ME
from TaskGen import feature, after
import Task, Utils

@feature('cc')
@after('apply_core')
def process_svn(self): <2>
	if getattr(self, 'svn_header', None):
		tsk = self.create_task('svn_ver')
		tsk.set_outputs(self.path.find_or_declare(self.svn_header))

def get_svn_rev(): <3>
	try:
		p = subprocess.Popen(['svn', 'info', '--non-interactive'], stdout=subprocess.PIPE, \
			stderr=subprocess.STDOUT, close_fds=False, env={'LANG' : 'C'})
		stdout = p.communicate()[0]

		if p.returncode == 0:
			lines = stdout.splitlines(True)
			for line in lines:
				if line.startswith('Last Changed Rev'):
					key, value = line.split(': ', 1)
					return value.strip()
		return '-1'
	except:
		return '-1'

def svnvars(self): <4>
	self.ver = get_svn_rev()
	fi = open(self.outputs[0].abspath(self.env), 'w')
	fi.write('#define  VER "%d"\n' % self.ver)
	fi.close()

cls = Task.task_type_from_func('svn_ver', vars=[], func=svnvars, color='BLUE', before='cc') <5>

def always(self): <6>
	return RUN_ME
cls.runnable_status = always

def post_run(self): <7>
	sg = Utils.h_list(self.ver)
	node = self.outputs[0]
	variant = node.variant(self.env)
	self.generator.bld.node_sigs[variant][node.id] = sg
cls.post_run = post_run
---------------

<1> Example in a user script, the attribute 'svn_header' is used to indicate a header to create as a build file
<2> Process the attribute svn_header when present, create a task instance
<3> A function for obtaining the svn version of the project
<4> Obtain the svn version and write it to the header
<5> Declaration of the task which will execute the svn processing
<6> The task must be run each time - there is no signature involved
<7> Mark the outputs as changed if necessary by changing the signature

Task creation is performed through a new task generator method (process_svn) which is executed only when the task generator creates all its tasks. This organization makes it possible to compile only the code necessary for a specific target (tasks are created lazily, and are grouped by task generators). To address the scenario described, a new task type is created, and methods are replaced dynamically: runnable_status (execute each time), and post_run (change the signature of the outputs according to the contents of the file created).

=== A compiler producing source files with names unknown in advance

The example below demonstrates how to tackle the following requirements:

. A compiler 'produces source files' (.c files) which are to be processed
. The source file names are 'not known in advance'
. The task must be 'run only if necessary'
. Other tasks 'may depend on the tasks' processing the source produced (compile and link the .c files)

The main difficulty in this scenario is to store the information on the source file produced and to create the corresponding tasks each time.

[source,python]
---------------
## A DEMO ##

VERSION='0.0.1'
APPNAME='unknown_outputs'
srcdir = '.'
blddir = 'build'

def configure(conf):
	# used only when configured from the same folder
	conf.check_tool('gcc')
	conf.env.SHPIP_COMPILER = os.getcwd() + os.sep + "bad_compiler.py"

def build(bld):
	staticlib = bld()
	staticlib.features = 'cc cstaticlib'
	staticlib.source = 'x.c foo.shpip' <1>
	staticlib.target='teststaticlib'
	staticlib.includes = '.'


## INTERNAL CODE BELOW ##

import os
import TaskGen, Task, Utils, Build
from TaskGen import taskgen, feature, before, after, extension
from logging import debug
from Constants import *

@taskgen
@after('apply_link')
@extension('.shpip')
def process_shpip(self, node): <2>
	tsk = shpip_task(self.env, generator=self)
	tsk.task_gen = self
	tsk.set_inputs(node)

class shpip_task(Task.Task): <3>
	"""
	A special task, which finds its outputs once it has run
	It outputs cpp files that must be compiled too
	"""

	color = 'PINK'
	quiet = True <4>

	# important, no link before all shpip are done
	before = ['cc_link', 'cxx_link', 'ar_link_static']

	def __init__(self, *k, **kw):
		Task.Task.__init__(self, *k, **kw)

	def run(self): <5>
		"runs a program that creates cpp files, capture the output to compile them"
		node = self.inputs[0]

		dir = self.generator.bld.srcnode.bldpath(self.env)
		cmd = 'cd %s && %s %s' % (dir, self.env.SHPIP_COMPILER, node.abspath(self.env))
		try:
			# read the contents of the file and create cpp files from it
			files = os.popen(cmd).read().strip()
		except:
			# comment the following line to disable debugging
			#raise
			return 1 # error

		# the variable lst should contain a list of paths to the files produced
		lst = Utils.to_list(files)

		# Waf does not know "magically" what files are produced
		# In the most general case it may be necessary to run os.listdir() to see them
		# In this demo the command outputs is giving us this list

		# the files exist in the build dir only so we do not use find_or_declare
		build_nodes = [node.parent.exclusive_build_node(x) for x in lst]
		self.outputs = build_nodes

		# create the cpp tasks, in the thread
		self.more_tasks = self.add_cpp_tasks(build_nodes) <6>

		# cache the file names and the task signature
		node = self.inputs[0]
		sig = self.signature()
		self.generator.bld.raw_deps[self.unique_id()] = [sig] + lst

		return 0 # no error

	def runnable_status(self):
		# look at the cache, if the shpip task was already run
		# and if the source has not changed, create the corresponding cpp tasks

		for t in self.run_after:
			if not t.hasrun:
				return ASK_LATER

		tree = self.generator.bld
		node = self.inputs[0]
		try: <7>
			sig = self.signature()
			key = self.unique_id()
			deps = tree.raw_deps[key]
			prev_sig = tree.task_sigs[key][0]
		except KeyError:
			pass
		else:
			# if the file has not changed, create the cpp tasks
			if prev_sig == sig:
				lst = [self.task_gen.path.exclusive_build_node(y) for y in deps[1:]]
				self.set_outputs(lst)
				lst = self.add_cpp_tasks(lst) <8>
				for tsk in lst:
					generator = self.generator.bld.generator
					generator.outstanding.append(tsk)


		if not self.outputs:
			return RUN_ME

		# this is a part of Task.Task:runnable_status: first node does not exist -> run
		# this is necessary after a clean
		env = self.env
		node = self.outputs[0]
		variant = node.variant(env)

		try:
			time = tree.node_sigs[variant][node.id]
		except KeyError:
			debug("run task #%d - the first node does not exist" % self.idx, 'task')
			try: new_sig = self.signature()
			except KeyError:
				return RUN_ME

			ret = self.can_retrieve_cache(new_sig)
			return ret and SKIP_ME or RUN_ME

		return SKIP_ME

	def add_cpp_tasks(self, lst): <9>
		"creates cpp tasks after the build has started"
		tgen = self.task_gen
		tsklst = []

		for node in lst:
			TaskGen.task_gen.mapped['c_hook'](tgen, node)
			task = tgen.compiled_tasks[-1]
			task.set_run_after(self)

			# important, no link before compilations are all over
			try:
				self.generator.link_task.set_run_after(task)
			except AttributeError:
				pass

			tgen.link_task.inputs.append(task.outputs[0])
			tsklst.append(task)

			# if headers are produced something like this can be done
			# to add the include paths
			dir = task.inputs[0].parent
			# include paths for c++ and c
			self.env.append_unique('_CXXINCFLAGS', '-I%s' % dir.abspath(self.env))
			self.env.append_unique('_CCINCFLAGS', '-I%s' % dir.abspath(self.env))
			self.env.append_value('INC_PATHS', dir) # for the waf preprocessor

		return tsklst
---------------

<1> An example. The source line contains a directive 'foo.shpip' which triggers the creation of a shpip task (it does not represent a real file)
<2> This method is used to create the shpip task when a file ending in '.shpip' is found
<3> Create the new task type
<4> Disable the warnings raised because the task has no input and outputs
<5> Execute the task
<6> Retrieve the information on the source files created
<7> Create the c++ tasks used for processing the source files found
<8> f the tasks are created during a task execution (in an execution thread), the tasks must be re-injected by adding them to the attribute 'more_tasks'
<9> If the tasks are created during the task examination (runnable_status), the tasks can be injected directly in the build by using the attribute 'outstanding' of the scheduler

