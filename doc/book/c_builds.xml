<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>C and C++ projects</title>
	<section>
		<title>Build model for C/C++</title>
		<para>
			The c/c++ builds consist in transforming source files into object files, and to assemble the object files at the end. In theory a single programming language should be sufficient for writing any application, but in practice small variations exist:
			<itemizedlist>
				<listitem>Applications may be divided in dynamic or static libraries</listitem>
				<listitem>Additional files may enter in the link step (libraries, object files)</listitem>
				<listitem>Source files may be generated by other compilers</listitem>
			</itemizedlist>
		The construction of c/c++ applications can be quite complicated, and several measures must be taken to ensure coherent interaction with new compilation rules. The canonical code for a task generator building a c/c++ application is the following:
			<programlisting language="python">
def build(bld):
	tgen = bld.task_generator('c', 'program') <co id="taskgen-co" linkends="al"/>
	tgen.source = 'main.c' <co id="src-co" linkends="a2"/>
	tgen.target = 'appname' <co id="tgt-co" linkends="a3"/>
	tgen.includes = '.' <co id="incl-co" linkends="a4"/>
			</programlisting>

			<calloutlist>
				<callout arearefs="taskgen-co" id="a1">
					<para>Task generator declaration; each element in the list represent a feature corresponding to a method having the correponding annotation, for example <emphasis>@program</emphasis></para>
				</callout>
				<callout arearefs="src-co" id="a2">
					<para>List of source, it may be either a python list, or a string containing the file names separated with spaces. This list may contain file names of different extensions to make hybrid applications.</para>
				</callout>
				<callout arearefs="tgt-co" id="a3">
					<para>Target name, it is concerted to the name of the binary <emphasis>name.so</emphasis> or <emphasis>name.exe</emphasis> depending on the platform and the features.</para>
				</callout>
				<callout arearefs="incl-co" id="a4">
					<para>List of include paths, it may be either a python list, or a string containing the paths separated by spaces. The paths are used for both the command-line and for finding the implicit dependencies (headers). In general, include paths must be relative to the wscript file and given explicitely. See the preprocessor section for more information.</para>
				</callout>
			</calloutlist>
		</para>
	</section>
	<section>
		<title>Writing a configuration header</title>
		<para>
			Writing configuration headers can be performed using the following methods:
			<programlisting language="python">
def configure(conf):
	conf.add_define('LIBF')
	conf.undefine('LIBF')
	conf.add_define('LIBF', 1)
	conf.add_define('LIBF_VERSION', '1.0.2')
	conf.write_config_header('config.h')
			</programlisting>
			The code snipped will produce the following <emphasis>config.h</emphasis> in the build directory:
			<programlisting language="sh">
build/
|-- c4che
|   |-- build.config.py
|   `-- default.cache.py
|-- config.log
`-- default
    `-- config.h
			</programlisting>
			The contents of the config.h for this example are
			<programlisting language="c">
/* Configuration header created by Waf - do not edit */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

/* #undef NOLIBF */
#define LIBF 1
#define LIBF_VERSION "1.0.2"

#endif /* _CONFIG_H_WAF */
			</programlisting>
		</para>
	</section>

	<section>
		<title>Task generators for C/C++ builds</title>
		<para>
			TODO Detail the main task generator attributes, includes, cxxflags, etc
		</para>
	</section>

	<section>
		<title>The creation of C/C++ tasks</title>
		<para>
			TODO activity diagram needed here
		</para>
	</section>

	<section>
		<title>The uselib system</title>
		<para>
			TODO
		</para>
	</section>

	<section>
		<title>The Waf preprocessor</title>
		<para>
			Waf uses a preprocessor written in Python for finding the headers on which the source files depend (implicity dependencies). By default the preprocessing is limited to the files present in the project. To enable the preprocessor to find system headers, use the following code:
			<programlisting language="python">
import preproc
preproc.go_absolute = 1
			</programlisting>
		</para>
	</section>
</chapter>

