<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>C and C++ projects</title>
	<section>
		<title>Common script for C/C++ applications</title>
		<para>
			The c/c++ builds consist in transforming source files into object files, and to assemble the object files at the end. In theory a single programming language should be sufficient for writing any application, but in practice slight variations exist:
			<itemizedlist>
				<listitem>Applications may be divided in dynamic or static libraries</listitem>
				<listitem>Additional files may enter in the link step (libraries, object files)</listitem>
				<listitem>Source files may be generated by other compilers</listitem>
			</itemizedlist>
		The construction of c/c++ applications can be quite complicated, and several measures must be taken to ensure coherent interaction with new compilation rules. The canonical code for a task generator building a c/c++ application is the following:
			<programlisting language="python">
def build(bld):
	tgen = bld.new_task_gen('c', 'program') <co id="taskgen-co" linkends="al"/>
	tgen.source = 'main.c' <co id="src-co" linkends="a2"/>
	tgen.target = 'appname' <co id="tgt-co" linkends="a3"/>
	tgen.includes = '.' <co id="incl-co" linkends="a4"/>
	tgen.install_path = '${SOME_PATH}/bin' <co id="inst-co" linkends="a5"/>
	tgen.defines = 'LINUX=1 BIDULE' <co id="defi-co" linkends="a6"/>
	tgen.ccflags = '-O2 -Wall' <co id="ccflags-co" linkends="a7"/>
			</programlisting>

			<calloutlist>
				<callout arearefs="taskgen-co" id="a1">
					<para>Task generator declaration; each element in the list represent a feature; it is possible to add several languages at once (<emphasis>ocaml and c++</emphasis> for example), but the one of <emphasis>objects, staticlib, shlib or program</emphasis> must be chosen.</para>
				</callout>
				<callout arearefs="src-co" id="a2">
					<para>List of source, it may be either a python list, or a string containing the file names separated with spaces. This list may contain file names of different extensions to make hybrid applications.</para>
				</callout>
				<callout arearefs="tgt-co" id="a3">
					<para>Target name, it is concerted to the name of the binary <emphasis>name.so</emphasis> or <emphasis>name.exe</emphasis> depending on the platform and the features.</para>
				</callout>
				<callout arearefs="incl-co" id="a4">
					<para>List of include paths, it may be either a python list, or a string containing the paths separated by spaces. The paths are used for both the command-line and for finding the implicit dependencies (headers). In general, include paths must be relative to the wscript file and given explicitly. See <xref linkend="include_sys"/>.</para>
				</callout>
				<callout arearefs="inst-co" id="a5">
					<para>Installation directory, this is where to install the library or program produced. The <emphasis>${}</emphasis> expression is a reference to a variable to be extracted from <emphasis>tgen.env</emphasis>. By default it is set to ${PREFIX}/bin for programs and ${PREFIX}/lib for libraries. To disable the installation, set it to <emphasis>None</emphasis>.</para>
				</callout>
				<callout arearefs="defi-co" id="a6">
					<para>Command-line defines: list of defines to add to the command-line with the <emphasis>-D</emphasis> prefix. To reduce the size of the command-line, it is possible to use a configuration header, see the following section for more details.</para>
				</callout>
				<callout arearefs="ccflags-co" id="a7">
					<para>Command-line compilation flags, for the c++ language the attribute is called <emphasis>cxxflags</emphasis></para>
				</callout>
			</calloutlist>
		</para>
	</section>

	<section>
		<title>Library interaction (uselib)</title>
		<para>
			To link a library against another one created in the same Waf project, the attribute <emphasis>uselib_local</emphasis> may be used. The include paths, the link path and the library name are automatically exported, and the dependent binary is recompiled when the library changes:
			<programlisting language="python">
def build(bld):
	staticlib = bld.new_task_gen('cc', 'staticlib') <co id="lib-co" linkends="b1"/>
	staticlib.source = 'test_staticlib.c'
	staticlib.target = 'teststaticlib'

	main = bld.new_task_gen('cc', 'program') <co id="prog-co" linkends="b2"/>
	main.source = 'main.c'
	main.target = 'test_c_program'
	main.includes = '.'
	main.uselib_local = 'teststaticlib' <co id="uselib-co" linkends="b3"/>
			</programlisting>

			<calloutlist>
				<callout arearefs="lib-co" id="b1">
					<para>A static library</para>
				</callout>
				<callout arearefs="prog-co" id="b2">
					<para>A program using the static library declared previously</para>
				</callout>
				<callout arearefs="uselib-co" id="b3">
					<para>A list of references to existing libraries declared in the project (either a python list or a string containing the names space-separated)</para>
				</callout>
			</calloutlist>
		</para>
		<para>
			To link an application against various <emphasis>system libraries</emphasis>, several compilation flags and link flags must be given at once. To reduce the maintenance, a system called <emphasis>uselib</emphasis> can be used to give all the flags at the same time:
			<programlisting language="python">
def configure(conf):
	conf.env['CCFLAGS_TEST'] = '-O2' <co id="uselib-vars-co" linkends="c1"/>
	conf.env['LINKFLAGS_TEST'] = '-g'

def build(bld):
	staticlib = bld.new_task_gen('cc', 'staticlib')
	staticlib.source = 'test_staticlib.c'
	staticlib.target = 'teststaticlib'
	staticlib.uselib = 'TEST' <co id="uselib-use-co" linkends="c2"/>
			</programlisting>
			<calloutlist>
				<callout arearefs="uselib-vars-co" id="c1">
					<para>Declare a few variables during the configuration, the variables follow the convention VAR_NAME</para>
				</callout>
				<callout arearefs="uselib-use-co" id="c2">
					<para>Add all the VAR_NAME corresponding to the uselib NAME, which is 'TEST' in this example</para>
				</callout>
			</calloutlist>
			The variables used for c/c++ are the following: STATICLIB, LIB, LIBPATH, LINKFLAGS, RPATH, CXXFLAGS, CCFLAGS, CPPPATH, CPPFLAGS, CXXDEFINES, FRAMEWORK, FRAMEWORKPATH, CXXDEPS. The uselib is similar to the cascading style sheet (CSS) principle.
		</para>
	</section>

	<section>
		<title>Using configuration headers</title>
		<para>
			Adding lots of command-line define values increases the size of the command-line and conceals the useful information (differences). Some projects use headers which are generated during the configuration, they are not modified during the build and they are not installed or redistributed. This system is useful for huge projects, and has been made popular by autoconf-based projects.
		</para>
		<para>
			Writing configuration headers can be performed using the following methods:
			<programlisting language="python">
def configure(conf):
	conf.add_define('LIBF')
	conf.undefine('LIBF')
	conf.add_define('LIBF', 1)
	conf.add_define('LIBF_VERSION', '1.0.2')
	conf.write_config_header('config.h')
			</programlisting>
			The code snipped will produce the following <emphasis>config.h</emphasis> in the build directory:
			<programlisting language="sh">
build/
|-- c4che
|   |-- build.config.py
|   `-- default.cache.py
|-- config.log
`-- default
    `-- config.h
			</programlisting>
			The contents of the config.h for this example are
			<programlisting language="c">
/* Configuration header created by Waf - do not edit */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

/* #undef NOLIBF */
#define LIBF 1
#define LIBF_VERSION "1.0.2"

#endif /* _CONFIG_H_WAF */
			</programlisting>
		</para>
	</section>

	<section id="include_sys">
		<title>The include system</title>
		<para>
			Include paths are used by the c/c++ compilers for finding the headers. Though some compilers (gcc) can use the folder of the source file for finding other includes implicitly, Waf requires the explicit list of the include paths. When one header changes, the files are recompiled automatically.
		</para>

		<para>
			Waf uses a preprocessor written in Python for finding the headers. By default the preprocessing is limited to the paths within the project. To enable the preprocessor to find system headers, use the following code:
			<programlisting language="python">
import preproc
preproc.go_absolute = True
			</programlisting>
		</para>
		<para>
			To include files conditionally, it is recommended to check the define conditions during the configuration, to store them in a <filename>config.h</filename> file, and to use simple #if/endif blocks. Variables defined by compilers internally or defined in system headers may be missed by the Waf preprocessor.
		</para>
	</section>

	<section>
		<title>Configuration helpers</title>
		<para>
			The methods <emphasis>check_cc</emphasis> and <emphasis>check_cxx</emphasis> are used to detect parameters using a small build project. The main parameters are the following
			<itemizedlist>
				<listitem>msg: title of the test to execute</listitem>
				<listitem>okmsg: message to display when the test succeeds</listitem>
				<listitem>errmsg: message to display when the test fails</listitem>
				<listitem>mandatory: when true, raise a configuration exception if the test fails</listitem>
				<listitem>env: environment to use for the build (conf.env is used by default)</listitem>
				<listitem>define_name: add a define for the configuration header when the test succeeds (in most cases it is calculated automatically)</listitem>
			</itemizedlist>
			Here is a concrete example:
			<programlisting language="python">
def configure(conf):

	conf.check_cc(header_name='time.h') <co id="cc1-co" linkends="ccl"/>
	conf.check_cc(function_name='printf', header_name="stdio.h", mandatory=1) <co id="cc2-co" linkends="cc2"/>
	conf.check_cc(fragment='int main() {2+2==4;}\n', define_name="boobah") <co id="cc3-co" linkends="cc3"/>
	conf.check_cc(lib='m', ccflags='-Wall', defines=['var=foo', 'x=y'], uselib_store='M') <co id="cc4-co" linkends="cc4"/>
	conf.check_cc(lib='linux', uselib='M') <co id="cc5-co" linkends="cc5"/>

	conf.check_cc(fragment='''
			#include &lt;stdio.h&gt;
			int main() { printf("4"); return 0; } ''',
		define_name="booeah",
		execute="1",
		define_ret="1",
		msg="Checking for something") <co id="cc6-co" linkends="cc6"/>

	conf.write_config_header('config.h') <co id="cc7-co" linkends="cc7"/>
			</programlisting>
			<calloutlist>
				<callout arearefs="cc1-co" id="cc1">
					<para>Try to compile a program using the configuration header time.h, if present on the system, if the test is successful, the define TIME_H will be added</para>
				</callout>
				<callout arearefs="cc2-co" id="cc2">
					<para>Try to compile a program with the function printf, adding the header stdio.h (the header_name may be a list of additional headers). The parameter mandatory will make the test raise an exception if it fails.</para>
				</callout>
				<callout arearefs="cc3-co" id="cc3">
					<para>Try to compile a code fragment, and if the test is successful, define the name boobah</para>
				</callout>
				<callout arearefs="cc4-co" id="cc4">
					<para>Modifications made to the task generator environment are not stored. When the test is successful and when the attribute uselib_store is provided, the names lib, cflags and defines will be converted into uselib variables LIB_M, CCFLAGS_M and DEFINE_M and the flag values are added to the configuration environment.</para>
				</callout>
				<callout arearefs="cc5-co" id="cc5">
					<para>Try to compile a simple c program against a library called 'linux', and reuse the previous parameters for libm (uselib)</para>
				</callout>
				<callout arearefs="cc6-co" id="cc6">
					<para>Execute a simple program, collect the output, and put it in a define when successful</para>
				</callout>
				<callout arearefs="cc7-co" id="cc7">
					<para>After all the tests are executed, write a configuration header in the build directory (optional). The configuration header is used to limit the size of the command-line.</para>
				</callout>
			</calloutlist>
			Here is an example of a <emphasis>config.h</emphasis> produced with the previous test code:
			<programlisting language="c">
/* Configuration header created by Waf - do not edit */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

#define HAVE_PRINTF 1
#define HAVE_TIME_H 1
#define boobah 1
#define booeah "4"

#endif /* _CONFIG_H_WAF */
			</programlisting>
			The file <filename>default.cache.py</filename> will contain the following variables:
			<programlisting language="python">
CCDEFINES_M = ['var=foo', 'x=y']
CXXDEFINES_M = ['var=foo', 'x=y']
CXXFLAGS_M = ['-Wall']
CCFLAGS_M = ['-Wall']
LIB_M = ['m']
boobah = 1
booeah = '4'
defines = {'booeah': '"4"', 'boobah': 1, 'HAVE_TIME_H': 1, 'HAVE_PRINTF': 1}
dep_files = ['config.h']
waf_config_files = ['/compilation/waf/demos/adv/build/default/config.h']
			</programlisting>
		</para>
	</section>

	<section>
		<title>Pkg-config</title>
		<para>
			Instead of duplicating the configuration detection in all dependent projects, configuration files may be written when libraries are installed. To ease the interaction with build systems based on Make (cannot query databases or apis), small applications have been created for reading the cache files and to interpret the parameters (with names traditionally ending in <emphasis>-config</emphasis>): <ulink url="http://pkg-config.freedesktop.org/wiki/">pkg-config</ulink>, wx-config, sdl-config, etc.
		</para>
		<para>
			Waf provides the method <emphasis>check_cfg</emphasis> for querying config parameters:
			<programlisting language="python">
def configure(conf):
	conf.check_cfg(atleast_pkgconfig_version='0.0.0') <co id="pk1-co" linkends="pk1"/>
	conf.check_cfg(package='pango', atleast_version='0.0.0') <co id="pk2-co" linkends="pk2"/>
	conf.check_cfg(package='pango', exact_version='0.21')
	conf.check_cfg(package='pango', max_version='9.0.0')
	conf.check_cfg(package='pango', args='--cflags --libs') <co id="pk3-co" linkends="pk3"/>
	pango_version = conf.check_cfg(modversion='pango') <co id="pk4-co" linkends="pk4"/>
	conf.check_cfg(path='sdl-config', args='--cflags --libs', package='', uselib_store='SDL') <co id="pk5-co" linkends="pk5"/>
			</programlisting>
			<calloutlist>
				<callout arearefs="pk1-co" id="pk1">
					<para>Check for the pkg-config version</para>
				</callout>
				<callout arearefs="pk2-co" id="pk2">
					<para>Check for a module version</para>
				</callout>
				<callout arearefs="pk3-co" id="pk3">
					<para>Obtain the flags for a package and assign them to the uselib PANGO (calculated automatically from the package name, can be overridden with the attribute "uselib_store='MYPANGO'")</para>
				</callout>
				<callout arearefs="pk4-co" id="pk4">
					<para>Retrieve the module version for a package. The returned object is a string containing the version number or an empty string in case of any errors. If there were no errors, 'PANGO_VERSION' is defined, can be overridden with the attribute "uselib_store='MYPANGO'".</para>
				</callout>
				<callout arearefs="pk5-co" id="pk5">
					<para>Obtain the flags for a different configuration program (sdl-config). The example is applicable for other configuration programs such as wx-config, pcre-config, etc</para>
				</callout>
			</calloutlist>
		</para>
		<para>
			Due to the amount of flags, the lack of standards between config applications, and to the output changing for different operating systems (-I for gcc, /I for msvc), the output of pkg-config is parsed, and the variables for the corresponding uselib are set in a go. The function <emphasis>parse_flags(line, uselib, env)</emphasis> in the Waf module config_c.py performs the output analysis.
		</para>
	</section>

</chapter>

