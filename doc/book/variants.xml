<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="build">
	<title>Variants</title>
	<section id="build_duplication">
		<title>Using several build folders</title>
		<para>
			It is not possible to use several Waf instances concurrently over the same build folder. Yet, several Waf instances may use the project at the same time. For this, two options must be set:
			<itemizedlist>
				<listitem>The environment variable <emphasis>WAFCACHE</emphasis></listitem>
				<listitem>The build directory, using a command-line option</listitem>
			</itemizedlist>
			Here is an example for a simple project located in <filename>/tmp/smallfolder</filename>:
			<programlisting language="python">
			</programlisting>

			Upon execution, the results will be the following:

			<programlisting language="shell">
$ export WAFLOCK=.lock-debug <co id="lock-co1" linkends="lock1"/>

$ waf distclean configure -b debug <co id="lock-co2" linkends="lock2"/>
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)

$ waf
Waf: Entering directory `/tmp/smallproject/debug'
[1/1] foo.txt:  -> debug/default/foo.txt <co id="lock-co3" linkends="lock3"/>
Waf: Leaving directory `/tmp/smallproject/debug'
'build' finished successfully (0.012s)

$ export WAFLOCK=.lock-release

$ waf distclean configure -b release
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.176s)

$ waf
Waf: Entering directory `/tmp/smallproject/release' <co id="lock-co4" linkends="lock4"/>
[1/1] foo.txt:  -> release/default/foo.txt
Waf: Leaving directory `/tmp/smallproject/release'
'build' finished successfully (0.034s)

$ tree -a
.
|-- .lock-debug <co id="lock-co5" linkends="lock5"/>
|-- .lock-release
|-- debug
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|       `-- foo.txt
|-- release
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|       `-- foo.txt
`-- wscript
			</programlisting>

			<calloutlist>
                <callout arearefs="lock-co1" id="lock1"><para>The environment variable <emphasis>WAFLOCK</emphasis> points at the configuration of the project in use.</para></callout>
				<callout arearefs="lock-co2" id="lock2"><para>The lockfile is created during the configuration.</para></callout>
				<callout arearefs="lock-co3" id="lock3"><para>The files are output in the build directory<filename>debug</filename></para></callout>
				<callout arearefs="lock-co4" id="lock4"><para>The configuration <emphasis>release</emphasis> is used with a different lock file and a different build directory.</para></callout>
				<callout arearefs="lock-co5" id="lock5"><para>The contents of the project directory contain the two lock files and the two build folders.</para></callout>
			</calloutlist>
		</para>
	</section>


	<section id="config_variants">
		<title>Defining variants and configuration sets</title>
		<para>
			Using different build folders is very useful for checking at some point if a different configuration would compile properly. To create different configurations at once, it is possible to use <emphasis>Waf variants</emphasis> to predefine the configuration sets and to automate the build process.
		</para>

		<para>
			We will now demonstrate the definition and the usage of two variants named <emphasis>default</emphasis> and <emphasis>debug</emphasis>respectively:
			<programlisting language="python">
srcdir = '.'
blddir = 'out_bld'

def configure(conf):
	conf.env.NAME = 'default'
    dbg = conf.env.copy() <co id="vari-co1" linkends="vari1"/>
    rel = conf.env.copy()

    dbg.set_variant('debug') <co id="vari-co2" linkends="vari2"/>
    conf.set_env_name('debug', dbg) <co id="vari-co3" linkends="vari3"/>
    conf.setenv('debug') <co id="vari-co4" linkends="vari4"/>
	# conf.check_tool('gcc') <co id="vari-co44" linkends="vari44"/>
    conf.env.NAME = 'foo' <co id="vari-co5" linkends="vari5"/>

    rel.set_variant('release') <co id="vari-co6" linkends="vari6"/>
    conf.set_env_name('cfg_name', rel)
    conf.setenv('cfg_name')
    conf.env.NAME = 'bar'

def build(bld):

    bld(rule='echo ${NAME} > ${TGT}', target='test.txt') <co id="vari-co7" linkends="vari7"/>
    bld(rule='echo ${NAME} > ${TGT}', target='test.txt'<co id="vari-co8" linkends="vari8"/>, env=bld.env_of_name('debug').copy()) <co id="vari-co9" linkends="vari9"/>
    bld(rule='echo ${NAME} > ${TGT}', target='test.txt', env=bld.env_of_name('cfg_name').copy())
			</programlisting>

			<calloutlist>
				<callout arearefs="lock-co1" id="vari1"><para>Create a copy of the default data set.</para></callout>
				<callout arearefs="lock-co2" id="vari2"><para>Set the copy to use the variant named <emphasis>debug</emphasis>: task using it will output their files into <filename>out_bld/debug</filename></para></callout>
				<callout arearefs="lock-co3" id="vari3"><para>Bind the configuration set to the configuration. The configuration set will be saved when the configuration terminates</para></callout>
				<callout arearefs="lock-co4" id="vari4"><para>Replace <emphasis>conf.env</emphasis> by our new debug configuration set</para></callout>
				<callout arearefs="lock-co44" id="vari44"><para>Waf tools store their configuration data on conf.env, in this case the <emphasis>debug</emphasis> configuration set, not in the default</para></callout>
				<callout arearefs="lock-co5" id="vari5"><para>Store a variable on the <emphasis>debug</emphasis> configuration set</para></callout>
				<callout arearefs="lock-co6" id="vari6"><para>Define another variant called </emphasis>release</emphasis>. The variant name and the configuration set name may be different.</para></callout>
				<callout arearefs="lock-co7" id="vari7"><para>Task generator for the default variant.</para></callout>
				<callout arearefs="lock-co8" id="vari8"><para>The argument <emphasis>env</emphasis> is given to specify the task generator configuration set. The configuration set holds the variant definition.</para></callout>
				<callout arearefs="lock-co9" id="vari9"><para>Environments may be retrieved by name from the build context object. It is recommended to make copies to avoid accidental data sharing.</para></callout>
			</calloutlist>

			Upon execution, an output similar to the following will be observed:

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.000s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject/out_bld'
[1/3] test.txt:  -> out_bld/default/test.txt
[2/3] test.txt:  -> out_bld/debug/test.txt <co id="varii-co1" linkends="varii1"/>
[3/3] test.txt:  -> out_bld/release/test.txt
Waf: Leaving directory `/tmp/smallproject/out_bld'
'build' finished successfully (0.020s)

$ tree out_bld/
out_bld/
|-- c4che
|   |-- cfg_name.cache.py <co id="varii-co2" linkends="varii2"/>
|   |-- build.config.py
|   |-- debug.cache.py
|   `-- default.cache.py
|-- config.log
|-- debug
|   `-- test.txt
|-- default
|   `-- test.txt <co id="varii-co3" linkends="varii3"/>
`-- release
    `-- test.txt

$ cat out_bld/default/test.txt out_bld/debug/test.txt out_bld/release/test.txt
default <co id="varii-co4" linkends="varii4"/>
foo
bar
			</programlisting>

			<calloutlist>
				<callout arearefs="varii-co1" id="varii1"><para>The files are output in their respective variants</para></callout>
				<callout arearefs="varii-co2" id="varii2"><para>The configuration sets are stored and retrieved by names, which must be valid filenames without blanks.</para></callout>
				<callout arearefs="varii-co3" id="varii3"><para>The tasks output their files in the relevant variant</para></callout>
				<callout arearefs="varii-co4" id="varii4"><para>The file contents are different and correspond to the configuration sets used</para></callout>
			</calloutlist>

		</para>

	</section>

<!--
	<section id="variants">
		<title>Using variants</title>
		<para>


		</para>
	</section>
-->

	<section id="cloning_taskgens">
		<title>Cloning task generators</title>
		<para>

			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
	dbg = conf.env.copy()
	rel = conf.env.copy()

	dbg.set_variant('debug')
	conf.set_env_name('debug', dbg)
	conf.setenv('debug')

	rel.set_variant('release')
	conf.set_env_name('release', rel)
	conf.setenv('release')

def build(bld):

	bld(rule='touch ${TGT}', target='foo.txt')

	for obj in bld.all_task_gen[:]:

		debug_obj = obj.clone('debug')
		release_obj = obj.clone('release')

		# disable the original task generator for the default variant (do not use it)
		obj.posted = 1

		# disable the unwanted variant(s)
		kind = Options.options.build_kind
		if kind.find('debug') &lt; 0:
			debug_obj.posted = 1
		if kind.find('release') &lt; 0:
			release_obj.posted = 1
			</programlisting>

			do not make clones for the current variant
		</para>
	</section>


</chapter>

