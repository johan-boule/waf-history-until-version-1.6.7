<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="variants">
	<title>Build copies and variants</title>
	<section id="build_duplication">
		<title>Using several build folders</title>
		<para>
			It is not possible to use several Waf instances concurrently over the same build folder. Yet, several Waf instances may use the project at the same time. For this, two options must be set:
			<itemizedlist>
				<listitem>The environment variable <emphasis>WAFCACHE</emphasis></listitem>
				<listitem>The build directory, using a command-line option</listitem>
			</itemizedlist>
			Here is an example for a simple project located in <filename>/tmp/smallfolder</filename>:
			<programlisting language="python">
srcdir = '.'
blddir = 'out_directory'

def configure(conf):
    pass

def build(bld):
    bld(rule='touch ${TGT}', target='foo.txt')
			</programlisting>

			Upon execution, the results will be the following:

			<programlisting language="shell">
$ export WAFLOCK=.lock-debug <co id="lock-co1" linkends="lock1"/>

$ waf distclean configure -b debug <co id="lock-co2" linkends="lock2"/>
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)

$ waf
Waf: Entering directory `/tmp/smallproject/debug'
[1/1] foo.txt:  -> debug/default/foo.txt <co id="lock-co3" linkends="lock3"/>
Waf: Leaving directory `/tmp/smallproject/debug'
'build' finished successfully (0.012s)

$ export WAFLOCK=.lock-release

$ waf distclean configure -b release
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.176s)

$ waf
Waf: Entering directory `/tmp/smallproject/release' <co id="lock-co4" linkends="lock4"/>
[1/1] foo.txt:  -> release/default/foo.txt
Waf: Leaving directory `/tmp/smallproject/release'
'build' finished successfully (0.034s)

$ tree -a
.
|-- .lock-debug <co id="lock-co5" linkends="lock5"/>
|-- .lock-release
|-- debug
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|       `-- foo.txt
|-- release
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|       `-- foo.txt
`-- wscript
			</programlisting>

			<calloutlist>
                <callout arearefs="lock-co1" id="lock1"><para>The environment variable <emphasis>WAFLOCK</emphasis> points at the configuration of the project in use.</para></callout>
				<callout arearefs="lock-co2" id="lock2"><para>The lockfile is created during the configuration.</para></callout>
				<callout arearefs="lock-co3" id="lock3"><para>The files are output in the build directory<filename>debug</filename></para></callout>
				<callout arearefs="lock-co4" id="lock4"><para>The configuration <emphasis>release</emphasis> is used with a different lock file and a different build directory.</para></callout>
				<callout arearefs="lock-co5" id="lock5"><para>The contents of the project directory contain the two lock files and the two build folders.</para></callout>
			</calloutlist>
		</para>
	</section>

	<section id="config_variants">
		<title>Defining variants</title>
		<para>
			Using different build folders is very useful for checking at some point if a different configuration would compile properly. To create different kinds of builds at once, it is possible to use <emphasis>Waf variants</emphasis> to predefine the configuration sets for specific output subdirectories.
		</para>

		<para>
			We will now demonstrate the definition and the usage of two variants named <emphasis>default</emphasis> and <emphasis>debug</emphasis> respectively:
			<programlisting language="python">
srcdir = '.'
blddir = 'out_bld'

def configure(conf):
	conf.env.NAME = 'default'
	dbg = conf.env.copy() <co id="vari-co1" linkends="vari1"/>
	rel = conf.env.copy()

	dbg.set_variant('debug') <co id="vari-co2" linkends="vari2"/>
	conf.set_env_name('debug', dbg) <co id="vari-co3" linkends="vari3"/>
	conf.setenv('debug') <co id="vari-co4" linkends="vari4"/>
	# conf.check_tool('gcc') <co id="vari-co44" linkends="vari44"/>
	conf.env.NAME = 'foo' <co id="vari-co5" linkends="vari5"/>

	rel.set_variant('release') <co id="vari-co6" linkends="vari6"/>
	conf.set_env_name('cfg_name', rel)
	conf.setenv('cfg_name')
	conf.env.NAME = 'bar'

def build(bld):
	bld(rule='echo ${NAME} > ${TGT}', target='test.txt') <co id="vari-co7" linkends="vari7"/>
	bld(rule='echo ${NAME} > ${TGT}', target='test.txt'<co id="vari-co8" linkends="vari8"/>, env=bld.env_of_name('debug').copy()) <co id="vari-co9" linkends="vari9"/>
	bld(rule='echo ${NAME} > ${TGT}', target='test.txt', env=bld.env_of_name('cfg_name').copy())
			</programlisting>

			<calloutlist>
				<callout arearefs="vari-co1" id="vari1"><para>Create a copy of the default data set.</para></callout>
				<callout arearefs="vari-co2" id="vari2"><para>Set the copy to use the variant named <emphasis>debug</emphasis>: task using it will output their files into <filename>out_bld/debug</filename></para></callout>
				<callout arearefs="vari-co3" id="vari3"><para>Bind the configuration set to the configuration. The configuration set will be saved when the configuration terminates</para></callout>
				<callout arearefs="vari-co4" id="vari4"><para>Replace <emphasis>conf.env</emphasis> by our new debug configuration set</para></callout>
				<callout arearefs="vari-co44" id="vari44"><para>Waf tools store their configuration data on conf.env, in this case the <emphasis>debug</emphasis> configuration set, not in the default</para></callout>
				<callout arearefs="vari-co5" id="vari5"><para>Store a variable on the <emphasis>debug</emphasis> configuration set</para></callout>
				<callout arearefs="vari-co6" id="vari6"><para>Define another variant called <emphasis>release</emphasis>. The variant name and the configuration set name may be different.</para></callout>
				<callout arearefs="vari-co7" id="vari7"><para>Task generator for the default variant.</para></callout>
				<callout arearefs="vari-co8" id="vari8"><para>The argument <emphasis>env</emphasis> is given to specify the task generator configuration set. The configuration set holds the variant definition.</para></callout>
				<callout arearefs="vari-co9" id="vari9"><para>Environments may be retrieved by name from the build context object. It is recommended to make copies to avoid accidental data sharing.</para></callout>
			</calloutlist>

			Upon execution, an output similar to the following will be observed:

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.000s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject/out_bld'
[1/3] test.txt:  -> out_bld/default/test.txt
[2/3] test.txt:  -> out_bld/debug/test.txt <co id="varii-co1" linkends="varii1"/>
[3/3] test.txt:  -> out_bld/release/test.txt
Waf: Leaving directory `/tmp/smallproject/out_bld'
'build' finished successfully (0.020s)

$ tree out_bld/
out_bld/
|-- c4che
|   |-- cfg_name.cache.py <co id="varii-co2" linkends="varii2"/>
|   |-- build.config.py
|   |-- debug.cache.py
|   `-- default.cache.py
|-- config.log
|-- debug
|   `-- test.txt
|-- default
|   `-- test.txt <co id="varii-co3" linkends="varii3"/>
`-- release
    `-- test.txt

$ cat out_bld/default/test.txt out_bld/debug/test.txt out_bld/release/test.txt
default <co id="varii-co4" linkends="varii4"/>
foo
bar
			</programlisting>

			<calloutlist>
				<callout arearefs="varii-co1" id="varii1"><para>The files are output in their respective variants</para></callout>
				<callout arearefs="varii-co2" id="varii2"><para>The configuration sets are stored and retrieved by names, which must be valid filenames without blanks.</para></callout>
				<callout arearefs="varii-co3" id="varii3"><para>The tasks output their files in the relevant variant</para></callout>
				<callout arearefs="varii-co4" id="varii4"><para>The file contents are different and correspond to the configuration sets used</para></callout>
			</calloutlist>

		</para>

		<note>
			As a general rule, tasks created for a particular variant should not share data with the tasks from another variant.
		</note>
	</section>


	<section id="cloning_taskgens">
		<title>Cloning task generators</title>
		<para>
			A cloning scheme is provided for duplicating task generators for several variants easily. A general design pattern is to duplicate the task generators for the desired variants immediately before the build starts. Here is an example, also available in the folder <filename>demos/cxx</filename> of the Waf distribution.

			<programlisting language="python">
srcdir = '.'
blddir = 'build'

import Options

def set_options(opt):
	opt.add_option('--build_kind', action='store', default='debug,release', help='build the selected variants') <co id="varai-co1" linkends="varai1"/>

def configure(conf): <co id="varai-co2" linkends="varai2"/>
	dbg = conf.env.copy()
	rel = conf.env.copy()

	dbg.set_variant('debug')
	conf.set_env_name('debug', dbg)
	conf.setenv('debug')

	rel.set_variant('release')
	conf.set_env_name('release', rel)
	conf.setenv('release')

def build(bld):

	bld(rule='touch ${TGT}', target='foo.txt')

	for obj in bld.all_task_gen[:]: <co id="varai-co3" linkends="varai3"/>

		debug_obj = obj.clone('debug') <co id="varai-co4" linkends="varai4"/>
		release_obj = obj.clone('release')

		obj.posted = 1 <co id="varai-co5" linkends="varai5"/>

		kind = Options.options.build_kind <co id="varai-co6" linkends="varai6"/>
		if kind.find('debug') &lt; 0:<co id="varai-co7" linkends="varai7"/>
			debug_obj.posted = 1
		if kind.find('release') &lt; 0:
			release_obj.posted = 1
			</programlisting>

			<calloutlist>
				<callout arearefs="varai-co1" id="varai1"><para>Add a command-line option for enabling or disabling the <emphasis>release</emphasis> and <emphasis>debug</emphasis> builds</para></callout>
				<callout arearefs="varai-co2" id="varai2"><para>The configuration will create the <emphasis>release</emphasis> and <emphasis>debug</emphasis> configuration sets, bound to a variant of the same names</para></callout>
				<callout arearefs="varai-co3" id="varai3"><para>A copy of the existing task generators is created to avoid the creation of an infinite loop. Task generators are added to that list upon creation</para></callout>
				<callout arearefs="varai-co4" id="varai4"><para>Clone a task generator for the configuration set <emphasis>debug</emphasis>. Making task generator clones is a cheap operation compared to duplicating tasks.</para></callout>
				<callout arearefs="varai-co5" id="varai5"><para>Disable the original task generator for the default configuration set (do not use it).</para></callout>
				<callout arearefs="varai-co6" id="varai6"><para>Disable the original task generators for the <emphasis>default</emphasis> configuration set when necessary (the tasks will not be created)</para></callout>
				<callout arearefs="varai-co7" id="varai7"><para>Look at the command-line arguments, and disable the unwanted variant(s)</para></callout>

			</calloutlist>
			Some task generators are use indexed attributes to generate unique values which may cause unnecessary rebuilds if the scripts change. To avoid problems, it is a best practice to create the task generators for the default configuration set first. Also, the method <emphasis>clone</emphasis> is not a substitute for creating instances for lots of nearly identical task generators. In such a situation, it will be better to use one task generator to create lots of tasks. As a reminder, creating task generator clones for the same variant will lead to build errors.

			<warning>
				Do not create task generator clones for the same variant or for the same configuration set.
			</warning>
		</para>
	</section>


</chapter>

