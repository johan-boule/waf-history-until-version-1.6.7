<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="make_like">
	<title>Rule-based task generators (Make-like)</title>
	<para>
		Rule-based task generators are a particular category of task generators producing exactly one task at a time.
	</para>

	<section id="make_like_decl">
		<title>Declaration and usage</title>
		<para>
			The following example presents a simple example of a task generator producing the file <filename>foobar.txt</filename> from the <filename>wscript</filename> by executing a copy (the command 'cp'). Let's create a new project in the folder <filename>/tmp/rule/</filename> containing the following <filename>wscript</filename> file:
			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
	pass

def build(bld):
	bld( <co id="rule1-co" linkends="rule1"/>
		rule   = 'cp ${SRC} ${TGT}', <co id="rule2-co" linkends="rule2"/>
		source = 'wscript', <co id="rule3-co" linkends="rule3"/>
		target = 'foobar.txt', <co id="rule4-co" linkends="rule4"/>
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="rule1-co" id="rule1">
					<para>To instantiate a new task generator, remember that all arguments have the form <emphasis>key=value</emphasis></para>
				</callout>
				<callout arearefs="rule2-co" id="rule2">
					<para>The attribute <emphasis>rule</emphasis> is mandatory here. It represents the command to execute in a readable manner (more on this in the next chapters).</para>
				</callout>
				<callout arearefs="rule3-co" id="rule3">
					<para>Source files, to give in a space-separated list<para>
				</callout>
				<callout arearefs="rule4-co" id="rule4">
					<para>Target files, to give in a space-separated list</para>
				</callout>
			</calloutlist>

			Upon execution, the following output will be observed:

			<programlisting language="sh">
$ waf distclean configure build -v
'distclean' finished successfully (0.000s)
'configure' finished successfully (0.021s)
Waf: Entering directory `/tmp/rule/out'
[1/1] foobar.txt: wscript -> out/default/foobar.txt <co id="rulo1-co" linkends="rulo1"/>
16:24:21 runner system command ->  cp ../wscript default/foobar.txt <co id="rulo2-co" linkends="rulo2"/>
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.016s)

$ tree
.
|-- out
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- default
|       `-- foobar.txt
`-- wscript

$ waf <co id="rulo3-co" linkends="rulo3"/>
Waf: Entering directory `/tmp/rule/out'
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.006s)

$ echo " " >> wscript <co id="rulo4-co" linkends="rulo4"/>

$ waf
Waf: Entering directory `/tmp/rule/out'
[1/1] foobar.txt: wscript -> out/default/foobar.txt <co id="rulo5-co" linkends="rulo5"/>
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.013s)
			</programlisting>

			<calloutlist>
				<callout arearefs="rulo1-co" id="rulo1">
					<para>In the first execution, the target is correctly created</para>
				</callout>
				<callout arearefs="rulo2-co" id="rulo2">
					<para>Command-lines are only displayed in <emphasis>verbose mode</emphasis> by using the option <emphasis>-v</emphasis></para>
				</callout>
				<callout arearefs="rulo3-co" id="rulo3">
					<para>The target are up-to-date, there is nothing to do</para>
				</callout>
				<callout arearefs="rulo4-co" id="rulo4">
					<para>Modify the source file in place by appending a space character</para>
				</callout>
				<callout arearefs="rulo5-co" id="rulo5">
					<para>Since the source has changed, the target is created once again.</para>
				</callout>
			</calloutlist>
		</para>
		The target is created once again whenever the source files or the rule change. This is achieved by computing a signature for the targets, and storing that signature between executions. By default, the signature is computed by hashing the rule and the source files (MD5 by default).
	</section>


	<section id="make_like_funs">
		<title>Rule functions</title>
		<para>
			Rules may be given as expression strings or as python function. Let's modify the previous project file with a python function:

			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
	pass

def build(bld):
	def run(task): <co id="rula1-co" linkends="rula1"/>
		print (' # source is ' + task.generator.source) <co id="rula2-co" linkends="rula2"/>

		src = task.inputs[0].srcpath(task.env) <co id="rula3-co" linkends="rula3"/>
		tgt = task.outputs[0].bldpath(task.env) <co id="rula4-co" linkends="rula4"/>

		import Utils
		cmd = "cp %s %s" % (src, tgt)
		print(cmd)
		return Utils.exec_command(cmd) <co id="rula5-co" linkends="rula5"/>

	bld(
		rule   = run, <co id="rula6-co" linkends="rula6"/>
		source = 'wscript',
		target = 'same.txt',
	)
			</programlisting>

			The execution trace will be similar to the following:

			<calloutlist>
				<callout arearefs="rula1-co" id="rula1">
					<para>Rule functions take the task instance as parameter.</para>
				</callout>
				<callout arearefs="rula2-co" id="rula2">
					<para>Task instances may access their task generator through the attribute <emphasis>generator</emphasis></para>
				</callout>
				<callout arearefs="rula3-co" id="rula3">
					<para>Sources and targets are represented internally as Node objects bound to the task instance.</para>
				</callout>
				<callout arearefs="rula4-co" id="rula4">
					<para>Commands are executed from the root of the build directory. Node methods such as <emphasis>bldpath</emphasis> ease the command line creation.</para>
				</callout>
				<callout arearefs="rula5-co" id="rula5">
					<para>Utils.exec_command(...) is a wrapper around subprocess.Popen(...) from the Python library. Passing a string will execute the command through the system shell (use lists to disable this behaviour). The return code for a rule function must be non-0 to indicate a failure.</para>
				</callout>
				<callout arearefs="rula6-co" id="rula6">
					<para>Use a function instead of a string expression</para>
				</callout>
			</calloutlist>

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/rule/out'
[1/1] same.txt: wscript -> out/default/same.txt
 # source is wscript
cp ../wscript default/same.txt
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.010s)
			</programlisting>

			The rule function must return <emphasis>0</emphasis> to indicate success, and must generate the files corresponding to the outputs. The rule function must also access the task object in a read-only manner, and avoid node creation or attribute modification.

			<note>The string expression <emphasis>cp ${SRC} ${TGT}</emphasis> from the previous example is converted internally to a function similar to <emphasis>run</emphasis></note>
			<note>While a string expression may execute only one system command, functions may execute various commands at once.</note>
			<warning>Due to limitations in the cPython interpreter, only functions defined in python modules can be hashed. This means that changing a function will trigger a rebuild only if it is defined in a waf tool (not in wscript files).</warning>
		</para>
	</section>


	<section id="make_like_shell">
		<title>Shell usage</title>
		<para>
			The attribute <emphasis>shell</emphasis> is used to enable the system shell for command execution. A few points are worth keeping in mind when declaring rule-based task generators:
			<itemizedlist>
				<listitem>The Waf tools do not use the shell for executing commands</listitem>
				<listitem>The shell is used by default for user commands and custom task generators</listitem>
				<listitem>String expressions containing the following symbols <emphasis>&gt;</emphasis>, <emphasis>&lt;</emphasis> or <emphasis>&amp;</emphasis> cannot be transformed into functions to execute commands without a shell, even if told to</listitem>
				<listitem>In general, it is better to avoid the shell whenever possible to avoid quoting problems (paths having blank characters in the name for example)</listitem>
				<listitem>The shell is creating a performance penalty which is more visible on win32 systems.</listitem>
			</itemizedlist>

			Here is an example:

			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
	pass

def build(bld):
    bld(rule='cp ${SRC} ${TGT}', source='wscript', target='f1.txt', shell=False)
    bld(rule='cp ${SRC} ${TGT}', source='wscript', target='f2.txt', shell=True)
			</programlisting>

			Upon execution, the results will be similar to the following:

			<programlisting language="sh">
waf distclean configure build --zones=runner,action <co id="rulb1-co" linkends="rulb1"/>
'distclean' finished successfully (0.004s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/rule/out'
23:11:23 action <co id="rulb2-co" linkends="rulb2"/>
def f(task):
        env = task.env
        wd = getattr(task, 'cwd', None)
        def to_list(xx):
                if isinstance(xx, str): return [xx]
                return xx
        lst = []
        lst.extend(['cp'])
        lst.extend([a.srcpath(env) for a in task.inputs])
        lst.extend([a.bldpath(env) for a in task.outputs])
        lst = [x for x in lst if x]
        return task.exec_command(lst, cwd=wd)

23:11:23 action
def f(task): <co id="rulb3-co" linkends="rulb3"/>
        env = task.env
        wd = getattr(task, 'cwd', None)
        p = env.get_flat
        cmd = ''' cp %s %s ''' % (" ".join([a.srcpath(env) for a in task.inputs]),
                " ".join([a.bldpath(env) for a in task.outputs]))
        return task.exec_command(cmd, cwd=wd)

[1/2] f1.txt: wscript -> out/default/f1.txt
23:11:23 runner system command -> ['cp', '../wscript', 'default/f1.txt'] <co id="rulb4-co" linkends="rulb4"/>
[2/2] f2.txt: wscript -> out/default/f2.txt
23:11:23 runner system command ->  cp ../wscript default/f2.txt
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.017s)
			</programlisting>

			<calloutlist>
				<callout arearefs="rulb1-co" id="rulb1">
					<para>The <emphasis>debugging zones</emphasis> enable the display of specific debugging information (comma-separated values) for the string expression conversion, and <emphasis>runner</emphasis> for command execution</para>
				</callout>
				<callout arearefs="rulb2-co" id="rulb2">
					<para>String expressions are converted to functions (here, without the shell).</para>
				</callout>
				<callout arearefs="rulb3-co" id="rulb3">
					<para>Command execution by the shell. Notice the heavy use of string concatenation.</para>
				</callout>
				<callout arearefs="rulb4-co" id="rulb4">
					<para>Commands to execute are displayed by calling <emphasis>waf --zones=runner</emphasis>. When called without the shell, the arguments are displayed as a list.</para>
				</callout>
			</calloutlist>

			<note>Whenever possible, avoid using the shell to improve both performance and maintainability</note>

		</para>
	</section>

	<section id="make_like_io">
		<title>Inputs and outputs</title>
		<para>
			Source and target arguments are optional for make-like task generators, and may point at one or several files at once. Here are a few examples:

			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
	pass

def build(bld):
    bld( <co id="rulec1-co" linkends="rulec1"/>
		rule   = 'cp ${SRC} ${TGT[0].abspath(env)} &amp;&amp; cp ${SRC} ${TGT[1].abspath(env)}',
		source = 'wscript',
		target = 'f1.txt f2.txt',
		shell  = True
	)

	bld( <co id="rulec2-co" linkends="rulec2"/>
		source = 'wscript',
		rule   = 'echo ${SRC}'
	)

	bld( <co id="rulec3-co" linkends="rulec3"/>
		target = 'test.k3',
		rule   = 'echo "test" > ${TGT}',
	)

	bld( <co id="rulec4-co" linkends="rulec4"/>
		rule   = 'echo 1337'
	)

	bld( <co id="rulec5-co" linkends="rulec5"/>
		rule   = "echo 'task always run'",
		always = True
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="rulec1-co" id="rulec1">
					<para>Generate <emphasis>two files</emphasis> whenever the input or the rule change. Likewise, a rule-based task generator may have multiple input files.</para>
				</callout>
				<callout arearefs="rulec2-co" id="rulec2">
					<para>The command is executed whenever the input or the rule change. There are no declared outputs.</para>
				</callout>
				<callout arearefs="rulec3-co" id="rulec3">
					<para>No input, the command is executed whenever it changes</para>
				</callout>
				<callout arearefs="rulec4-co" id="rulec4">
					<para>No input and no output, the command is executed only when the string expression changes</para>
				</callout>
				<callout arearefs="rulec5-co" id="rulec5">
					<para>No input and no output, the command is executed each time the build is called</para>
				</callout>
			</calloutlist>

			For the record, here is the output of the build:

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.093s)
Waf: Entering directory `/tmp/rule/out'
[1/5] echo 1337:
1337
[2/5] echo 'task always run':
[3/5] echo ${SRC}: wscript
../wscript
[4/5] f1.txt f2.txt: wscript -> out/default/f1.txt out/default/f2.txt
task always run
[5/5] test.k3:  -> out/default/test.k3
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.049s)

$ waf
Waf: Entering directory `/tmp/rule/out'
[2/5] echo 'task always run':
task always run
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.014s)
			</programlisting>

		</para>
	</section>

	<section id="make_like_data">
		<title>Sharing data</title>
		<para>
			Data sharing is performed through the configuration set. The following example illustrates how to use it.

			<programlisting language="python">
srcdir='.'
blddir='out'

import Options

def configure(conf):
    print('prefix: %r' % conf.env.PREFIX)
	print('jobs:   %r' % Options.options.jobs)

def build(bld):
	bld(
		target = 't1.txt',
		rule   = 'echo ${PREFIX} > ${TGT}' <co id="ruled1-co" linkends="ruled1"/>
	)

	obj = bld(
		target = 't2.txt',
		rule   = 'echo ${TEST_VAR} > ${TGT}', <co id="ruled2-co" linkends="ruled2"/>
	)
	obj.env.TEST_VAR <co id="ruled3-co" linkends="ruled3"/>= str(Options.options.jobs) <co id="ruled4-co" linkends="ruled4"/>

	bld(
		rule = 'echo "hey"',
		vars = ['TEST_VAR'], <co id="ruled5-co" linkends="ruled5"/>
		env  = obj.env <co id="ruled6-co" linkends="ruled6"/>
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="ruled1-co" id="ruled1">
					<para>The <emphasis>PREFIX</emphasis> is one of the few predefined variables. It is necessary for computing the default installation path.</para>
				</callout>
				<callout arearefs="ruled2-co" id="ruled2">
					<para>The following rule will create the file <filename>t2.txt</filename> with the contents of <emphasis>TEST_VAR</emphasis></para>
				</callout>
				<callout arearefs="ruled3-co" id="ruled3">
					<para>The value of <emphasis>TEST_VAR</emphasis> will be defined now</para>
				</callout>
				<callout arearefs="ruled4-co" id="ruled4">
					<para>Use the value of a predefined command-line option (the jobs control the amount of commands which may be executed in parallel)</para>
				</callout>
				<callout arearefs="ruled5-co" id="ruled5">
					<para>By default, the variables used in string expressions <emphasis>${...}</emphasis> are extracted automatically and used as dependencies (rebuild the targets when the value change). They are given manually in this case.</para>
				</callout>
				<callout arearefs="ruled6-co" id="ruled6">
					<para>Set the base environment. The variable TEST_VAR will be used for the dependency here.</para>
				</callout>
			</calloutlist>

			By turning the debugging flags on, it will be easier to understand what is happening during the build:

			<programlisting language="sh">
$ waf distclean configure build --zones=runner,action
'distclean' finished successfully (0.003s)
prefix: '/usr/local' <co id="ruledd1-co" linkends="ruledd1"/>
jobs:   2
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/rule/out'
15:21:29 action
def f(task):
        env = task.env
        wd = getattr(task, 'cwd', None)
        p = env.get_flat
        cmd = ''' echo %s > %s ''' % (p('PREFIX'), <co id="ruledd2-co" linkends="ruledd2"/>
                " ".join([a.bldpath(env) for a in task.outputs]))
        return task.exec_command(cmd, cwd=wd)

[...] <co id="ruledd3-co" linkends="ruledd3"/>

[1/3] t2.txt:  -> out/default/t2.txt
15:21:29 runner system command ->  echo 2 > default/t2.txt
[2/3] t1.txt:  -> out/default/t1.txt
15:21:29 runner system command ->  echo /usr/local > default/t1.txt <co id="ruledd4-co" linkends="ruledd4"/>
[2/3] echo "hey":
18:05:26 runner system command ->  echo "hey"
hey
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.052s)

$ waf
Waf: Entering directory `/tmp/rule/out'
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.007s)

$ waf --jobs=17 --zones=runner
Waf: Entering directory `/tmp/rule/out'
[1/3] t2.txt:  -> out/default/t2.txt
15:23:24 runner system command ->  echo 17 > default/t2.txt <co id="ruledd5-co" linkends="ruledd5"/>
[2/3] echo "hey": <co id="ruledd6-co" linkends="ruledd6"/>
hey
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.014s)
			</programlisting>

			<calloutlist>
				<callout arearefs="ruledd1-co" id="ruledd1">
					<para>The default values for prefix and jobs</para>
				</callout>
				<callout arearefs="ruledd2-co" id="ruledd2">
					<para>The function generated from the string expression will use the <emphasis>PREFIX</emphasis> value</para>
				</callout>
				<callout arearefs="ruledd3-co" id="ruledd3">
					<para>Some output was removed</para>
				</callout>
				<callout arearefs="ruledd4-co" id="ruledd4">
					<para>The expression <emphasis>${PREFIX}</emphasis> was substituted by its value</para>
				</callout>
				<callout arearefs="ruledd5-co" id="ruledd5">
					<para>The target is created whenever the value of a variable changes, even though the string expression has not changed</para>
				</callout>
				<callout arearefs="ruledd6-co" id="ruledd6">
					<para>The variable <emphasis>TEST_VAR</emphasis> changed, so the command was executed again</para>
				</callout>
			</calloutlist>
		</para>
	</section>

	<section id="make_like_order">
		<title>Execution order and dependencies</title>
		<para>
			Although task generators will create the tasks in the relevant order, tasks are executed in parallel and the compilation order may not be the order expected. In the example from the previous section, the target <filename>t2.txt</filename> was processed before the target <filename>t1.txt</filename>. We will now illustrate two important concepts used for the build specification:
			<itemizedlist>
				<listitem>order: sequential constraints between the tasks being executed (here, the commands)</listitem>
				<listitem>dependency: executing a task if another task is executed</listitem>
			</itemizedlist>

			For illustation purposes, let's create a file named <filename>r1.txt</filename> containing the date. It will be updated each time the build is executed. A second file named <filename>r2.txt</filename> will be created from <filename>r1.txt</filename>.

			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
    pass

def build(bld):
	bld(
		name   = 'r1', <co id="rulef1-co" linkends="rulef1"/>
		target = 'r1.txt',
		rule   = '(date &gt; ${TGT}) &amp;&amp; cat ${TGT}', <co id="rulef2-co" linkends="rulef2"/>
		always = True, <co id="rulef3-co" linkends="rulef3"/>
	)

	bld(
		name   = 'r2', <co id="rulef4-co" linkends="rulef4"/>
		target = 'r2.txt',
		rule   = 'cp ${SRC} ${TGT}',
		source = 'r1.txt', <co id="rulef5-co" linkends="rulef5"/>
		after  = 'r1', <co id="rulef6-co" linkends="rulef6"/>
	)
			</programlisting>

			<calloutlist>
				<callout arearefs="rulef1-co" id="rulef1">
					<para>Give the task generator a name, it will create a task class of the same name to execute the command</para>
				</callout>
				<callout arearefs="rulef2-co" id="rulef2">
					<para>Create <filename>r1.txt</filename> with the date</para>
				</callout>
				<callout arearefs="rulef3-co" id="rulef3">
					<para>There is no source file to depend on and the rule never changes. The task is then set to be executed each time the build is started by using the attribute <emphasis>always</emphasis></para>
				</callout>
				<callout arearefs="rulef4-co" id="rulef4">
					<para>If no name is provided, the rule is used as a name for the task class</para>
				</callout>
				<callout arearefs="rulef5-co" id="rulef5">
					<para>Use <filename>r1.txt</filename> as a source for <filename>r2.txt</filename>. Since <filename>r1.txt</filename> was declared before, the dependency will be added automatically (<filename>r2.txt</filename> will be re-created whenever <filename>r1.txt</filename> changes)</para>
				</callout>
				<callout arearefs="rulef6-co" id="rulef6">
					<para>Set the command generating <emphasis>r2.txt</emphasis> to be executed after the command generating <emphasis>r1.txt</emphasis>. The attribute <emphasis>after</emphasis> references task class names, not task generators. Here it will work because rule-based task generator tasks inherit the <emphasis>name</emphasis> attribute</para>
				</callout>
			</calloutlist>

			The execution output will be the following:

			<programlisting language="sh">
$ waf distclean configure build -v
'distclean' finished successfully (0.003s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/rule/out'
[1/2] r1:  -> out/default/r1.txt
16:44:39 runner system command ->  (date &gt; default/r1.txt) &amp;&amp; cat default/r1.txt
dom ene 31 16:44:39 CET 2010
[2/2] r2: out/default/r1.txt -> out/default/r2.txt
16:44:39 runner system command ->  cp default/r1.txt default/r2.txt
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.021s)

$ waf -v
Waf: Entering directory `/tmp/rule/out'
[1/2] r1:  -> out/default/r1.txt
16:44:41 runner system command ->  (date &gt; default/r1.txt) &amp;&amp; cat default/r1.txt
dom ene 31 16:44:41 CET 2010
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.016s)
			</programlisting>

			Although r2 <emphasis>depends</emphasis> on <filename>r1.txt</filename>, r2 was not executed in the second build. As a matter of fact, the signature of the task r1 has not changed, and r1 was only set to be executed each time, regardless of its signature. Since the signature of the <filename>r1.txt</filename> does not change, the signature of r2 will not change either, and <filename>r2.txt</filename> is considered up-to-date.

		</para>

		<para>
			We will now illustrate how to make certain that the outputs reflect the file contents and trigger the rebuild for dependent tasks by enabling the attribute <emphasis>on_results</emphasis>:
			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
    pass

def build(bld):
	bld(
		name   = 'r1',
		target = 'r1.txt',
		rule   = '(date &gt; ${TGT}) &amp;&amp; cat ${TGT}',
		always = True,
		on_results = True,
	)

	bld(
		target = 'r2.txt',
		rule   = 'cp ${SRC} ${TGT}',
		source = 'r1.txt',
		after  = 'r1',
	)
			</programlisting>

			Here <filename>r2.txt</filename> will be re-created each time:

			<programlisting language="sh">
$ waf distclean configure build -v; waf -v
'distclean' finished successfully (0.003s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/rule/out'
[1/2] r1:  -> out/default/r1.txt
16:59:49 runner system command ->  (date &gt; default/r1.txt) &amp;&amp; cat default/r1.txt <co id="ruleff1-co" linkends="ruleff1"/>
dom ene 31 16:59:49 CET 2010 <co id="ruleff2-co" linkends="ruleff2"/>
[2/2] r2: out/default/r1.txt -> out/default/r2.txt
16:59:49 runner system command ->  cp default/r1.txt default/r2.txt
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.020s)

Waf: Entering directory `/tmp/rule/out'
[1/2] r1:  -> out/default/r1.txt
16:59:49 runner system command ->  (date &gt; default/r1.txt) &amp;&amp; cat default/r1.txt
dom ene 31 16:59:49 CET 2010 <co id="ruleff3-co" linkends="ruleff3"/>
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.016s)

$ waf -v
Waf: Entering directory `/tmp/rule/out'
[1/2] r1:  -> out/default/r1.txt
16:59:53 runner system command ->  (date &gt; default/r1.txt) &amp;&amp; cat default/r1.txt
dom ene 31 16:59:53 CET 2010 <co id="ruleff4-co" linkends="ruleff4"/>
[2/2] r2: out/default/r1.txt -> out/default/r2.txt
16:59:53 runner system command ->  cp default/r1.txt default/r2.txt
Waf: Leaving directory `/tmp/rule/out'
'build' finished successfully (0.022s)
			</programlisting>

			<calloutlist>
				<callout arearefs="ruleff1-co" id="ruleff1">
					<para>Start with a clean build, both <filename>r1.txt</filename> and <filename>r2.txt</filename> are created</para>
				</callout>
				<callout arearefs="ruleff2-co" id="ruleff2">
					<para>Notice the date and time</para>
				</callout>
				<callout arearefs="ruleff3-co" id="ruleff3">
					<para>The second build was executed at the same date and time, so <filename>r1.txt</filename> has not changed, therefore </filename>r2.txt</filename> is up to date</para>
				</callout>
				<callout arearefs="ruleff4-co" id="ruleff4">
					<para>The third build is executed at another date and time. Since <filename>r1.txt</filename> has changed, <filename>r2.txt</filename> is created once again</para>
				</callout>
			</calloutlist>

		</para>
	</section>


	<section id="make_like_example">
		<title>A more complicated example</title>
		<para>

			provide an example for c-like compilation + idl, etc

		<warning>
			Using many rule-based task generators <emphasis>may lead to spaghetti code</emphasis> and <emphasis>may impact performance negatively</emphasis>. The next chapters explain how to make more re-usable task generators.
		</warning>
	</section>

</chapter>

