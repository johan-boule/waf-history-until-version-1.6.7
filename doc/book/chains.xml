<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="chains">
	<title>Name and extension-based file processing</title>

	<section id="processing_chains">
		<title>Refactoring repeated rule-based task generators into implicit rules</title>
			<para>
			The explicit rules described in the previous section become limited for processing several files of the same kind. The following code may lead to unmaintainable scripts and to slow builds:
				<programlisting language="python">
def build(bld):
	for x in 'a.lua b.lua c.lua':
		y = x.replace('.lua', '.luac')
		bld(source=x, target=y, rule='${LUAC} -s -o ${TGT} ${SRC}')
		bld.install_files('${LUADIR}', x)
				</programlisting>
			Rather, the rule should be removed from the user script, like this:
				<programlisting language="python">
def build(bld):
	bld(source='a.lua b.lua c.lua')
				</programlisting>
			The equivalent logic may then be provided by using the following code. It may be located in either the same <filename>wscript</filename>, or in a waf tool:
				<programlisting language="python">
import TaskGen
TaskGen.declare_chain(
	name      = 'luac', <co id="chaina1-co" linkends="chaina1"/>
	rule      = '${LUAC} -s -o ${TGT} ${SRC}', <co id="chaina2-co" linkends="chaina2"/>
	shell     = False,
	ext_in    = '.lua', <co id="chaina3-co" linkends="chaina3"/>
	ext_out   = '.luac', <co id="chaina4-co" linkends="chaina4"/>
	reentrant = False, <co id="chaina5-co" linkends="chaina5"/>
	install   = '${LUADIR}', <co id="chaina6-co" linkends="chaina6"/>
)
				</programlisting>

				<calloutlist>
					<callout arearefs="chaina1-co" id="chaina1">
						<para>The name for the corresponding task class to use</para>
					</callout>
					<callout arearefs="chaina2-co" id="chaina2">
						<para>The rule is the same as for any rule-based task generator</para>
					</callout>
					<callout arearefs="chaina3-co" id="chaina3">
						<para>Input file, processed by extension</para>
					</callout>
					<callout arearefs="chaina4-co" id="chaina4">
						<para>Output files extensions separated by spaces. In this case there is only one output file</para>
					</callout>
					<callout arearefs="chaina5-co" id="chaina5">
						<para>The reentrant attribute is used to add the output files as source again, for processing by another implicit rule</para>
					</callout>
					<callout arearefs="chaina6-co" id="chaina6">
						<para>String representing the installation path for the output files, similar to the destination path from <emphasis>bld.install_files</emphasis>. To disable installation, set it to False.</para>
					</callout>
			</calloutlist>
			</para>
	</section>




	<section id="chain_mult">
		<title>Chaining more than one command</title>
		<para>
			Now consider the long chain  <filename>uh.in</filename> &#8594; <filename>uh.a</filename> &#8594; <filename>uh.b</filename> &#8594; <filename>uh.c</filename>. The following implicit rules demonstrate how to generate the files while maintaining a minimal user script:

			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
	pass

def build(bld):
	bld(source='uh.in')

import TaskGen
TaskGen.declare_chain(name='a', rule='cp ${SRC} ${TGT}', ext_in='.in', ext_out='.a',)
TaskGen.declare_chain(name='b', rule='cp ${SRC} ${TGT}', ext_in='.a',  ext_out='.b',)
TaskGen.declare_chain(name='c', rule='cp ${SRC} ${TGT}', ext_in='.b',  ext_out='.c', reentrant = False)
			</programlisting>

			During the build phase, the correct compilation order is computed based on the extensions given:

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.000s)
'configure' finished successfully (0.090s)
Waf: Entering directory `/comp/waf/demos/simple_scenarios/chaining/build'
[1/3] a: uh.in -> build/default/uh.a
[2/3] b: build/default/uh.a -> build/default/uh.b
[3/3] c: build/default/uh.b -> build/default/uh.c
Waf: Leaving directory `/comp/waf/demos/simple_scenarios/chaining/build'
'build' finished successfully (0.034s)
			</programlisting>
		</para>
	</section>



	<section id="chain_scan">
		<title>Scanner methods</title>
		<para>
			Because transformation chains rely on implicit transformations, it may be desirable to hide some files from the list of sources. Or, some dependencies may be produced conditionally and may not be known in advance. A <emphasis>scanner method</emphasis> is a kind of callback used to find additional dependencies just before the target is generated. For illustration purposes, let us start with an empty project containing three files: the <filename>wscript</filename>, <filename>ch.in</filename> and <filename>ch.dep</filename>.

			<programlisting language="sh">
$ cd /tmp/smallproject

$ tree
.
|-- ch.dep
|-- ch.in
`-- wscript
			</programlisting>

				The build will create a copy of <filename>ch.in</filename> called <filename>ch.out</filename>. Also, <filename>ch.out</filename> must be rebuild whenever <filename>ch.dep</filename> changes. This corresponds more or less to the following Makefile:
			<programlisting language="makefile">
ch.out: ch.in ch.dep
	cp ch.in ch.out
			</programlisting>
				The user script should only contain the following code:
			<programlisting language="python">
srcdir='.'
blddir='out'

def configure(conf):
	pass

def build(bld):
	bld(source = 'ch.in')
			</programlisting>

				The code below is independent from the user scripts and may be located in a Waf tool.

			<programlisting language="python">
def scan_meth(task): <co id="chainb1-co" linkends="chainb1"/>
	node = task.inputs[0]
	dep = node.parent.find_resource(node.name.replace('.in', '.dep')) <co id="chainb2-co" linkends="chainb2"/>
	if not dep:
		raise ValueError("Could not find the .dep file for %r" % node)
	return ([dep], []) <co id="chainb3-co" linkends="chainb3"/>

import TaskGen
TaskGen.declare_chain(
	name      = 'copy',
	rule      = 'cp ${SRC} ${TGT}',
	ext_in    = '.in',
	ext_out   = '.out',
	reentrant = False,
	scan      = scan_meth, <co id="chainb4-co" linkends="chainb4"/>
)
			</programlisting>

			<calloutlist>
				<callout arearefs="chainb1-co" id="chainb1">
					<para>The scanner method accepts a task object as input (not a task generator)</para>
				</callout>
				<callout arearefs="chainb2-co" id="chainb2">
					<para>Use node methods to locate the dependency (and raise an error if it cannot be found)</para>
				</callout>
				<callout arearefs="chainb3-co" id="chainb3">
					<para>Scanner methods return a tuple containing two lists. The first list contains the list of node objects to depend on. The second list contains private data such as debugging information. The results are cached between build calls so the contents must be serializable.</para>
				</callout>
				<callout arearefs="chainb4-co" id="chainb4">
					<para>Add the scanner method to chain declaration</para>
				</callout>
			</calloutlist>

			The execution trace will be the following:

			<programlisting languagge="sh">
$ echo 1 > ch.in
$ echo 1 > ch.dep <co id="chainbg1-co" linkends="chainbg1"/>

$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject/out'
[1/1] copy: ch.in -> out/default/ch.out <co id="chainbg2-co" linkends="chainbg2"/>
Waf: Leaving directory `/tmp/smallproject/out'
'build' finished successfully (0.010s)

$ waf
Waf: Entering directory `/tmp/smallproject/out'
Waf: Leaving directory `/tmp/smallproject/out'
'build' finished successfully (0.005s) <co id="chainbg3-co" linkends="chainbg3"/>

$ echo 2 > ch.dep <co id="chainbg4-co" linkends="chainbg4"/>

$ waf
Waf: Entering directory `/tmp/smallproject/out'
[1/1] copy: ch.in -> out/default/ch.out <co id="chainbg5-co" linkends="chainbg5"/>
Waf: Leaving directory `/tmp/smallproject/out'
'build' finished successfully (0.012s)
			</programlisting>

			<calloutlist>
				<callout arearefs="chainbg1-co" id="chainbg1">
					<para>Initialize the file contents of <filename>ch.in</filename> and <filename>ch.dep</filename></para>
				</callout>
				<callout arearefs="chainbg2-co" id="chainbg2">
					<para>Execute a first clean build. The file <filename>ch.out</filename> is produced</para>
				</callout>
				<callout arearefs="chainbg3-co" id="chainbg3">
					<para>The target <filename>ch.out</filename>is up-to-date because nothing has changed</para>
				</callout>
				<callout arearefs="chainbg4-co" id="chainbg4">
					<para>Change the contents of <filename>ch.dep</filename></para>
				</callout>
				<callout arearefs="chainbg5-co" id="chainbg5">
					<para>The dependency has changed, so the target is rebuilt</para>
				</callout>
			</calloutlist>

			Here are a few important points about scanner methods:
			<itemizedlist>
				<listitem>they are executed only when the target is not up-to-date.</listitem>
				<listitem>they may not modify the <emphasis>task</emphasis> object or the contents of the configuration set <emphasis>task.env</emphasis></listitem>
				<listitem>they are executed in a single main thread to avoid concurrency issues</listitem>
				<listitem>the results of the scanner (tuple of two lists) are re-used between build executions (and it is possible to access programatically those results)</listitem>
				<listitem>the make-like rules also accept a <emphasis>scan</emphasis> argument (scanner methods are bound to the task rather than the task generators)</listitem>
				<listitem>they are used by Waf internally for c/c++ support, to add dependencies dynamically on the header files (.c &#8594; .h)</listitem>
			</itemizedlist>
		</para>
	</section>

		<!-- The chaining declaration is usually located in a separate python file for re-usability. In practice, chains are useful for simple cases such as processing statistical data and generating simple documents. When more control over the declaration and the output files is needed, it is more convenient to use the techniques described in the next sections. -->



	<section id="chain_extension">
		<title>Extension callbacks</title>
			<para>
				In the chain declaration from the previous sections, the attribute <emphasis>reentrant</emphasis> was described to control if the generated files are to be processed or not. There are cases however where one of the two generated files must be declared (because it will be used as a dependency) but where it cannot be considered as a source file in itself (like a header in c/c++). Now consider the following two chains (uh.in &#8594; uh.a1 + uh.a2) and (uh.a1 &#8594; uh.b) in the following example:

				<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
	pass

def build(bld):
	obj = bld(source='uh.in')

import TaskGen
TaskGen.declare_chain(
	name      = 'a',
	action    = 'touch ${SRC} ${TGT}',
	ext_in    = '.in',
	ext_out   = ['.a1', '.a2'],
	reentrant = True,
)

TaskGen.declare_chain(
	name      = 'b',
	action    = 'cp ${SRC} ${TGT}',
	ext_in    = '.a1',
	ext_out   = '.b',
	reentrant = 0,
)
				</programlisting>

				The following error message will be produced:

				<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject'
Waf: Leaving directory `/tmp/smallproject'
Cannot guess how to process bld:///tmp/smallproject/uh.a2 (got mappings ['.a1', '.in'] in &lt;class 'TaskGen.task_gen'&gt;) -> try conf.check_tool(..)?
				</programlisting>

				The error message indicates that there is no way to process <emphasis>uh.a2</emphasis>. Only files of extension <emphasis>.a1</emphasis> or <emphasis>.in</emphasis> can be processed. Internally, extension names are bound to callback methods. The error is raised because no such method could be found, and here is how to register an extension callback globally:

				<programlisting language="python">
@TaskGen.extension('.a2')
def foo(*k, **kw):
	pass
				</programlisting>

				To register an extension callback locally, a reference to the task generator object must be kept:
				<programlisting language="python">
def build(bld):
	obj = bld(source='uh.in')
	def callback(*k, **kw):
		pass
	obj.mappings['.a2'] = callback
				</programlisting>
		</para>

		<para>
			The exact method signature and typical usage for the extension callbacks is the following:

			<programlisting language="python">
import TaskGen
@TaskGen.extension(ext1<co id="chainc0-co" linkends="chainc0"/>, ext2)
def my_callback(task_gen_object<co id="chainc1-co" linkends="chainc1"/>, node<co id="chainc2-co" linkends="chainc2"/>):
	task_gen_object.create_task(task_name<co id="chainc3-co" linkends="chainc3"/> , node<co id="chainc4-co" linkends="chainc4"/> , output_nodes<co id="chainc5-co" linkends="chainc6"/>)
			</programlisting>

			<calloutlist>
				<callout arearefs="chainc0-co" id="chainc0">
					<para>Comma-separated list of extensions (string)</para>
				</callout>
				<callout arearefs="chainc1-co" id="chainc1">
					<para>Task generator instance holding the data</para>
				</callout>
				<callout arearefs="chainc2-co" id="chainc2">
					<para>Instance of Node, representing a file (either source or build)</para>
				</callout>
				<callout arearefs="chainc3-co" id="chainc3">
					<para>The first argument to create a task is the name of the task class</para>
				</callout>
				<callout arearefs="chainc4-co" id="chainc4">
					<para>The second argument is the input node (or a list of nodes for several inputs)</para>
				</callout>
				<callout arearefs="chainc5-co" id="chainc5">
					<para>The last parameter is the output node (or a list of nodes for several outputs)</para>
				</callout>
			</calloutlist>

			The creation of new task classes will be described in the next section.
		</para>
	</section>




	<section id="processing_extensions">
		<title>Task class declaration</title>
			<para>
				Waf tasks are instances of the class Task.TaskBase. Yet, the base class contains the real minimum, and the immediate subclass <emphasis>Task.Task</emphasis>is usually chosen in user scripts. We will now start over with a simple project containing only one project <filename>wscript</filename> file and and example file named <filename>ah.in</filename>. A task class will be added.

				<programlisting language="python">
srcdir = '.'
blddir = 'out'

def configure(conf):
	pass

def build(bld):
	bld(source='uh.in')

import Task, TaskGen

@TaskGen.extension('.in')
def process(self, node):
	tsk = self.create_task('abcd') <co id="chaind1-co" linkends="chaind1"/>
	print(tsk.__class__)

class abcd(Task.Task): <co id="chaind2-co" linkends="chaind2"/>
	def run(self): <co id="chaind3-co" linkends="chaind3"/>
		print('executing...')
		return 0 <co id="chaind4-co" linkends="chaind4"/>
				</programlisting>

			<calloutlist>
				<callout arearefs="chaind1-co" id="chaind1">
					<para>Create a new instance of <emphasis>abcd</emphasis>. The method <emphasis>create_task</emphasis> is a shortcut to make certain the task will keep a reference on its task generator.</para>
				</callout>
				<callout arearefs="chaind2-co" id="chaind2">
					<para>Inherit the class Task located in the module Task.py</para>
				</callout>
				<callout arearefs="chaind3-co" id="chaind3">
					<para>The method run is called when the task is executed</para>
				</callout>
				<callout arearefs="chaind4-co" id="chaind4">
					<para>The task return status must be an integer, which is zero to indicate success. The tasks that have failed will be executed on subsequent builds</para>
				</callout>
			</calloutlist>

			The output of the build execution will be the following:

			<programlisting language="sh">
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/simpleproject/out'
&lt;class 'wscript_main.abcd'&gt;
[1/1] abcd:
executing...
Waf: Leaving directory `/tmp/simpleproject/out'
'build' finished successfully (0.005s)
			</programlisting>

			Although it is possible to write down task classes in plain python, two functions (factories) are provided to simplify the work, for example:

			<programlisting language="python">
Task.simple_task_type <co id="chaine1-co" linkends="chaine1"/>('xsubpp'<co id="chaine2-co" linkends="chaine2"/>, rule='${PERL} ${XSUBPP} ${SRC} > ${TGT}'<co id="chaine3-co" linkends="chaine3"/>, color='BLUE'<co id="chaine4-co" linkends="chaine4"/>, before='cc'<co id="chaine5-co" linkends="chaine5"/>)

def build_it(task):
	return 0

Task.task_type_from_func<co id="chaine6-co" linkends="chaine6"/>('sometask'<co id="chaine7-co" linkends="chaine7"/>, func=build_it<co id="chaine8-co" linkends="chaine8"/>, vars=['SRT'], color='RED', ext_in='.in', ext_out='.out'<co id="chaine9-co" linkends="chaine9"/>)
			</programlisting>

			<calloutlist>
				<callout arearefs="chaine1-co" id="chaine1">
					<para>Create a new task class executing a rule string</para>
				</callout>
				<callout arearefs="chaine2-co" id="chaine2">
					<para>Task class name</para>
				</callout>
				<callout arearefs="chaine3-co" id="chaine3">
					<para>Rule to execute during the build</para>
				</callout>
				<callout arearefs="chaine4-co" id="chaine4">
					<para>Color for the output during the execution</para>
				</callout>
				<callout arearefs="chaine5-co" id="chaine5">
					<para>Execute the task instance before any instance of task classes named <emphasis>cc</emphasis>. The opposite of <emphasis>before</emphasis> is <emphasis>after</emphasis></para>
				</callout>
				<callout arearefs="chaine6-co" id="chaine6">
					<para>Create a new task class from a custom python function. The <emphasis>vars</emphasis> attribute represents additional configuration set variables to use as dependencies</para>
				</callout>
				<callout arearefs="chaine7-co" id="chaine7">
					<para>Task class name</para>
				</callout>
				<callout arearefs="chaine8-co" id="chaine8">
					<para>Function to use</para>
				</callout>
				<callout arearefs="chaine9-co" id="chaine9">
					<para>In this context, the extension names are meant to be used for computing the execution order with other tasks, without naming the other task classes explicitely</para>
				</callout>
			</calloutlist>

			Note that most attributes are common between the two function factories. More usage examples may be found in most Waf tools.
		</para>
	</section>



	<section id="chain_source">
		<title>Source attribute processing</title>
		<para>
			The first step in processing the source file attribute is to convert all file names into Nodes. Special methods may be mapped to intercept names by the exact file name entry (no extension). The Node objects are then added to the task generator attribute <emphasis>allnodes</emphasis>.
		</para>
		<para>
			The list of nodes is then consumed by regular extension mappings. Extension methods may re-inject the output nodes for further processing by appending them to the the attribute <emphasis>allnodes</emphasis> (hence the name re-entrant provided in declare_chain).

			<graphic format="png" fileref="source.png" align="center"/>
		</para>
	</section>


</chapter>

