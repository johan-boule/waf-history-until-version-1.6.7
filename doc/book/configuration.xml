<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter id="configuration">
	<title>The configuration system</title>

	<section id="config_data">
		<title>Using configuration data</title>
		<para>
			Configuration data is held by instances of the class <emphasis>Environment</emphasis>. The class acts as a wrapper around Python dicts to handle serialization (in human-editable files) and copy-on-write efficiently. Instances of that class are used extensively within waf, and the instances are usually named 'env'. Here is how configuration data is usually stored:

			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
    conf.env['CXXFLAGS'] = ['-O2'] # key-based access
    conf.env.store('test.txt')
    conf.env.TEST        = 'test'  # attribute-based access

    new = conf.env.__class__()
    new.load('test.txt')

    print new
    print ""
    print conf.env
			</programlisting>

			The execution will result in the following output:

			<programlisting language="sh">
$ waf configure
'CXXFLAGS' ['-O2']
'PREFIX' '/usr/local'

'CXXFLAGS' ['-O2']
'PREFIX' '/usr/local'
'TEST' 'test'

$ cat test.txt
CXXFLAGS = ['-O2']
PREFIX = '/usr/local'

$ cat build/c4che/default.cache.py
CXXFLAGS = ['-O2']
PREFIX = '/usr/local'
TEST = 'test'
			</programlisting>

			The default configuration is stored to the cache file named <emphasis>default.cache.py</emphasis>. The configuration data will always contain the default variable PREFIX, which is used to indicate the default directory in which to install something (in case there is something to install). The cache file is written in pseudo-python, and may be edited manually if necessary.
		</para>

		<para>
			Although the conf.env object is similar to a Python dict, a few routines are present to ease value access:
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def configure(conf):
	conf.env.append_value('CXXFLAGS', ['-O2', '-g'])
	conf.env.CCFLAGS = ['-g']
	conf.env.append_unique('CCFLAGS', ['-g', '-O2'])
	conf.env.prepend_value('CCFLAGS', ['-O3'])
	print(conf.env)

	import Utils
	s = Utils.subst_vars('${CCFLAGS}', conf.env)
	print(s)

			</programlisting>

			Upon execution, the output will be the following

			<programlisting language="sh">
$ waf configure
'CCFLAGS' ['-O3', '-g', '-O2']
'CXXFLAGS' ['-O2', '-g']
'PREFIX' '/usr/local'
-O3 -g -O2
			</programlisting>
		</para>
	</section>


	<section id="config_data_sharing">
		<title>Using configuration data during the build</title>
		<para>
			By splitting the configuration from the build step, it is possible to stop and look at the configuration data (build/c4che/default.cache.py). The data used during the build should use the command-line options as little as possible. To achieve this, a pattern similar to the following is usually applied:
			<programlisting language="python">
srcdir = '.'
blddir = 'build'

def set_options(ctx):
	ctx.add_option('--foo', action='store', default=False, help='Silly test')

def configure(ctx):
	import Options
	ctx.env.FOO = Options.options.foo
	ctx.find_program('touch', var='TOUCH', mandatory=True) # a configuration helper

def build(ctx):
	print(ctx.env.TOUCH)
	print(ctx.env.FOO)
			</programlisting>

			The default configuration data is automatically loaded during the build. Upon execution, the output will be similar to the following:

			<programlisting language="sh">
$ waf distclean configure build --foo=abcd
'distclean' finished successfully (0.002s)
Checking for program touch               : ok /usr/bin/touch
'configure' finished successfully (0.001s)
Waf: Entering directory `/comp/waf/demos/simple_scenarios/folders/build'
/usr/bin/touch
abcd
Waf: Leaving directory `/comp/waf/demos/simple_scenarios/folders/build'
'build' finished successfully (0.003s)
			</programlisting>

		</para>
	</section>


	<section id="config_helper_execution">
		<title>Understanding configuration helpers</title>
		<para>
			Configuration helpers are methods provided by the conf object to help finding parameters, for example the method <emphasis>conf.find_program</emphasis>
			<programlisting language="python">
def configure(conf):
	conf.find_program('test')
			</programlisting>
			When a test fails, the exception <emphasis>Configure.ConfigurationException</emphasis> is raised.
		</para>

		<para>
			When calling the configuration from a tool, for example:
			<programlisting language="python">
def configure(conf):
	conf.check_tool('g++')
			</programlisting>
			several different configuration helpers may be called: the first one for finding the compiler and the others for finding compiler flags. In some cases, it is interesting to disable some tests (unnecessary, time consuming, etc), to insert new tests, or to modify the existing tests. The <emphasis>check_tool</emphasis> method has a parameter for passing the list of checks to perform:
			<programlisting language="python">
def configure(conf):
	conf.check_tool('g++', funs="find_gxx find_cpp find_ar gxx_common_flags")
			</programlisting>
			If no check is performed, the configuration helpers are still attached to the conf object, and may be used later:
			<programlisting language="python">
def configure(conf):
	conf.check_tool('g++', funs=[])
	conf.find_gxx()
			</programlisting>
			To ease the creation of projects split into modules, conf.check_tool will not load the tools twice for the same environment and the same parameters.
		</para>

		<para>
			An error handler attached to the conf object is used for catching the Configuration exceptions and processing the errors. Here is how to replace the default configuration error handler by a custom method which may modify the list of tests, stop the evaluation, or re-raise the exception:
			<programlisting language="python">
import Configure, Constants
@conf
def error_handler(fun, exc):
	print('exception %r' % exc)
	# other optionals return values: Constants.CONTINUE or anything else to re-raise the exception
	return Constants.BREAK
			</programlisting>
			The following diagram illustrates the test execution loop performed from conf.check_tool
			<graphic format="png" fileref="conftest.png" align="center"/>
		</para>
	</section>

	<section id="adding_config_helpers">
		<title>Adding new configuration helpers</title>
		<para>
			The configuration tests specific for the different languages belong to the different Waf tools representing the languages supported. For example, The configuration tests for the C language are located in the tool <filename>config_c.py</filename>.
			To enable this, decorators are used to attach new configuration tests dynamically, for example:
			<programlisting language="python">
from Configure import conf

@conf
def get_define(self, define):
	"get the value of a previously stored define"
	try: return self.env.defines[define]
	except KeyError: return None
			</programlisting>
			Then the new configuration test may be used easily in wscript:
			<programlisting language="python">
def configure(conf):
	print(conf.get_define('DEBUG'))
			</programlisting>
		</para>
	</section>
</chapter>

