== C and C++ projects

=== Common script for C/C++ applications

The c/c++ builds consist in transforming source files into object files, and to assemble the object files at the end. In theory a single programming language should be sufficient for writing any application, but in practice this does not scale:

. Applications may be divided in dynamic or static libraries
. Additional files may enter in the link step (libraries, object files)
. Source files may be generated by other compilers
. Differnt platforms require different processing rules (manifest files on windows, etc)

The construction of c/c++ applications can be quite complicated, and several measures must be taken to ensure coherent interaction with new compilation rules. The canonical code for a task generator building a c/c++ application is the following:

[source,python]
---------------
top = '.'
out = 'build'

def set_options(conf):
	conf.tool_options('compiler_cc')

def configure(conf):
	conf.check_tool('compiler_cc') <1>

def build(bld):
	t = bld(
		features     = ['cc', 'cprogram'], <2>
		source       = 'main.c', <3>
		target       = 'appname', <4>
		install_path = '${SOME_PATH}/bin', <5>
		vnum         = '1.2.3', <6>
		includes     = ['.'], <7>
		defines      = ['LINUX=1', 'BIDULE'], <8>
		ccflags      = ['-O2', '-Wall'], <9>
		lib          = ['m'], <10>
		libpath      = ['/usr/lib'],
		linkflags    = ['-g'],
	)
	t.rpath          = ['/usr/lib']
---------------

<1> Load the c/c++ support routines (such as the features below) and try to find a suitable compiler for the build. The support for c++ is loaded by 'compiler_cxx'
<2> Task generator declaration; each element in the list represent a feature; it is possible to add several languages at once ('ocaml and c++' for example), but the one of 'cstaticlib, cshlib or cprogram' must be chosen.
<3> List of source, it may be either a python list, or a string containing the file names separated with spaces. This list may contain file names of different extensions to make hybrid applications.
<4> Target name, it is concerted to the name of the binary 'name.so' or 'name.exe' depending on the platform and the features.
<5> Installation directory, this is where to install the library or program produced. The '$\{}' expression is a reference to a variable to be extracted from 'tgen.env'. By default it is set to '$\{PREFIX}/bin' for programs and '$\{PREFIX}/lib' for libraries. To disable the installation, set it to 'None'.
<6> Version number for shared libraries. It is not used for programs or static libraries.
<7> List of include paths, it may be either a python list, or a string containing the paths separated by spaces. The paths are used for both the command-line and for finding the implicit dependencies (headers). In general, include paths must be relative to the wscript file and given explicitly.
<8> Command-line defines: list of defines to add to the command-line with the '-D' prefix. To reduce the size of the command-line, it is possible to use a configuration header, see the following section for more details.
<9> Command-line compilation flags, for the c++ language the attribute is called 'cxxflags'
<10> Shared libraries may be given directly (use 'staticlib' and 'staticlibpath' for static libraries)

Additional pararameters may be added from a task generator reference. The next section describes a technique to gather the conditions into the configuration section.


=== Library interaction (uselib)

==== Local libraries

To link a library against another one created in the same Waf project, the attribute 'uselib_local' may be used. The include paths, the link path and the library name are automatically exported, and the dependent binary is recompiled when the library changes:

[source,python]
---------------
def build(bld):
	staticlib = bld(
		features       = 'cc cstaticlib', <1>
		source         = 'test_staticlib.c',
		target         = 'teststaticlib',
		export_incdirs = '.') <2>

	main = bld(
		features       = 'cc cprogram', <3>
		source         = 'main.c',
		target         = 'test_c_program',
		includes       = '.',
		uselib_local   = 'teststaticlib') <4>
---------------

<1> A static library
<2> Include paths to export for use with uselib_local (include paths are not added automatically). These folders are taken relatively to the current target.
<3> A program using the static library declared previously
<4> A list of references to existing libraries declared in the project (either a python list or a string containing the names space-separated)

The library does not need to actually declare a target. Header-only libraries may be created to add common include paths to several targets:

[source,python]
---------------
def build(bld):
	bld(
		uselib         = '',
		export_incdirs = '.',
		name           = 'common_includes')

	main = bld(
		features       = 'cc cprogram',
		source         = 'main.c',
		target         = 'some_app',
		uselib_local   = 'common_includes')
---------------

NOTE: Include paths are only propagated when 'export_incdirs' is provided. The include paths are relative to the path of the task generator that declared them.

NOTE: The local shared libraries and the uselib variables are propagated transitively, but the static libraries are not.

==== System libraries

To link an application against various 'system libraries', several compilation flags and link flags must be given at once. To reduce the maintenance, a system called 'uselib' can be used to give all the flags at the same time:

[source,python]
---------------
def configure(conf):
	conf.env.CPPPATH_TEST = ['/usr/include'] <1>

	if sys.platform != win32: <2>
		conf.env.CCDEFINES_TEST = ['TEST']
		conf.env.CCFLAGS_TEST   = ['-O0'] <3>
		conf.env.LIB_TEST       = 'test'
		conf.env.LIBPATH_TEST   = ['/usr/lib'] <4>
		conf.env.LINKFLAGS_TEST = ['-g']

def build(bld):
	mylib = bld(
		features = 'cc cstaticlib',
		source   = 'test_staticlib.c',
		target   = 'teststaticlib',
		uselib   = 'TEST') <5>

	if mylib.env.CC_NAME == 'gcc':
		mylib.cxxflags = ['-O2'] <6>
---------------

<1> For portability reasons, it is recommended to use CPPPATH instead of giving flags of the form -I/include. Note that the CPPPATH use used by both c and c++
<2> Variables may be left undefined in platform-specific settings, yet the build scripts will remain identical.
<3> Declare a few variables during the configuration, the variables follow the convention VAR_NAME
<4> Values should be declared as lists excepts for LIB and STATICLIB
<5> Add all the VAR_NAME corresponding to the uselib NAME, which is 'TEST' in this example
<6> 'Model to avoid': setting the flags and checking for the configuration must be performed in the configuration section

The variables used for c/c++ are the following:

.Uselib variables and task generator attributes for c/c++
[options="header"]
|=================
|Uselib variable | Attribute | Usage
|LIB      |lib      | list of sharedlibrary names to use, without prefix or extension
|STATICLIB|staticlib| list of static library names to use, without prefix or extension
|LIBPATH  |libpath  | list of search path for shared and static libraries
|RPATH    |rpath    | list of paths to hard-code into the binary during linking time
|CXXFLAGS |cxxflags | flags to use during the compilation of c++ files
|CCFLAGS  |ccflags  | flags to use during the compilation of c files
|CPPPATH  |includes | include paths
|CXXDEPS  |         | a variable to trigger c++ file recompilations when it changes
|CCDEPS   |         | same as above, for c
|FRAMEWORK|framework| list of frameworks to use, requires the waf tool 'osx'
|FRAMEWORKPATH|frameworkpath| list of framework paths to use, requires the waf tool 'osx'
|=================


The variables may be left empty for later use, and will not cause errors. During the development, the configuration cache files (for example, default.cache.py) may be modified from a text editor to try different configurations without forcing a whole project reconfiguration. The files affected will be rebuilt however.

=== Specific settings by object files

In some cases, it is necessary to re-use object files generated by another task generator to avoid recompilations. This is similar to copy-pasting code, so it is discouraged in general. Another use for this is to enable some compilation flags for specific files. The attribute "add_objects" can be used, like in the following example:

[source,python]
---------------
def build(bld):
	some_objects = bld(
		features       = 'cc', <1>
		source         = 'test.c',
		ccflags        = '-O3',
		target         = 'my_objs')

	main = bld(
		features       = 'cc cprogram',
		source         = 'main.c',
		ccflags        = '-O2', <2>
		target         = 'test_c_program',
		add_objects    = 'my_objs') <3>
---------------

<1> Files will be compiled in c mode, but no program or library will be produced
<2> Different compilation flags may be used
<3> The objects will be added automatically in the link stage

=== Using configuration headers

Adding lots of command-line define values increases the size of the command-line and conceals the useful information (differences). Some projects use headers which are generated during the configuration, they are not modified during the build and they are not installed or redistributed. This system is useful for huge projects, and has been made popular by autoconf-based projects.

Writing configuration headers can be performed using the following methods:

[source,python]
---------------
def configure(conf):
	conf.define('NOLIBF', 1)
	conf.undefine('NOLIBF')
	conf.define('LIBF', 1)
	conf.define('LIBF_VERSION', '1.0.2')
	conf.write_config_header('config.h')
---------------

The code snipped will produce the following 'config.h' in the build directory:

[source,shishell]
---------------
build/
|-- c4che
|   |-- build.config.py
|   `-- default.cache.py
|-- config.log
`-- default
    `-- config.h
---------------

The contents of the config.h for this example are

[source,c]
---------------
/* Configuration header created by Waf - do not edit */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

/* #undef NOLIBF */
#define LIBF 1
#define LIBF_VERSION "1.0.2"

#endif /* _CONFIG_H_WAF */
---------------



=== The include system

==== The Waf preprocessor

Include paths are used by the c/c++ compilers for finding the headers. When one header changes, the files are recompiled automatically. Includes must be given in the following form:

[source,python]
---------------
def build(bld):
	bld(
		features = 'cxx cprogram',
		source   = 'main.cpp',
		target   = 'test',
		includes = '. .. ../../')
---------------

Local folders are given relative to the folder of the current script. The equivalent build directory folder is then added automatically for headers or source files produced in the build directory.

Waf uses a preprocessor written in Python for adding the dependencies on the headers. A simple parser looking at #include statements would miss constructs such as:

[source,c]
---------------
#define mymacro "foo.h"
#include mymacro
---------------

Using the compiler for finding the dependencies would not work for applications requiring file preprocessing such as Qt. For Qt, special include files having the '.moc' extension must be detected by the build system and produced ahead of time. The c compiler could not parse such files.

[source,c]
---------------
#include "foo.moc"
---------------

Using the Waf preprocessor also contributes to make the scripts strongly compiler-independent.

==== Portability recommandations

By default, the preprocessing does not climb to system headers. This may lead to missed depdendencies in the cases similar to the following:

[source,c]
---------------
#if SOMEMACRO
	/* an include in the project */
	#include "foo.h"
#endif
---------------

To write portable code and to ease debugging, it is strongly recommended to put all the conditions used in the project into a 'config.h' file.

[source,python]
---------------
def configure(conf):
	conf.check(
		fragment='int main() { return 0; }\n',
		define_name='FOO',
		mandatory=1)
	conf.write_config_header('config.h')
---------------

Although it is discouraged, it is possible to enable the preprocessor to look into system headers by using the following code:

[source,python]
---------------
import preproc
preproc.go_absolute = True
---------------

==== Debugging dependencies

The Waf preprocessor contains a specific debugging zone:

[source,shishell]
---------------
$ waf --zones=preproc
---------------

To display the dependencies obtained or missed, use the following:

[source,shishell]
---------------
$ waf --zones=deps
---------------

The dependency computation is performed only when the files are not up-to-date, so these commands will display something only when there is a file to compile.



=== Configuration helpers

The method 'check' is used to detect parameters using a small build project. The main parameters are the following

. msg: title of the test to execute
. okmsg: message to display when the test succeeds
. errmsg: message to display when the test fails
. mandatory: when true, raise a configuration exception if the test fails
. env: environment to use for the build (conf.env is used by default)
. compile_mode: 'cc' or 'cxx'
. define_name: add a define for the configuration header when the test succeeds (in most cases it is calculated automatically)

Besides the main parameters, the attributes from c/c++ task generators may be used. Here is a concrete example:

[source,python]
---------------
def configure(conf):

	conf.check(header_name='time.h', compile_mode='cc') <1>
	conf.check_cc(function_name='printf', header_name="stdio.h", mandatory=1) <2>
	conf.check_cc(fragment='int main() {2+2==4;}\n', define_name="boobah") <3>
	conf.check_cc(lib='m', ccflags='-Wall', defines=['var=foo', 'x=y'], uselib_store='M') <4>
	conf.check_cxx(lib='linux', uselib='M', cxxflags='-O2') <5>

	conf.check_cc(fragment='''
			#include <stdio.h>
			int main() { printf("4"); return 0; } ''',
		define_name="booeah",
		execute="1",
		define_ret="1",
		msg="Checking for something") <6>

	conf.write_config_header('config.h') <7>
---------------

<1> Try to compile a program using the configuration header time.h, if present on the system, if the test is successful, the define HAVE_TIME_H will be added
<2> Try to compile a program with the function printf, adding the header stdio.h (the header_name may be a list of additional headers). The parameter mandatory will make the test raise an exception if it fails. Note that convenience methods 'check_cc' and 'check_cxx' only define the compilation mode 'compile_mode'
<3> Try to compile a piece of code, and if the test is successful, define the name boobah
<4> Modifications made to the task generator environment are not stored. When the test is successful and when the attribute uselib_store is provided, the names lib, cflags and defines will be converted into uselib variables LIB_M, CCFLAGS_M and DEFINE_M and the flag values are added to the configuration environment.
<5> Try to compile a simple c program against a library called 'linux', and reuse the previous parameters for libm (uselib)
<6> Execute a simple program, collect the output, and put it in a define when successful
<7> After all the tests are executed, write a configuration header in the build directory (optional). The configuration header is used to limit the size of the command-line.

Here is an example of a 'config.h' produced with the previous test code:

[source,c]
---------------
/* Configuration header created by Waf - do not edit */
#ifndef _CONFIG_H_WAF
#define _CONFIG_H_WAF

#define HAVE_PRINTF 1
#define HAVE_TIME_H 1
#define boobah 1
#define booeah "4"

#endif /* _CONFIG_H_WAF */
---------------

The file `default.cache.py` will contain the following variables:

[source,python]
---------------
CCDEFINES_M = ['var=foo', 'x=y']
CXXDEFINES_M = ['var=foo', 'x=y']
CXXFLAGS_M = ['-Wall']
CCFLAGS_M = ['-Wall']
LIB_M = ['m']
boobah = 1
booeah = '4'
defines = {'booeah': '"4"', 'boobah': 1, 'HAVE_TIME_H': 1, 'HAVE_PRINTF': 1}
dep_files = ['config.h']
waf_config_files = ['/compilation/waf/demos/adv/build/default/config.h']
---------------

NOTE: The methods 'conf.check' all use task generators internally. This means that the attributes 'includes', 'defines', 'cxxflags' may be used (not all shown here).

NOTE: The attribute 'compile_mode' may also contain user-defined task generator features.

=== Pkg-config

Instead of duplicating the configuration detection in all dependent projects, configuration files may be written when libraries are installed. To ease the interaction with build systems based on Make (cannot query databases or apis), small applications have been created for reading the cache files and to interpret the parameters (with names traditionally ending in '-config'): http://pkg-config.freedesktop.org/wiki/[pkg-config], wx-config, sdl-config, etc.

Waf provides the method 'check_cfg' for querying config parameters:

[source,python]
---------------
def configure(conf):
	conf.check_cfg(atleast_pkgconfig_version='0.0.0') <1>
	conf.check_cfg(package='pango', atleast_version='0.0.0') <2>
	conf.check_cfg(package='pango', exact_version='0.21')
	conf.check_cfg(package='pango', max_version='9.0.0')
	conf.check_cfg(package='pango', args='--cflags --libs') <3>
	pango_version = conf.check_cfg(modversion='pango') <4>
	conf.check_cfg(path='sdl-config', args='--cflags --libs', package='', uselib_store='SDL') <5>
	conf.check_cfg(path='mpicc', args='--showme:compile --showme:link',
		package='', uselib_store='OPEN_MPI') <6>
---------------

<1> Check for the pkg-config version
<2> Check for a module version
<3> Obtain the flags for a package and assign them to the uselib PANGO (calculated automatically from the package name, can be overridden with the attribute "uselib_store='MYPANGO'")
<4> Retrieve the module version for a package. The returned object is a string containing the version number or an empty string in case of any errors. If there were no errors, 'PANGO_VERSION' is defined, can be overridden with the attribute "uselib_store='MYPANGO'".
<5> Obtain the flags for a different configuration program (sdl-config). The example is applicable for other configuration programs such as wx-config, pcre-config, etc
<6> The method check_cfg may be used for other '-config' applications too

Due to the amount of flags, the lack of standards between config applications, and to the output changing for different operating systems (-I for gcc, /I for msvc), the output of pkg-config is parsed, and the variables for the corresponding uselib are set in a go. The function 'parse_flags(line, uselib, env)' in the Waf module config_c.py performs the output analysis.

