== Build context and nodes

The following chapter serves as a quick description of the node system as used in waf 1.5.

=== Node types

The nodes are use for representing the filesystem. There are only 3 node types:

. Source nodes represent source files present on the file system. The signature for a source node is the hash of the file contents.
. Build nodes represent files created under the build directory. While build nodes are not bound to the build variant, the build nodes may have several signatures corresponding to the variants in which the files have been created (the signature is the signature of the task that created the file).
. Directory nodes represent the folders from the project directory. During the build phase, the folders corresponding to the source directory are automatically created for each variant into the build directory. Directory nodes have no associated signatures.

For example, for a project located in /tmp/nodes, using the rule 'source.in' -> 'target.out' with three variants 'default', 'debug' and 'release', the filesystem contents will be:

[source,shishell]
---------------
$ tree
.
|-- build
|   |-- c4che
|   |   |-- build.config.py
|   |   |-- debug.cache.py
|   |   |-- default.cache.py
|   |   `-- release.cache.py
|   |-- config.log
|   |-- debug
|   |   `-- target.out
|   |-- default
|   `-- release
|       `-- target.out
|-- source.in
`-- wscript
---------------

Yet, there are only three nodes associated with the project:

[source,shishell]
---------------
dir:///tmp/nodes <1>
src:///tmp/nodes/source.in <2>
bld:///tmp/nodes/target.out <3>
---------------

<1> The project directory. Directory nodes are represented by 'dir://'
<2> The source node for 'source.in'. Source nodes are represented by 'src://'
<3> The build node for the outputs 'target.out'. Build nodes are represented by 'bld://'

There can be only one node of a name for a given directory node. Because of this restriction, it is not possible to copy a file from the source directory to the corresponding build directory (for a given variant):

[source,python]
---------------
bld(
	rule   = 'cp ${SRC} ${TGT}',
	source = 'test.png',
	target = 'test.png') <1>

bld(
	rule   = 'cp ${SRC} ${SRC[0].parent.abspath(env)}/${SRC[0].name}',
	source = 'test.png') <2>
---------------

<1> Forbidden
<2> Discouraged, but Ok.

=== Build context creation and access

For testing purposes, a function created from a build context instance could create another build context. Therefore, the build context is not a singleton. The task signatures and the dependent nodes are then bound to the build context instance that created them.

Here is how to create a build context inside another build context:

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
	pass

def build(ctx):

	def do_it():

		import Environment, Build
		bld = Build.BuildContext() <1>
		bld.load_dirs('/tmp', '/tmp/build') <2>
		env = Environment.Environment()
		bld.all_envs['default'] = env <3>
		bld.init_variants() <4>

		bld( <5>
			rule='echo hi from the nested context!',
			always=True)
		bld.compile() <6>

	ctx( <7>
		rule='echo hi from the main buildcontext',
		always=True)

	do_it()
---------------

<1> Create a new build context.
<2> Set the project and the output folders
<3> Set the configuration data set
<4> Create the folder(s) '/tmp/build/variant' and initialize the build node signature cache
<5> Declare a task generator
<6> Execute a build
<7> Create a task generator for the main build context
<8> Call the function 'do_it' to create immediately a new build context and to execute it

The execution trace is the following:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.002s)
Waf: Entering directory `/tmp/nested/build'
[1/1] echo hi from the nested context!: <1>
hi from the nested context!
[1/1] echo hi from the main buildcontext:
hi from the main buildcontext <2>
Waf: Leaving directory `/tmp/nested/build'
'build' finished successfully (0.018s)
---------------

<1> The nested build is executed immediately
<2> Trace from the normal build

The task generators, the tasks, and the node objects are all bound to a particular build context. Here is how to access the different objects:

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
    pass

def build(bld):
    print('root %r' % type(bld.root)) <1>
    print('path %r' % bld.path) <2>
    print('path %r' % bld.srcnode) <3>
    print('bld %r' % bld.path.__class__.bld)

    def fun(task):
        print("task %r %r -> %r" % (
            type(task),
            task.generator, <5>
            task.generator.bld) <6>
        )

    obj = bld(rule=fun, always=True, name='foo')
    print('tgen %r -> %r' % (type(obj), obj.bld)) <7>
    print(bld.name_to_obj('foo', bld.env)) <8>
---------------

<1> Filesystem root
<2> Current path
<3> Project directory (top-level)
<4> Access the build context instance from the class
<5> Get a reference to the task generator that created the task instance
<6> Get the build context corresponding to the task instance
<7> The attribute 'bld' of a task generator is the build context
<8> Obtain a task generator from the build context

The execution trace will be the following:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.002s)
Waf: Entering directory `/tmp/nested/build'
root <class 'Node.Nodu'>
path dir:///tmp/nested
src  dir:///tmp/nested
bld <Build.BuildContext object at 0x7f5472764490>
tgen <class 'TaskGen.task_gen'> -> <Build.BuildContext object at 0x7f5472764490>
<task_gen 'foo' of type task_gen defined in dir:///tmp/nested>
[1/1] 1:
task <class 'Task.1'> <TaskGen.task_gen object at 0x7f547277b610>
     -> <Build.BuildContext object at 0x7f5472764490>
Waf: Leaving directory `/tmp/nested/build'
'build' finished successfully (0.007s)
---------------

NOTE: Tasks created by task generators are somehow private objects. They should not be manipulated directly in the 'build' function, but rather by task generator methods.

=== Obtaining nodes

find_dir
find_or_declare
find_resource


