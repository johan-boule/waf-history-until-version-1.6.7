<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
>
<chapter>
	<title>The Waf architecture</title>
	<section>
		<title>The core library</title>
		<para>
			Waf is based on 12 modules which constitute the core library. They are located in the directory <filename>wafadmin/</filename>. The modules located under <filename>wafadmin/Tools</filename> add support for programming languages and more tools, but are not essential for the Waf core.
<table>
<title>The core library</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colname='c1'/>
<colspec colname='c2'/>

<thead>
<row>
  <entry>Module</entry>
  <entry>Role</entry>
</row>
</thead>

<tbody>

<row>
  <entry>Build</entry>
  <entry>Defines the build context class, which holds the data for one build (paths, configuration data)</entry>
</row>

<row>
  <entry>Configure</entry>
  <entry>Contains the configuration context class, which is used for launching configuration tests, and the extension system</entry>
</row>

<row>
  <entry>Constants</entry>
  <entry>Provides the constants used in the project</entry>
</row>

<row>
  <entry>Environment</entry>
  <entry>Contains a dictionary class which supports a lightweight copy scheme and provides persistence services</entry>
</row>

<row>
  <entry>Logs</entry>
  <entry>Provide a logging system</entry>
</row>

<row>
  <entry>Node</entry>
  <entry>Contains the filesystem representation class</entry>
</row>

<row>
  <entry>Options</entry>
  <entry>Provides a custom command-line option processing system based on optparse</entry>
</row>

<row>
  <entry>Runner</entry>
  <entry>Contains the task execution system (threaded producer-consumer)</entry>
</row>

<row>
  <entry>Scripting</entry>
  <entry>Constitutes the entry point of the Waf application, use the command-line for launching the configuration, the build, etc</entry>
</row>

<row>
  <entry>TaskGen</entry>
  <entry>Provide the task generator system, and its extension system based on method addition</entry>
</row>

<row>
  <entry>Task</entry>
  <entry>Contains the task classes, and the task containers.</entry>
</row>

<row>
  <entry>Utils</entry>
  <entry>Contains the support functions and classes re-used in other Waf modules</entry>
</row>


</tbody>
</tgroup>
</table>
	</para>

	<para>
		The essential classes and methods from the core library are represented on the following diagram:
		<graphic format="png" fileref="classes.png" align="center"/>
	</para>

	</section>

	<section>
		<title>Build context instances</title>
		<para>
			Executing tasks, accessing the file system and consulting the results of a previous build are very different concerns which have to be encapsulated properly. The core class representing a build is a build context.
		</para>
		<sect2>
			<title>Build context and persistency</title>
			<para>
				The build context holds all the information necessary for a build. To accelerate the startup, a part of the information is stored and loaded between the runs. The persistent attributes are the following:
<table>
<title>Build context persistency</title>

<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colname='c1'/>
<colspec colname='c2'/>

<thead>
<row>
  <entry>Attribute</entry>
  <entry>Information</entry>
</row>
</thead>

<tbody>

<row>
  <entry>root</entry>
  <entry>Node representing the root of the filesystem</entry>
</row>
<row>
  <entry>srcnode</entry>
  <entry>Node representing the source directory</entry>
</row>
<row>
  <entry>bldnode</entry>
  <entry>Node representing the build directory</entry>
</row>
<row>
  <entry>node_sigs</entry>
  <entry>File hashes (dict mapping Node ids to hashes)</entry>
</row>
<row>
  <entry>node_deps</entry>
  <entry>Implicit dependencies (dict mapping Node ids)</entry>
</row>
<row>
  <entry>raw_deps</entry>
  <entry>Implicit file dependencies which could not be resolved (dict mapping Node ids to lists of strings)</entry>
</row>
<row>
  <entry>task_sigs</entry>
  <entry>Signature of the tasks previously run (dict mapping a Task id to a hash)</entry>
</row>
<row>
  <entry>id_nodes</entry>
  <entry>Sequence for generating unique node instance ids (id of the last Node created)</entry>
</row>

</tbody>
</tgroup>
</table>
			</para>
		</sect2>
		<sect2>
			<title>Build context access</title>
			<para>
				In previous Waf releases, the build context was supposed to be a unique object (one build active at a time). To enable the use of Waf as a library, the dependency on the singleton <emphasis>Build.bld</emphasis> was removed. This implies that each object should be able to obtain its build context from its attributes. Here are a few examples:
<table>
<title>Build context access</title>

<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colname='c1'/>
<colspec colname='c2'/>

<thead>
<row>
  <entry>Object type</entry>
  <entry>Build context access</entry>
</row>
</thead>

<tbody>

<row>
  <entry>Node</entry>
  <entry>self.__class__.bld</entry>
</row>
<row>
  <entry>task_gen</entry>
  <entry>self.bld</entry>
</row>
<row>
  <entry>Task</entry>
  <entry>self.generator.bld</entry>
</row>

</tbody>
</tgroup>
</table>
			</para>
		</sect2>
		<sect2>
			<title>Parallelization concerns</title>
			<para>
				Build contexts perform an <emphasis>os.chdir</emphasis> call before starting to execute the tasks. When running build contexts within build contexts (tasks), the current working directory may cause various problems. To work around them, it may be necessary to inject code (replace bld.compile) and to change the compilation rules (compile from the filesystem root).
			</para>
			<para>
				Direct <emphasis>Node</emphasis> instances are not used anywhere in the Waf code. Instead, each build context creates a new Node subclass (bld.node_class), on which the build context instance is attached as a class attribute.
			</para>
		</sect2>
	</section>


	<section>
		<title>Overview of the Waf execution</title>
		<para>
		</para>
		<sect2>
			<title>The scripting system</title>
			<para>
				The Waf script contains a tarball of the <filename>wafadmin</filename> directory, it is included in a commentary line where all the newline characters have been replaced (base64 and ascii85 encodings have been used in previous releases). When Waf is launched, the <filename>wafadmin</filename> directory is automatically extracted in the current directory if it cannot be found on the system.
			</para>
			<para>
				After finding the <filename>wafadmin</filename> directory, the function <emphasis>Scripting.prepare</emphasis> is executed, it loads the top-level wscript file, and then calls the function main to perform the configuration, the build or the installation. New commands may be added by overriding the main function, and catching the operations to perform (from the top-level wscript file):
				<programlisting language="python">
import sys, Options, Scripting
Options.cmds.append("meow")
oldmain = Scripting.main
def main():
	if Options.commands['meow']:
		print "meow"
		sys.exit(0)
	oldmain()
Scripting.main = main
				</programlisting>
				With the previous code snippet, the execution will be:
				<programlisting language="shell">
$ waf meow
meow
				</programlisting>
			</para>
			<para>
				The rest of the execution usually results in calling configuration context or build context instances. For single builds, the build context is stored on a singleton <emphasis>Build.bld</emphasis> which may be used after the build finished (shutdown function). The singleton is provided for convenience and its use should be limited to simple projects.
			</para>
		</sect2>
		<sect2>
			<title>Filesystem access</title>
			<para>
				Filesystem access is performed through an abstraction layer formed by the build context and <emphasis>Node</emphasis> instances. The data structure was carefully designed to maximize performance, so it is unlikely that it will change again in the future. The idea is to represent one file or one directory by a single Node instance. Dependent data such as file hashes are stored on the build context object and allowed to be persisted. Three kinds of nodes are declared: files, build files and folders. The nodes in a particular directory are unique, but build files used in several variant add duplicate entry on the build context cache.
			</para>
			<para>
				To access a file, the methods <emphasis>Node::find_resource</emphasis>, <emphasis>Node::find_build</emphasis> (find an existing resource or declare a build node) and <emphasis>Node::find_dir</emphasis> must be used. While searching for a particular node, the folders are automatically searched once for the files. Old nodes (which do not have a corresponding file) are automatically removed, except for the build nodes. In some cases (lots of files added and removed), it may be necessary to perform a <emphasis>Waf clean</emphasis> to eliminate the information on build files which do not exist anymore.
			</para>
		</sect2>
		<sect2>
			<title>Task classes</title>
			<para>
				The whole process of generating tasks through Waf is performed by methods added on the class task_gen by code injection. This often puzzles the programmers used to static languages where new functions or classes cannot be defined at runtime.
			</para>
			<para>
				The task generators automatically inherit the build context attribute <emphasis>bld</emphasis> when created from bld.new_task_gen. Likewise, tasks created from a task generator (create_task) automatically inherit their generator, and their build context. Direct instanciation may result in problems when running Waf as a library.
			</para>
			<para>
				The tasks created by task generator methods are automatically stored on the build context task manager, which stores the task into a task group. The task groups are later used by the scheduler to obtain the task which may run (state machine). Target (un)installation is performed right after a task has run, using the method <emphasis>install</emphasis>.
			</para>
		</sect2>
		<sect2>
			<title>Threading concerns</title>
			<para>
				Nearly all the code is executed in the main thread. The other threads are merely waiting for new tasks, and executing the methods <emphasis>run</emphasis> from the task instances. Such methods should contain as little code as possible, and avoid sharing data with other parts of Waf. If code affecting the scheduler must be executed, it is recommended to overload the method <emphasis>get_out</emphasis> of the scheduler and to share the data in an event-like manner (data is attached to the task, and the method get_out executes the code). Adding additional tasks from a running task is demonstrated <xref linkend="runtime_discovered_outputs"/>.
			</para>
		</sect2>
	</section>

	<section>
		<title>Performance and build accuracy</title>
		<para>
			From the experience with tools such as Scons, users may be concerned about performance and think that all build systems based on interpreted languages such as Python would not scale. We will now describe why this is not the case for Waf and why Waf should be chosen for building very large projects.
		</para>

		<sect2>
			<title>Comparing Waf against other build systems</title>
			<para>
				Since Waf considers the file contents in the build process, it is often thought that Waf would be much slower than make. For a test project having 5000 files (generated from the script located in <filename>tools/genbench.py</filename>), on a 1.5Ghz computer, the Waf runtime is actually slightly faster than the Gnu/Make one (less than one second). The reason is the time to launch a new process - make is usually called recursively, once by directory. For huge projects, calling make recursively is necessary for flexibility, but it hurts performance (launch many processes), and cpu utilization (running tasks in parallel). Make-based build systems such as CMake or autotools inherit the limitations of Make.
			</para>
			<para>
				Though Waf uses a similar design as SCons, Waf is about 15 times faster for similar features and without sacrificing build accuracy. There are many reasons for this, among them:
				<itemizedlist>
					<listitem>The Waf datastructures (filesystem representation, tasks) have been carefully chosen to minimize memory usage and data duplication</listitem>
					<listitem>For a project of the same size, Scons requires at least 10 times as many function calls</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Optimization and Waf hot spots</title>
			<para>
				The best locations to obtain profiling information are the files <filename>Scripting.py</filename> and <filename>Build.py</filename>. Profiling is hardly necessary in practice, and some comments are left for the curious to make experiment with the code. Here is the output obtained from a project generated with <filename>tools/genbench.py</filename> in which the targets are up-to-date. In practice, Waf takes about 2 seconds to decide that the project is up-to-date.
				<programlisting>
Sun Nov  9 19:22:59 2008    prof.txt

         959695 function calls (917845 primitive calls) in 3.195 CPU seconds

   Ordered by: internal time
   List reduced from 187 to 10 due to restriction 10

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.531    0.531    0.531    0.531 {cPickle.dump}
73950/42150    0.223    0.000    0.276    0.000 Environment.py:66(__getitem__)
     5000    0.215    0.000    0.321    0.000 Task.py:770(compute_sig_implicit_deps)
   204434    0.180    0.000    0.180    0.000 {method 'update' of '_hashlib.HASH' objects}
     5050    0.170    0.000    0.551    0.000 Task.py:706(sig_vars)
    10000    0.144    0.000    0.301    0.000 Utils.py:98(h_file)
25255/15205    0.113    0.000    0.152    0.000 Node.py:329(abspath)
    15050    0.107    0.000    0.342    0.000 Task.py:481(unique_id)
    15301    0.102    0.000    0.102    0.000 Environment.py:50(variant)
   132062    0.097    0.000    0.097    0.000 {method 'get' of 'dict' objects}
				</programlisting>
				From the profile information, it appears that the visible hot spots are, in order:
				<itemizedlist>
					<listitem>The persistency implemented by the cPickle module (the cache file to serialize takes about 3Mb)</listitem>
					<listitem>Accessing configuration data from the Environment instances</listitem>
					<listitem>Computing implicit dependencies (the test project contains lots of interleaved dependencies)</listitem>
				</itemizedlist>
			</para>
			<para>
				The computation of implicit dependencies (searching for headers when a c file is to be compiled) may take a significant time, but is only performed when the targets have to be compiled. The preprocessing time (<filename>preproc.py</filename>) is therefore invisible. In practice, the optimizations should aim at reducing the datastructure sizes (for cPickle) and the amount of function calls (overall runtime).
			</para>
		</sect2>

		<sect2>
			<title>Waf hashing schemes and target caching</title>
			<para>
				To rebuild targets when source file change, the file contents are hashed and compared. The hashes are used to identify the tasks, and to retrieve the files from a cache (folder defined by the environment variable <emphasis>WAFCACHE</emphasis>). Besides command-lines, this scheme also takes file dependencies into account: it is more accurate than caching systems such as <emphasis>ccache</emphasis>.
			</para>
			<para>
				The Waf hashing scheme uses the md5 algorithm provided by the Python distribution. It is fast enough for up to about 100Mb of data and about 10000 files.
			</para>
			<para>
				If more data is present, it may be necessary to use a faster hashing algorithm. An implementation of the fnv algorithm is present in the Waf distribution, and can replace md5 without really degrading accuracy.
			</para>
			<para>
				If more files are present, it may be necessary to replace the hashing system by a file name+size+timestamp hash scheme. An example is provided in the comment section of the module <filename>Utils.py</filename>. That scheme is more efficient but less accurate: the Waf cache should not be used with this scheme.
			</para>
		</sect2>
	</section>
</chapter>

