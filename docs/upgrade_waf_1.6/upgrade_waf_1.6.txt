Upgrade to waf 1.6 (draft)
=========================
:author: Thomas Nagy
:quotes.++:

[preface]
== Introduction

////
a2x -L -a toc --icons-dir=.   -v   --icons -d article -f pdf upgrade_waf_1.6.txt
////

Copyright (C) 2010 Thomas Nagy

Copies of this document may be redistributed, verbatim, and for non-commercial
purposes. The license for this document is
 http://creativecommons.org/licenses/by-nc-nd/3.0/[by-nc-nd license].

=== Waf 1.5 limitations

The waf build system was first created to provide an alternative for the autotool-based build systems based on a single programming language. To ease the development, a few assumptions were made, and over the time it became clear that they had become a limitation for specific corner cases, among others:

- sometimes, some files are generated in the source directory and are kept in the source control system
- there may be more than one kind of build command
- some configuration apis may be useful in the build section
- it may be interesting to use waf as a library from another system
- some apis were private (node objects)

=== Goals of Waf 1.6

The main goals of waf 1.6 are:

. to remove most assumptions/restrictions present in waf 1.5 (nodes, build directory, reduce the coupling between the modules)
. to optimize the code base (execution time, source code size, compatibility with different python versions)
. to improve the apis and the user experience (make the apis more intuitive, expose more classes and functions, improve the error handling)

=== Purpose of this document

The apis had to be changed to make the changes described in the previous section, the apis (modules, classes. functions).
This document describes the main changes compared to the previous version, waf 1.5.
The waf book for waf 1.6 should be the reference for new users and for projects upgrading from previous waf versions such as waf 1.4.






== Changes in the user scripts

=== The attributes 'srcdir' and 'blddir'

The attributes 'srcdir' and 'blddir' have been renamed to 'top' and 'out' respectively:

[source,python]
---------------
#srcdir = '.' # old
#blddir = 'build' # old
top = '.'
out = 'build'

def configure(ctx):
    pass
---------------

=== The command 'options'

The method set_options has been renamed to 'options':

[source,python]
---------------
top = '.'
out = 'build'

def options(opt):
	pass

def configure(ctx):
	pass
---------------

=== The method 'recurse'

The context class for all commands has a unique method named 'recurse'. The methods 'add_subdirs', 'sub_config' and 'sub_options' disappear:

[source,python]
---------------
def options(opt):
	#ctx.sub_options('src') # old
	ctx.recurse('src')

def configure(ctx):
	#ctx.sub_config('src') # old
	ctx.recurse('src')

def build(ctx):
	#ctx.add_subdirs('src') # old
	ctx.recurse('src')
---------------

=== Tool declaration

For consistency with the user scripts, the method 'detect' in waf tools has been renamed to 'configure'. The method 'set_options' is now called 'options' and is consistent with waf scripts.

=== Task generator declaration

The build context method 'new_task_gen' disappears, and is replaced by '__call__'. The task generator subclasses have been removed completely, so only keyword arguments are accepted. For example:

[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(bld):
	# bld.new_task_gen('cc', 'cprogram', source='main.c', target='app') # old
	bld(features='cc cprogram', source='main.c', target='app')
---------------

=== Configuration apis

The configuration apis may be used during the build phase. The only inconvenience is to provide a log file to obtain some output:

[source,python]
---------------
def options(opt):
    opt.tool_options('compiler_cxx')

def configure(conf):
    conf.check_tool('compiler_cxx')
    conf.check(header_name='stdio.h', features='cxx cprogram')

def build(bld):

    if bld.cmd != 'clean':
        bld.log = open('test.log', 'w')
        try:
            bld.find_program('gpg', var='GPG')
            bld.check(header_name='sadlib.h', features='cxx cprogram')
        except bld.errors.ConfigurationError:
            pass
        finally:
            bld.log.close() # always close the file or it may be empty
            bld.log = None
---------------






== Node classes

=== Targets in the source directory or in any location

The build may now update files under the source directory (versioned files). In this case, the task signature may not be used as node signature (source files signatures are computed from a hash of the file). Here is an example:

[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(ctx):
	# create the node next to the current wscript file - no build directory
	node = bld.path.make_node('foo.txt')
	bld(rule='touch ${TARGET}', always=True, update_outputs=True, target=node)
---------------

For nodes present out of the build directory, the node signature must be set to the file hash immediately after the file is created or modified (not the task signature set by default):

[source,python]
---------------
import Task

@Task.update_outputs
class copy(Task.Task):
	run_str = '${CP} ${SRC} ${TGT}'
---------------

=== Enable the top-level directory to be the build directory

Although discouraged, it is possible to avoid the use of a build directory:

[source,python]
---------------
top = '.'
out = '.'

def configure(ctx):
    pass
---------------

=== Enable nodes in various attributes

Nodes are now accepted in the task generator source and target attributes

[source,python]
---------------
def configure(ctx):
    pass

def build(ctx):
    src = ctx.path.find_resource('foo.a')
    tgt = ctx.path.find_or_declare('foo.b')

    bld(rule='cp ${SRC} ${TGT}', source=[src], target=[tgt])
---------------

In the case of includes, the node may be used to control exactly the include path to add:

[source,python]
---------------
def configure(ctx):
    ctx.check_tool('gcc')

def build(ctx):
	bld(features='cc', source='main.c', includes=[bld.path])
	bld(features='cc', source='main.c', includes=[bld.path.get_bld()])
---------------

The output will be:

[source,shishell]
---------------
$ waf -v
Waf: Entering directory `/foo/test/build'
[1/2] cc: main.c -> build/main.c.0.o
03:01:20 runner ['/usr/bin/gcc', '-I/foo/test', '../main.c', '-c', '-o', 'main.c.0.o']
[2/2] cc: main.c -> build/main.c.1.o
03:01:20 runner ['/usr/bin/gcc', '-I/foo/test/bld', '../main.c', '-c', '-o', 'main.c.1.o']
Waf: Leaving directory `/foo/test/build'
'build' finished successfully (0.476s)
---------------

Because node objects are accepted directly, the attribute allnodes has been removed, and the nodes should be added to the list of source directly:

[source,python]
---------------
from waflib.TaskGen import extension
@extension('.c.in')
def some_method(self, node):
	out_node = node.change_ext('.c')
	task = self.create_task('in2c', node, out_node)

	#self.allnodes.append(out_node) # old
	self.source.append(out_node)
---------------

== Internal apis

=== Syntax

Python 3 is now the default syntax. Waf now runs unmodified for 2.6, 2.7, 3.0 and 3.1. Upon execution, a detection is performed and the code
is then converted for python 2.3, 2.4 and 2.5 if necessary. It is far easier to modify Python3 code to run on Python2 than porting Python 2 code to Python 3.






== New commands

=== Obtaining waf tools from the network

The call to 'conf.check_tool' will normally fail if the tool cannot be found.

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
	conf.check_tool('swig')
---------------

By configuring with the option '--download', it is possible to go and download the missing tools
from a remote repository.

[source,shishell]
---------------
$ ./waf configure --download
Checking for Setting top to              : /comp/test
Checking for Setting out to              : /comp/test/build
http://waf.googlecode.com/svn//branches/waf-1.6/waflib/extras/swig.py
downloaded swig from http://waf.googlecode.com/svn//branches/waf-1.6/waflib/extras/swig.py
Checking for Checking for program swig   : /usr/bin/swig
'configure' finished successfully (0.408s)
---------------

The list of remote and locations may be configured from the user scripts. It is also
recommended to change the function 'Configure.download_check' to check the downloaded tool
from a white list and to avoid potential security issues. This may be unnecessary on local
networks.

[source,python]
---------------
top = '.'
out = 'build'

from waflib import Configure, Utils, Context

Context.remote_repo = ['http://waf.googlecode.com/svn/']
Context.remote_locs = ['branches/waf1.6/waflib/extras']

def check(path):
	if not Utils.h_file(path) in whitelist:
		raise ValueError('corrupt file, try again')
Configure.download_check = check

def configure(conf):
    conf.check_tool('swig')
---------------

=== waf list

A new command named 'list' is used to list the valid targets (task generators) for "waf build --targets=x"

[source,shishell]
---------------
$ waf list
foo.exe
my_shared_lib
my_static_lib
test_shared_link
test_static_link
'list' finished successfully (0.029s)

$ waf clean --targets=foo.exe
Waf: Entering directory `/disk/comp/waf-1.6/demos/c/build'
[1/2] cc: program/main.c -> build/program/main.c.0.o
[2/2] cprogram: build/program/main.c.0.o -> build/foo.exe
Waf: Leaving directory `/disk/comp/waf-1.6/demos/c/build'
'build' finished successfully (0.154s)
---------------

=== waf step

The new command 'step' is used to execute specific tasks and to return the exit status or any error message. It is particularly useful for debugging:

[source,shishell]
---------------
$ waf clean step --file=test_shlib.c
'clean' finished successfully (0.017s)
Waf: Entering directory `/disk/comp/waf-1.6/demos/c/build'
cc: shlib/test_shlib.c -> build/shlib/test_shlib.c.1.o
 -> 0
cshlib: build/shlib/test_shlib.c.1.o -> build/shlib/libmy_shared_lib.so
 -> 0
Waf: Leaving directory `/disk/comp/waf-1.6/demos/c/build'
'step' finished successfully (0.146s)
---------------

To restrict the tasks to execute, just prefix the names by 'in:' or 'out:':

[source,shishell]
---------------
$ waf step --file=out:build/shlib/test_shlib.c.1.o
Waf: Entering directory `/disk/comp/waf-1.6/demos/c/build'
cc: shlib/test_shlib.c -> build/shlib/test_shlib.c.1.o
 -> 0
Waf: Leaving directory `/disk/comp/waf-1.6/demos/c/build'
'step' finished successfully (0.091s)
---------------

* Environment -> ConfigSet
* only lists are allowed in ConfigSet
* only the build-related commands require a configured project
* new variant system + build context commands
* merge the include system for c, c+, d, gas and nasm
* rename apply_core -> process_source
* rename apply_rule -> process_rule
* rename Task.TaskBase.classes -> Task.classes
* remove Task.TaskManager and Build.BuildContext.all_task_gen to improve the build group handling
* remove program_USELIB, shlib_USELIB staticlib_USELIB support
* infer the build directory from the lock filename

installation methods
* use tasks for target installation

nodes
* removed the pseudo glob in installation methods
* eliminate find_sources_in_dirs
* node.__class__.bld → node.ctx
* post task generators in a lazy manner

context and commands
* Utils.load_tool -> Context.load_tool
* let the commands access node objects

modules
* the modules Utils.py and Logs.py are now independent from the rest of waf (imports)
* improve the exception handling (WscriptError was removed, use WafError)
* eliminate Constants

